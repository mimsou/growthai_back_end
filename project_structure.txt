src\app.controller.spec.ts 
import { Test, TestingModule } from '@nestjs/testing';
import { AppController } from './app.controller';
import { AppService } from './app.service';

describe('AppController', () => {
  let appController: AppController;

  beforeEach(async () => {
    const app: TestingModule = await Test.createTestingModule({
      controllers: [AppController],
      providers: [AppService],
    }).compile();

    appController = app.get<AppController>(AppController);
  });

  describe('root', () => {
    it('should return "Hello World!"', () => {
      expect(appController.getHello()).toBe('Hello World!');
    });
  });
});
 
src\app.controller.ts 
import { Controller, Get } from '@nestjs/common';
import { AppService } from './app.service';

@Controller()
export class AppController {
  constructor(private readonly appService: AppService) {}

  @Get()
  getHello(): string {
    return this.appService.getHello();
  }
}
 
src\app.module.ts 
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { ConfigModule, ConfigService } from '@nestjs/config';
import { AuthModule } from './auth/auth.module';
import { SEOModule } from './seo/seo.module';
import { AuditSessionModule } from './audit/audit-session.module';
import { AIModule } from './ai/ai.module';
import { CrawlerModule } from './crawler/core/crawler.module';


@Module({
  imports: [
    ConfigModule.forRoot({
      isGlobal: true,
      envFilePath: '.env',
    }),
    MongooseModule.forRootAsync({
      imports: [ConfigModule],
      useFactory: async (configService: ConfigService) => ({
        uri: configService.get<string>('MONGO_URI'),
        useNewUrlParser: true,
        useUnifiedTopology: true,
        maxPoolSize: configService.get<number>('MONGO_POOL_SIZE', 10),
        maxIdleTimeMS: configService.get<number>('MONGO_MAX_IDLE_TIME_MS', 30000),
        connectTimeoutMS: configService.get<number>('MONGO_CONNECT_TIMEOUT_MS', 30000),
      }),
      inject: [ConfigService],
    }),
    AuthModule,
    SEOModule,
    AuditSessionModule,
    AIModule,
    CrawlerModule
  ],
  controllers: [],
  providers: [],
})
export class AppModule {}
 
src\app.service.ts 
import { Injectable } from '@nestjs/common';

@Injectable()
export class AppService {
  getHello(): string {
    return 'Hello World!';
  }
}
 
src\main.ts 
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import { ValidationPipe } from '@nestjs/common';
import { IoAdapter } from '@nestjs/platform-socket.io';
import * as os from 'os';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);

  // Enable CORS
  app.enableCors({
    origin: 'http://localhost:3000',
    methods: 'GET,HEAD,PUT,PATCH,POST,DELETE,OPTIONS',
    credentials: true,
    allowedHeaders: ['Content-Type', 'Authorization'],
  });

  // Configure WebSocket adapter with CORS
  app.useWebSocketAdapter(new IoAdapter(app));

  app.setGlobalPrefix('api');
  app.useGlobalPipes(new ValidationPipe());

  // Configure thread pool
  const numCPUs = os.cpus().length;
  const maxThreads = Math.min(numCPUs, parseInt(process.env.CRAWLER_MAX_THREADS) || 4);
  process.env.UV_THREADPOOL_SIZE = maxThreads.toString();
  
  await app.listen(process.env.PORT || 5000);
}bootstrap(); 
    C:\Workspace\Web\Ai Business grow project\Back_end\src\ai\ai.controller.ts 
import { Controller, Post, Body, Res } from '@nestjs/common';
import { AIService } from './ai.service';
import { OllamaService } from './agent/ollama.agent.service';
import { AiPromptService } from './prompt/ai.prompt.service';
import { Response } from 'express'; // Import Express Response

@Controller('ai')
export class AiController {
  constructor(private readonly aiService: AIService, private readonly ollamaService: OllamaService, private readonly aiPromptService: AiPromptService) {}

  @Post('ask')
  async Ask(@Body() data: { prompt: string; seoSubject: string, sessionId: string }, @Res() res: Response): Promise<any> {
    const content = await this.aiService.getData(data.seoSubject, data.sessionId);
    const prompt = await this.aiPromptService.getPromptBySeoSubject(data.seoSubject);

    res.setHeader('Content-Type', 'application/json');
    res.setHeader('Transfer-Encoding', 'chunked'); // Important for streaming response

    // Call the service to stream the AI response
    await this.ollamaService.streamResponse(prompt, content, res);
  }
}
 
    C:\Workspace\Web\Ai Business grow project\Back_end\src\ai\ai.module.ts 
import { Module , forwardRef } from '@nestjs/common';
import { AIService } from './ai.service';
import { SeoStrategy } from './ai.seo.strategy'; 
import { RobotsService } from '../seo/robots/robots.service';
import { SEOModule } from 'src/seo/seo.module';
import { SEOEnum } from 'src/enum/seo.enum';
import { MongooseModule } from '@nestjs/mongoose';
import { SeoServiceInterface } from 'src/seo/seo.interface';
import { RobotsData, RobotsDataSchema } from '../seo/robots/robots-data.schema';
import { PromptData, PromptDataSchema } from  '../ai/prompt/ai.prompt-data.schema';
import { AiController } from './ai.controller';
import { AgentModule } from './agent/agent.modules';
import { AiPromptService } from './prompt/ai.prompt.service';


@Module({
  imports: [
    MongooseModule.forFeature([
      { name: RobotsData.name, schema: RobotsDataSchema },
      { name: PromptData.name, schema: PromptDataSchema },
    ]),
    AgentModule
  ],
  providers: [AIService,SeoStrategy,
      {
      provide: 'seoServices',
      useFactory: (robotsService: RobotsService) => {
        const seoServices = new Map<string, SeoServiceInterface>();
        seoServices.set(SEOEnum.ROBOT, robotsService);
        return seoServices;
      },
      inject: [RobotsService],
    },
    RobotsService,
    AiPromptService],
    controllers: [AiController],
  exports: [AIService],
})
export class AIModule {
}
 
    C:\Workspace\Web\Ai Business grow project\Back_end\src\ai\ai.seo.strategy.ts 
import { Inject, Injectable } from '@nestjs/common';
import { SeoServiceInterface } from '../seo/seo.interface';

@Injectable()
export class SeoStrategy {
  constructor( @Inject('seoServices') private readonly seoServices: Map<string, SeoServiceInterface>) {}

  async execute(seoSubject: string, sessionId:string): Promise<any> {
    const seoService = this.seoServices.get(seoSubject);
    if (!seoService) {
      throw new Error(`No SEO service found for subject: ${seoSubject}`);
    }
    return await seoService.getData(sessionId);
  }

  addSeoService(seoSubject: string, seoService: SeoServiceInterface): void {
    this.seoServices.set(seoSubject, seoService);
  }
} 
    C:\Workspace\Web\Ai Business grow project\Back_end\src\ai\ai.service.ts 
import { Injectable } from '@nestjs/common';
import { SeoStrategy } from './ai.seo.strategy';

@Injectable()
export class AIService {
  constructor(private readonly seoStrategy: SeoStrategy) {}
  async getData(seoSubject:string, sessionId:string): Promise<any> {
     return this.seoStrategy.execute(seoSubject, sessionId);
  }
} 
        C:\Workspace\Web\Ai Business grow project\Back_end\src\ai\agent\agent.modules.ts 
import { Module } from '@nestjs/common';
 import { OllamaService } from './ollama.agent.service';
import { HttpModule } from '@nestjs/axios';
 
 const agentProviders = [
        OllamaService,
 ];

 @Module({
   imports: [HttpModule],
   providers: [...agentProviders],
   exports: [...agentProviders],
 })
 export class AgentModule {}
 
        C:\Workspace\Web\Ai Business grow project\Back_end\src\ai\agent\ollama.agent.service.ts 
import { Injectable, HttpException, HttpStatus } from '@nestjs/common';
import { HttpService } from '@nestjs/axios';
import { ConfigService } from '@nestjs/config';
import { Response } from 'express';

@Injectable()
export class OllamaService {
  private readonly baseUrl: string;
  private readonly httpService: HttpService;

  constructor(private readonly configService: ConfigService, httpService: HttpService) {
    this.baseUrl = this.configService.get<string>('LOCAL_IA_AGENT_SERVICE'); // Base URL from environment variable
    this.httpService = httpService;
  }

  async streamResponse(prompt: string, context: string, res: Response): Promise<void> {
    const endpoint = `${this.baseUrl}/api/generate`;

    try {
      const response = await this.httpService.post(endpoint, {
        model: 'llama3.1:8b',
        prompt: `${prompt} ${context}`,
      }, { responseType: 'stream' }).toPromise();

      if (!response || !response.data) {
        throw new HttpException(`Error contacting the AI model`, HttpStatus.INTERNAL_SERVER_ERROR);
      }

      response.data.on('data', (chunk) => {
        res.write(chunk);
      });

      response.data.on('end', () => {
        res.end();
      });
    } catch (error) {
      console.error(error);
      throw new HttpException(`Error contacting the AI model: ${error.message}`, HttpStatus.INTERNAL_SERVER_ERROR);
    }
  }
}
 
            C:\Workspace\Web\Ai Business grow project\Back_end\src\ai\prompt\ai.prompt-data.schema.ts 
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document } from 'mongoose';

@Schema()
export class PromptData extends Document {
  @Prop({ required: true })
  seoSubject: string;

  @Prop()
  content?: string;
}

export const PromptDataSchema = SchemaFactory.createForClass(PromptData); 
            C:\Workspace\Web\Ai Business grow project\Back_end\src\ai\prompt\ai.prompt.service.ts 

import { Injectable } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import {PromptData } from './ai.prompt-data.schema';

@Injectable()
export class AiPromptService {
  constructor(
    @InjectModel(PromptData.name) private promptDataModel: Model<PromptData>,
  ) {}

  async getPromptBySeoSubject(seoSubject: string): Promise<string | null> {
    const result = await this.promptDataModel.find({ seoSubject: seoSubject }).exec();
    if (!result) return null;
    return result.map(item => item.content).join('\n');
  }
}

 
                C:\Workspace\Web\Ai Business grow project\Back_end\src\audit\audit-session.controller.ts 
import { Controller, Post, UseGuards, Request } from '@nestjs/common';
import { AuditSessionService } from './audit-session.service';
import { JwtAuthGuard } from '../common/guards/jwt-auth.guard';

@Controller('audit')
export class AuditSessionController {
  constructor(private readonly auditSessionService: AuditSessionService) {}

  //@UseGuards(JwtAuthGuard)
  @Post('new')
  async createAuditSession(@Request() req: any) {
    //console.log(req.user.id);
    const userId = "66eefa9b8319d7e5b17f4d70"
    const session = await this.auditSessionService.createAuditSession(userId);
    return { auditId: session.auditId };
  }
}
 
                C:\Workspace\Web\Ai Business grow project\Back_end\src\audit\audit-session.module.ts 
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { AuditSessionController } from './audit-session.controller';
import { AuditSessionService } from './audit-session.service';
import { AuditSession, AuditSessionSchema } from './audit-session.schema';

@Module({
  imports: [MongooseModule.forFeature([{ name: AuditSession.name, schema: AuditSessionSchema }])],
  controllers: [AuditSessionController],
  providers: [AuditSessionService],
})
export class AuditSessionModule {}
 
                C:\Workspace\Web\Ai Business grow project\Back_end\src\audit\audit-session.schema.ts 
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document } from 'mongoose';
import { v4 as uuidv4 } from 'uuid'; 

@Schema()
export class AuditSession extends Document {
  @Prop({ required: true, default: uuidv4 })
  auditId: string;

  @Prop({ required: true })
  userId: string;

  @Prop({ required: true, default: Date.now })
  startDateTime: Date;
}

export const AuditSessionSchema = SchemaFactory.createForClass(AuditSession);
 
                C:\Workspace\Web\Ai Business grow project\Back_end\src\audit\audit-session.service.ts 
import { Injectable } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { AuditSession } from './audit-session.schema';

@Injectable()
export class AuditSessionService {
  constructor(
    @InjectModel(AuditSession.name) private readonly auditSessionModel: Model<AuditSession>,
  ) {}

  async createAuditSession(userId: string): Promise<AuditSession> {
    const newAuditSession = new this.auditSessionModel({ userId });
    return newAuditSession.save();
  }
}
 
                    C:\Workspace\Web\Ai Business grow project\Back_end\src\auth\auth.controller.ts 
import { Body, Controller, Get, Post, UseGuards, UnauthorizedException, Req } from '@nestjs/common';
import { AuthService } from './auth.service';
import { RegisterUserDto } from './dto/register-user.dto';
import { LoginUserDto } from './dto/login-user.dto';
import { AuthGuard } from '@nestjs/passport';
import { GoogleTokenDto } from './dto/google-token.dto';

@Controller('auth')
export class AuthController {
  constructor(private readonly authService: AuthService) {}

  @Post('register')
  async register(@Body() registerDto: RegisterUserDto) {
    return this.authService.register(registerDto);
  }

  @Post('login')
  async login(@Body() loginDto: LoginUserDto) {
    const user = await this.authService.validateUser(loginDto.email, loginDto.password);
    if (!user) {
      throw new UnauthorizedException('Invalid credentials');
    }
    return this.authService.login(user);
  }

  @Post('google')
  async googleLogin(@Body() googleTokenDto: GoogleTokenDto) {
    return this.authService.verifyGoogleTokenAndLogin(googleTokenDto.token);
  }

  @UseGuards(AuthGuard('jwt'))
  @Post('protected')
  getProtected() {
    return "This is a protected route";
  }
}
 
                    C:\Workspace\Web\Ai Business grow project\Back_end\src\auth\auth.module.ts 
import { Module } from '@nestjs/common';
import { JwtModule } from '@nestjs/jwt';
import { PassportModule } from '@nestjs/passport';
import { AuthService } from './auth.service';
import { AuthController } from './auth.controller';
import { JwtStrategy } from './jwt.strategy';
import { MongooseModule } from '@nestjs/mongoose';
import { User, UserSchema } from '../users/user.schema';
import { UserService } from 'src/users/user.service';

@Module({
  imports: [
    MongooseModule.forFeature([{ name: User.name, schema: UserSchema }]),
    PassportModule,
    JwtModule.register({
      secret: process.env.JWT_SECRET || 'defaultSecret',
      signOptions: { expiresIn: '60m' },
    }),
  ],
  providers: [AuthService, UserService, JwtStrategy],
  controllers: [AuthController],
})
export class AuthModule {}
 
                    C:\Workspace\Web\Ai Business grow project\Back_end\src\auth\auth.service.ts 
import { Injectable, UnauthorizedException } from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import { UserService } from '../users/user.service';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { User } from '../users/user.schema';
import { JwtPayload } from './interfaces/jwt-payload.interface';
import { RegisterUserDto } from './dto/register-user.dto';
import * as bcrypt from 'bcrypt';
import { OAuth2Client } from 'google-auth-library';

@Injectable()
export class AuthService {

  private googleClient: OAuth2Client;
  constructor(
    @InjectModel(User.name) private userModel: Model<User>,
    private readonly userService: UserService,
    private readonly jwtService: JwtService,
  ) {
    console.log(process.env.GOOGLE_CLIENT_ID)
    this.googleClient = new OAuth2Client("244958252159-hl1ir8a7isdhpletnuuvbdobtdcfjebk.apps.googleusercontent.com");
  }

  async register(registerDto: RegisterUserDto) {
    const { username, password, email } = registerDto;
    const newUser = new this.userModel({ username, email, password });
    return newUser.save();
  }

  async validateUser(email: string, pass: string): Promise<any> {
    const user = await this.userModel.findOne({ email }).exec();
    if (user && await bcrypt.compare(pass, user.password)) {
      const { password, ...result } = user;
      return result;
    }
    return null;
  }

  async login(user: any) {
    const payload = { email: user.email, sub: user._id };
    return {
      access_token: this.jwtService.sign(payload),
    };
  }

  async verifyGoogleTokenAndLogin(token: string) {
    const ticket = await this.googleClient.verifyIdToken({
      idToken: token,
      audience: "244958252159-hl1ir8a7isdhpletnuuvbdobtdcfjebk.apps.googleusercontent.com",
    });
    const payload = ticket.getPayload();

    if (!payload) {
      throw new UnauthorizedException('Google token is invalid');
    }

    let user = await this.userService.findOne(payload.email);
    if (!user) {
      user = await this.userService.create({
        username: payload.name,
        email: payload.email,
        password: await bcrypt.hash(Math.random().toString(36).slice(-8), 10),
      });
    }

    return this.generateJwtToken(user);
  }
  async generateJwtToken(user: User) {
    const payload = { email: user.email, sub: user._id };
    return {
      access_token: this.jwtService.sign(payload),
    };
  }

  async validateUserByJwt(payload: JwtPayload): Promise<User> {
    return this.userModel.findOne({ _id: payload.sub }).exec();
  }
}
 
                    C:\Workspace\Web\Ai Business grow project\Back_end\src\auth\jwt.strategy.ts 
import { Injectable, UnauthorizedException } from '@nestjs/common';
import { PassportStrategy } from '@nestjs/passport';
import { ExtractJwt, Strategy } from 'passport-jwt';
import { AuthService } from './auth.service';
import { JwtPayload } from './interfaces/jwt-payload.interface';

@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy) {
  constructor(private authService: AuthService) {
    super({
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      ignoreExpiration: false,
      secretOrKey: process.env.JWT_SECRET || 'defaultSecret',
    });
  }

  async validate(payload: JwtPayload) {
    const user = await this.authService.validateUserByJwt(payload);
    if (!user) {
      throw new UnauthorizedException();
    }
    return user;
  }
}

 
                        C:\Workspace\Web\Ai Business grow project\Back_end\src\auth\dto\create-user.dto.ts 
import { IsEmail, IsNotEmpty, MinLength } from 'class-validator';

export class CreateUserDto {
  @IsNotEmpty()
  name: string;

  @IsEmail()
  email: string;

  @IsNotEmpty()
  @MinLength(6)
  password: string;
}
 
                        C:\Workspace\Web\Ai Business grow project\Back_end\src\auth\dto\google-token.dto.ts 
import { IsNotEmpty } from 'class-validator';

export class GoogleTokenDto {
  @IsNotEmpty()
  token: string;
} 
                        C:\Workspace\Web\Ai Business grow project\Back_end\src\auth\dto\login-user.dto.ts 
import { IsEmail, IsNotEmpty } from 'class-validator';

export class LoginUserDto {
  @IsEmail()
  email: string;

  @IsNotEmpty()
  password: string;
}

 
                        C:\Workspace\Web\Ai Business grow project\Back_end\src\auth\dto\register-user.dto.ts 
import { IsEmail, IsNotEmpty, MinLength } from 'class-validator';

export class RegisterUserDto {
  @IsNotEmpty()
  username: string;

  @IsEmail()
  email: string;

  @IsNotEmpty()
  @MinLength(6)
  password: string;
} 
                            C:\Workspace\Web\Ai Business grow project\Back_end\src\auth\interfaces\jwt-payload.interface.ts 
export interface JwtPayload {
    email: string;
    sub: string;
  }
   
                                    C:\Workspace\Web\Ai Business grow project\Back_end\src\common\guards\jwt-auth.guard.ts 
import { Injectable } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';

@Injectable()
export class JwtAuthGuard extends AuthGuard('jwt') {}
 
                                        C:\Workspace\Web\Ai Business grow project\Back_end\src\config\mongoose.config.ts 
import { MongooseModuleOptions } from '@nestjs/mongoose';
import * as dotenv from 'dotenv';

dotenv.config();

export const mongooseConfig: MongooseModuleOptions = {
  uri: process.env.MONGO_URI 
}; 
                                                C:\Workspace\Web\Ai Business grow project\Back_end\src\crawler\config\crawler-config.service.ts 
import { Injectable } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { InclusionExclusionService, Rule } from './inclusion-exclusion.service';
import { GeneralConfig } from './sub-configs/general.config';
import { SitemapConfig } from './sub-configs/sitemap.config';
import { DirectoryTreeConfig } from './sub-configs/directory-tree.config';
import { MultithreadingConfig } from './sub-configs/multithreading.config';
import { AsyncOperationsConfig } from './sub-configs/async-operations.config';
import { RateLimitConfig } from './sub-configs/rate-limit.config';
import { HttpHeaderConfig } from './sub-configs/http-header.config';

@Injectable()
export class CrawlerConfigService {
  private generalConfig: GeneralConfig;
  private sitemapConfig: SitemapConfig;
  private directoryTreeConfig: DirectoryTreeConfig;
  private multithreadingConfig: MultithreadingConfig;
  private specificUrlList: string[] = [];
  private customStartingPoints: string[] = [];
  private asyncOperationsConfig: AsyncOperationsConfig;
  private rateLimitConfig: RateLimitConfig;
  private httpHeaderConfig: HttpHeaderConfig;

  constructor(
    private configService: ConfigService,
    private inclusionExclusionService: InclusionExclusionService
  ) {
    this.generalConfig = new GeneralConfig(configService);
    this.sitemapConfig = new SitemapConfig(configService);
    this.directoryTreeConfig = new DirectoryTreeConfig(configService);
    this.multithreadingConfig = new MultithreadingConfig(configService);
    this.asyncOperationsConfig = new AsyncOperationsConfig(configService);
    this.rateLimitConfig = new RateLimitConfig(configService);
    this.httpHeaderConfig = new HttpHeaderConfig(configService);
    this.loadRulesFromEnv();
    this.loadSpecificUrlListFromEnv();
    this.loadCustomStartingPointsFromEnv();
  }

  getStructuredDataConfig() {
    return {
      validation: {
        enabled: this.configService.get<boolean>('STRUCTURED_DATA_VALIDATION_ENABLED', true),
        strictMode: this.configService.get<boolean>('STRUCTURED_DATA_STRICT_MODE', true),
        maxErrors: this.configService.get<number>('STRUCTURED_DATA_MAX_ERRORS', 50),
        validateAgainstSchemaOrg: this.configService.get<boolean>('VALIDATE_AGAINST_SCHEMA_ORG', true),
        validateAgainstGoogleRequirements: this.configService.get<boolean>('VALIDATE_AGAINST_GOOGLE', true),
      },
      jsonLd: {
        enabled: this.configService.get<boolean>('JSON_LD_ANALYSIS_ENABLED', true),
        multipleAllowed: this.configService.get<boolean>('JSON_LD_MULTIPLE_ALLOWED', true),
        maxSize: this.configService.get<number>('JSON_LD_MAX_SIZE', 50000),
        requiredProperties: this.configService.get<string>('JSON_LD_REQUIRED_PROPERTIES', '@context,@type').split(','),
      },
      microdata: {
        enabled: this.configService.get<boolean>('MICRODATA_ANALYSIS_ENABLED', true),
        validateNesting: this.configService.get<boolean>('MICRODATA_VALIDATE_NESTING', true),
        maxNestedDepth: this.configService.get<number>('MICRODATA_MAX_NESTED_DEPTH', 10),
      },
      rdfa: {
        enabled: this.configService.get<boolean>('RDFA_ANALYSIS_ENABLED', true),
        validatePrefixes: this.configService.get<boolean>('RDFA_VALIDATE_PREFIXES', true),
        requiredPrefixes: this.configService.get<string>('RDFA_REQUIRED_PREFIXES', 'og:,dc:').split(','),
      },
      richSnippets: {
        checkEligibility: this.configService.get<boolean>('CHECK_RICH_SNIPPET_ELIGIBILITY', true),
        types: this.configService.get<string>('RICH_SNIPPET_TYPES', 
          'Article,BreadcrumbList,Event,FAQPage,HowTo,LocalBusiness,Product,Recipe,Review').split(','),
        validateRequiredFields: this.configService.get<boolean>('VALIDATE_RICH_SNIPPET_FIELDS', true),
      },
      schemaTypes: {
        preferredTypes: this.configService.get<string>('PREFERRED_SCHEMA_TYPES',
          'Article,BlogPosting,Product,Organization,LocalBusiness,WebSite,WebPage').split(','),
        deprecatedTypesWarning: this.configService.get<boolean>('WARN_DEPRECATED_SCHEMAS', true),
      },
      competitive: {
        enabled: this.configService.get<boolean>('STRUCTURED_DATA_COMPETITIVE_ANALYSIS', true),
        benchmarkThreshold: this.configService.get<number>('STRUCTURED_DATA_BENCHMARK_THRESHOLD', 0.8),
        industryStandards: this.configService.get<string>('STRUCTURED_DATA_INDUSTRY_STANDARDS', 
          'Organization,WebSite,BreadcrumbList').split(','),
      }
    };
  }

  getTechnicalSeoConfig() {
    return {
      performance: {
        ttfbThreshold: this.configService.get<number>('TECH_SEO_TTFB_THRESHOLD', 200),
        domLoadThreshold: this.configService.get<number>('TECH_SEO_DOM_LOAD_THRESHOLD', 2500),
        loadTimeThreshold: this.configService.get<number>('TECH_SEO_LOAD_TIME_THRESHOLD', 3000),
        firstContentfulPaintThreshold: this.configService.get<number>('TECH_SEO_FCP_THRESHOLD', 1800),
        speedIndex: this.configService.get<number>('TECH_SEO_SPEED_INDEX_THRESHOLD', 3400),
        resourceTiming: {
          enabled: this.configService.get<boolean>('TECH_SEO_RESOURCE_TIMING_ENABLED', true),
          slowResourceThreshold: this.configService.get<number>('TECH_SEO_SLOW_RESOURCE_THRESHOLD', 1000),
        }
      },
      pageSize: {
        maxTotalSizeKB: this.configService.get<number>('TECH_SEO_MAX_TOTAL_SIZE_KB', 5120),
        maxHtmlSizeKB: this.configService.get<number>('TECH_SEO_MAX_HTML_SIZE_KB', 100),
        resourceLimits: {
          maxJsSizeKB: this.configService.get<number>('TECH_SEO_MAX_JS_SIZE_KB', 400),
          maxCssSizeKB: this.configService.get<number>('TECH_SEO_MAX_CSS_SIZE_KB', 100),
          maxImageSizeKB: this.configService.get<number>('TECH_SEO_MAX_IMAGE_SIZE_KB', 1000),
          maxFontSizeKB: this.configService.get<number>('TECH_SEO_MAX_FONT_SIZE_KB', 100),
        }
      },
      compression: {
        minCompressionRatio: this.configService.get<number>('TECH_SEO_MIN_COMPRESSION_RATIO', 0.7),
        preferredEncodings: this.configService.get<string>('TECH_SEO_PREFERRED_ENCODINGS', 'br,gzip').split(','),
        checkPrecompressed: this.configService.get<boolean>('TECH_SEO_CHECK_PRECOMPRESSED', true),
        warnUncompressed: this.configService.get<boolean>('TECH_SEO_WARN_UNCOMPRESSED', true),
      },
      http2: {
        required: this.configService.get<boolean>('TECH_SEO_HTTP2_REQUIRED', true),
        analyzeServerPush: this.configService.get<boolean>('TECH_SEO_ANALYZE_SERVER_PUSH', true),
        checkMultiplexing: this.configService.get<boolean>('TECH_SEO_CHECK_MULTIPLEXING', true),
        connectionEfficiency: {
          enabled: this.configService.get<boolean>('TECH_SEO_CONNECTION_EFFICIENCY_ENABLED', true),
          minConcurrentStreams: this.configService.get<number>('TECH_SEO_MIN_CONCURRENT_STREAMS', 30),
        }
      },
      advanced: {
        resourcePrioritization: this.configService.get<boolean>('TECH_SEO_RESOURCE_PRIORITIZATION', true),
        preloadAnalysis: this.configService.get<boolean>('TECH_SEO_PRELOAD_ANALYSIS', true),
        cacheAnalysis: this.configService.get<boolean>('TECH_SEO_CACHE_ANALYSIS', true),
        cdnDetection: this.configService.get<boolean>('TECH_SEO_CDN_DETECTION', true),
        dnsPreFetchAnalysis: this.configService.get<boolean>('TECH_SEO_DNS_PREFETCH_ANALYSIS', true),
      },
      mobileFriendliness: {
        enabled: this.configService.get<boolean>('TECH_SEO_MOBILE_FRIENDLY_ENABLED', true),
        viewportAnalysis: {
          requiredProperties: this.configService.get<string>('MOBILE_VIEWPORT_REQUIRED_PROPS', 'width,initial-scale').split(','),
          minTouchTargetSize: this.configService.get<number>('MOBILE_MIN_TOUCH_TARGET_SIZE', 48),
          minTouchTargetSpacing: this.configService.get<number>('MOBILE_MIN_TOUCH_TARGET_SPACING', 8),
          minFontSize: this.configService.get<number>('MOBILE_MIN_FONT_SIZE', 12),
          maxContentWidth: this.configService.get<number>('MOBILE_MAX_CONTENT_WIDTH', 980),
        },
        mediaQueries: {
          checkResponsiveImages: this.configService.get<boolean>('MOBILE_CHECK_RESPONSIVE_IMAGES', true),
          checkResponsiveBreakpoints: this.configService.get<boolean>('MOBILE_CHECK_RESPONSIVE_BREAKPOINTS', true),
        }
      },
      amp: {
        enabled: this.configService.get<boolean>('TECH_SEO_AMP_ENABLED', true),
        validateAmpHtml: this.configService.get<boolean>('AMP_VALIDATE_HTML', true),
        checkCanonicalRelation: this.configService.get<boolean>('AMP_CHECK_CANONICAL', true),
        maxAmpSize: this.configService.get<number>('AMP_MAX_SIZE_KB', 50),
      },
      resourceUsage: {
        iframe: {
          enabled: this.configService.get<boolean>('TECH_SEO_IFRAME_ANALYSIS_ENABLED', true),
          maxIframes: this.configService.get<number>('MAX_IFRAMES_PER_PAGE', 3),
          checkSandbox: this.configService.get<boolean>('IFRAME_CHECK_SANDBOX', true),
          checkSecurity: this.configService.get<boolean>('IFRAME_CHECK_SECURITY', true),
        },
        flash: {
          enabled: this.configService.get<boolean>('TECH_SEO_FLASH_DETECTION_ENABLED', true),
          checkAlternatives: this.configService.get<boolean>('FLASH_CHECK_ALTERNATIVES', true),
        }
      },
      cookies: {
        enabled: this.configService.get<boolean>('TECH_SEO_COOKIE_ANALYSIS_ENABLED', true),
        maxCookieSize: this.configService.get<number>('MAX_COOKIE_SIZE_KB', 4),
        checkGdprCompliance: this.configService.get<boolean>('COOKIE_CHECK_GDPR', true),
        categories: this.configService.get<string>('COOKIE_CATEGORIES', 'necessary,preferences,statistics,marketing').split(','),
        maxCookiesPerDomain: this.configService.get<number>('MAX_COOKIES_PER_DOMAIN', 50),
      }
    };
  }
  
  getJavaScriptRenderingConfig() {
    return  {
      enabled: this.configService.get<boolean>('JS_RENDERING_ENABLED', true),
      timeout: this.configService.get<number>('JS_RENDERING_TIMEOUT', 30000),
      waitUntil: this.configService.get<string>('JS_RENDERING_WAIT_UNTIL', 'networkidle0'),
      userAgent: this.configService.get<string>('JS_RENDERING_USER_AGENT', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'),
      viewport: {
        width: this.configService.get<number>('JS_RENDERING_VIEWPORT_WIDTH', 1920),
        height: this.configService.get<number>('JS_RENDERING_VIEWPORT_HEIGHT', 1080),
        deviceScaleFactor: this.configService.get<string>('JS_RENDERING_DEVICE_SCALE_FACTOR', '1'),
      },
    };
  }


  getImageAnalysisConfig() {
    return {
      enabled: this.configService.get<boolean>('IMAGE_ANALYSIS_ENABLED', true),
      maxSizeMB: this.configService.get<number>('IMAGE_MAX_SIZE_MB', 5),
      minWidth: this.configService.get<number>('IMAGE_MIN_WIDTH', 100),
      minHeight: this.configService.get<number>('IMAGE_MIN_HEIGHT', 100),
      allowedFormats: this.configService.get<string>('IMAGE_FORMATS_ALLOWED', 'jpg,jpeg,png,gif,webp,svg').split(','),
      ocrEnabled: this.configService.get<boolean>('OCR_ENABLED', true),
      ocrConfidenceThreshold: this.configService.get<number>('OCR_CONFIDENCE_THRESHOLD', 0.7),
    };
  }

  getKeywordAnalysisConfig() {
    return {
      densityAnalysisEnabled: this.configService.get<boolean>('KEYWORD_DENSITY_ANALYSIS_ENABLED', true),
      densityThreshold: this.configService.get<number>('KEYWORD_DENSITY_THRESHOLD', 2),
      usageMinCount: this.configService.get<number>('KEYWORD_USAGE_MIN_COUNT', 3),
      usageMaxCount: this.configService.get<number>('KEYWORD_USAGE_MAX_COUNT', 10),
      contentHtmlRatioThreshold: this.configService.get<number>('CONTENT_HTML_RATIO_THRESHOLD', 0.2),
      duplicateContentSimilarityThreshold: this.configService.get<number>('DUPLICATE_CONTENT_SIMILARITY_THRESHOLD', 0.9),
      nearDuplicateContentSimilarityThreshold: this.configService.get<number>('NEAR_DUPLICATE_CONTENT_SIMILARITY_THRESHOLD', 0.8),
      minWordCount: this.configService.get<number>('CONTENT_ANALYSIS_MIN_WORD_COUNT', 100),
    };
  }

  getThinContentConfig() {
    return {
      wordThreshold: this.configService.get<number>('THIN_CONTENT_WORD_THRESHOLD', 300),
      charThreshold: this.configService.get<number>('THIN_CONTENT_CHAR_THRESHOLD', 1500),
    };
  }

  

  getReadabilityScoreConfig() {
    return {
      enabled: this.configService.get<boolean>('READABILITY_SCORE_ENABLED', true),
    };
  }
  
  getContentAnalysisConfig() {
    return {
      wordCount: {
        minLength: this.configService.get<number>('WORD_COUNT_MIN_LENGTH', 3),
        maxLength: this.configService.get<number>('WORD_COUNT_MAX_LENGTH', 30),
      },
      languageDetection: {
        confidenceThreshold: this.configService.get<number>('LANGUAGE_DETECTION_CONFIDENCE_THRESHOLD', 0.8),
      },
    };
  }

  getOpenGraphConfig() {
    return {
      enabled: this.configService.get<boolean>('OG_ANALYSIS_ENABLED', true),
      requiredProperties: this.configService.get<string>('OG_REQUIRED_PROPERTIES', 'og:title,og:type,og:image,og:url').split(','),
    };
  }
  
  getTwitterCardConfig() {
    return {
      enabled: this.configService.get<boolean>('TWITTER_CARD_ANALYSIS_ENABLED', true),
      requiredProperties: this.configService.get<string>('TWITTER_CARD_REQUIRED_PROPERTIES', 'twitter:card,twitter:title,twitter:description,twitter:image').split(','),
    };
  }
  
  getViewportConfig() {
    return {
      enabled: this.configService.get<boolean>('VIEWPORT_ANALYSIS_ENABLED', true),
      recommendedValue: this.configService.get<string>('VIEWPORT_RECOMMENDED_VALUE', 'width=device-width, initial-scale=1'),
    };
  }

  getHreflangConfig() {
    return {
      enabled: this.configService.get<boolean>('HREFLANG_ANALYSIS_ENABLED', true),
      maxTags: this.configService.get<number>('HREFLANG_MAX_TAGS', 10),
      requiredAttributes: this.configService.get<string>('HREFLANG_REQUIRED_ATTRIBUTES', 'hreflang,href').split(','),
    };
  }

  getRelLinkConfig() {
    return {
      enabled: this.configService.get<boolean>('REL_LINK_ANALYSIS_ENABLED', true),
      maxDepth: this.configService.get<number>('REL_LINK_MAX_DEPTH', 3),
    };
  }

    getCanonicalTagConfig() {
      return {
        enabled: this.configService.get<boolean>('CANONICAL_TAG_ANALYSIS_ENABLED', true),
        maxLength: this.configService.get<number>('CANONICAL_TAG_MAX_LENGTH', 2048),
        allowRelative: this.configService.get<boolean>('CANONICAL_TAG_ALLOW_RELATIVE', true),
      };
    }

    getMetaRobotsConfig() {
      return {
        enabled: this.configService.get<boolean>('META_ROBOTS_ANALYSIS_ENABLED', true),
        directivesToCheck: this.configService.get<string>('META_ROBOTS_DIRECTIVES_TO_CHECK', 'noindex,nofollow,noarchive,nosnippet,noimageindex,notranslate,noodp,noydir')
          .split(',')
          .map(directive => directive.trim()),
        maxLength: this.configService.get<number>('META_ROBOTS_MAX_LENGTH', 200),
      };
    }

    getMetaKeywordsConfig() {
      return {
        enabled: this.configService.get<boolean>('META_KEYWORDS_EXTRACTION_ENABLED', true),
        maxCount: this.configService.get<number>('META_KEYWORDS_MAX_COUNT', 10),
      };
    }

    getKeywordExtractionConfig() {
      return {
        minWordLength: this.configService.get<number>('KEYWORD_EXTRACTION_MIN_WORD_LENGTH', 4),
        maxKeywords: this.configService.get<number>('KEYWORD_EXTRACTION_MAX_KEYWORDS', 50),
        minOccurrence: this.configService.get<number>('KEYWORD_EXTRACTION_MIN_OCCURRENCE', 3),
        maxPagesToAnalyze: this.configService.get<number>('KEYWORD_EXTRACTION_MAX_PAGES_TO_ANALYZE', 10),
      };
    }
  
    getSecurityHeaderConfig() {
      return {
        enabled: this.configService.get<boolean>('SECURITY_HEADER_ANALYSIS_ENABLED', true),
        headersToCheck: this.configService.get<string>('SECURITY_HEADERS_TO_CHECK', '')
          .split(',')
          .map(header => header.trim()),
      };
    }

    getHeadingAnalysisConfig() {
      return {
        enabled: this.configService.get<boolean>('HEADING_ANALYSIS_ENABLED', true),
        maxLength: this.configService.get<number>('HEADING_MAX_LENGTH', 70),
        idealH1Count: this.configService.get<number>('HEADING_IDEAL_H1_COUNT', 1),
        maxH1Count: this.configService.get<number>('HEADING_MAX_H1_COUNT', 1),
        maxH2Count: this.configService.get<number>('HEADING_MAX_H2_COUNT', 10),
        maxH3Count: this.configService.get<number>('HEADING_MAX_H3_COUNT', 20),
        maxH4Count: this.configService.get<number>('HEADING_MAX_H4_COUNT', 30),
        maxH5Count: this.configService.get<number>('HEADING_MAX_H5_COUNT', 40),
        maxH6Count: this.configService.get<number>('HEADING_MAX_H6_COUNT', 50),
      };
    }

    getMetaDescriptionConfig() {
      return {
        minLength: this.configService.get<number>('META_DESCRIPTION_MIN_LENGTH', 120),
        maxLength: this.configService.get<number>('META_DESCRIPTION_MAX_LENGTH', 160),
        keywordMinCount: this.configService.get<number>('META_DESCRIPTION_KEYWORD_MIN_COUNT', 1),
      };
    }

    getHttpHeaderConfig() {
      return this.httpHeaderConfig.getConfig();
    }

    getUrlAnalysisConfig() {
      return {
        maxDepth: this.configService.get<number>('URL_ANALYSIS_MAX_DEPTH', 10),
        cleanUrlThreshold: this.configService.get<number>('URL_ANALYSIS_CLEAN_URL_THRESHOLD', 3),
        paramMaxLength: this.configService.get<number>('URL_PARAM_MAX_LENGTH', 100),
        paramMaxCount: this.configService.get<number>('URL_PARAM_MAX_COUNT', 20),
        maxTotalLength: this.configService.get<number>('URL_MAX_TOTAL_LENGTH', 2083),
        maxPathLength: this.configService.get<number>('URL_MAX_PATH_LENGTH', 1000),
        maxQueryLength: this.configService.get<number>('URL_MAX_QUERY_LENGTH', 1000),
        maxFragmentLength: this.configService.get<number>('URL_MAX_FRAGMENT_LENGTH', 255),
        lowercasePreferred: this.configService.get<boolean>('URL_LOWERCASE_PREFERRED', true),
        preferredProtocol: this.configService.get<string>('URL_PREFERRED_PROTOCOL', 'https'),
      };
    } 

    getContentTypeConfig() {
      return {
        enabled: this.configService.get<boolean>('CONTENT_TYPE_DETECTION_ENABLED', true),
        maxSize: this.configService.get<number>('CONTENT_TYPE_MAX_SIZE', 10485760),
        allowedTypes: this.configService.get<string>('CONTENT_TYPE_ALLOWED_TYPES', 'text/html,application/pdf,image/jpeg,image/png,image/gif').split(','),
      };
    }

    getTitleTagConfig() {
      return {
        minLength: this.configService.get<number>('TITLE_TAG_MIN_LENGTH', 10),
        maxLength: this.configService.get<number>('TITLE_TAG_MAX_LENGTH', 60),
        minPixelWidth: this.configService.get<number>('TITLE_TAG_MIN_PIXEL_WIDTH', 200),
        maxPixelWidth: this.configService.get<number>('TITLE_TAG_MAX_PIXEL_WIDTH', 580),
      };
    }

    getHttpStatusCodeConfig() {
      return {
        informational: {
          min: this.configService.get<number>('HTTP_INFORMATIONAL_MIN', 100),
          max: this.configService.get<number>('HTTP_INFORMATIONAL_MAX', 199),
        },
        success: {
          min: this.configService.get<number>('HTTP_SUCCESS_MIN', 200),
          max: this.configService.get<number>('HTTP_SUCCESS_MAX', 299),
        },
        redirection: {
          min: this.configService.get<number>('HTTP_REDIRECTION_MIN', 300),
          max: this.configService.get<number>('HTTP_REDIRECTION_MAX', 399),
        },
        clientError: {
          min: this.configService.get<number>('HTTP_CLIENT_ERROR_MIN', 400),
          max: this.configService.get<number>('HTTP_CLIENT_ERROR_MAX', 499),
        },
        serverError: {
          min: this.configService.get<number>('HTTP_SERVER_ERROR_MIN', 500),
          max: this.configService.get<number>('HTTP_SERVER_ERROR_MAX', 599),
        },
      };
    }

    
    
    getCrawlerConfig() {
    return {
      ...this.generalConfig.getConfig(),
      ...this.sitemapConfig.getConfig(),
      ...this.directoryTreeConfig.getConfig(),
      ...this.multithreadingConfig.getConfig(),
      ...this.asyncOperationsConfig.getConfig(),
      ...this.rateLimitConfig.getConfig(),
      specificUrlList: this.specificUrlList,
      customStartingPoints: this.customStartingPoints,
      requestTimeout: this.configService.get<number>('CRAWLER_REQUEST_TIMEOUT', 30000),
      followInternalLinks: this.configService.get<boolean>('CRAWLER_FOLLOW_INTERNAL_LINKS', true),
      followExternalLinks: this.configService.get<boolean>('CRAWLER_FOLLOW_EXTERNAL_LINKS', false),
      followSubfolderLinks: this.configService.get<boolean>('CRAWLER_FOLLOW_SUBFOLDER_LINKS', true),
      extractSitemapsFromRobots: this.configService.get<boolean>('CRAWLER_EXTRACT_SITEMAPS_FROM_ROBOTS', true),
      extractSitemapsFromHtml: this.configService.get<boolean>('CRAWLER_EXTRACT_SITEMAPS_FROM_HTML', true),
      userAgent: this.configService.get<string>('CRAWLER_USER_AGENT', 'SeoOptimizer Crawler/1.0'),
      batchUpdateSize: this.configService.get<number>('CRAWLER_BATCH_UPDATE_SIZE', 100),
      adaptiveEstimation: this.configService.get<boolean>('CRAWLER_ADAPTIVE_ESTIMATION', true),
      progressPersistence: this.configService.get<boolean>('CRAWLER_PROGRESS_PERSISTENCE', true),
      separateProgressWorker: this.configService.get<boolean>('CRAWLER_SEPARATE_PROGRESS_WORKER', true)
    };

  
  }

  getRobotsTxtAdherence(): boolean {
    return this.generalConfig.getConfig().respectRobotsTxt;
  }

  validateCrawlLimits(urlLimit: number, depthLimit: number): void {
    if (urlLimit <= 0 || depthLimit <= 0) {
      throw new Error('URL limit and depth limit must be positive integers');
    }
  }

  getInclusionRules(): Rule[] {
    return this.inclusionExclusionService.getInclusionRules();
  }
  
  getExclusionRules(): Rule[] {
    return this.inclusionExclusionService.getExclusionRules();
  }

  addInclusionRule(pattern: string, isRegex: boolean = false) {
    this.inclusionExclusionService.addInclusionRule(pattern, isRegex);
  }

  addExclusionRule(pattern: string, isRegex: boolean = false) {
    this.inclusionExclusionService.addExclusionRule(pattern, isRegex);
  }

  removeInclusionRule(pattern: string) {
    this.inclusionExclusionService.removeInclusionRule(pattern);
  }

  removeExclusionRule(pattern: string) {
    this.inclusionExclusionService.removeExclusionRule(pattern);
  }

  getSpecificUrlList(): string[] {
    return this.specificUrlList;
  }

  setSpecificUrlList(urlList: string[]): void {
    this.specificUrlList = urlList;
  }

  getDirectoryTreeConfig() {
    return this.directoryTreeConfig.getConfig();
  }

  getCustomStartingPoints(): string[] {
    return this.customStartingPoints;
  }

  setCustomStartingPoints(startingPoints: string[]): void {
    this.customStartingPoints = startingPoints;
  }

  getMultithreadingConfig() {
    return this.multithreadingConfig.getConfig();
  }

  getAsyncOperationsConfig() {
    return this.asyncOperationsConfig.getConfig();
  }

  private loadRulesFromEnv() {
    const inclusionRules = this.configService.get<string>('CRAWLER_INCLUSION_RULES', '').split(',');
    const exclusionRules = this.configService.get<string>('CRAWLER_EXCLUSION_RULES', '').split(',');

    inclusionRules.forEach(rule => {
      if (rule) this.addInclusionRule(rule.trim());
    });

    exclusionRules.forEach(rule => {
      if (rule) this.addExclusionRule(rule.trim());
    });
  }

  private loadSpecificUrlListFromEnv() {
    const urlList = this.configService.get<string>('CRAWLER_SPECIFIC_URL_LIST', '').split(',');
    this.specificUrlList = urlList.filter(url => url.trim() !== '');
  }

  private loadCustomStartingPointsFromEnv() {
    const startingPoints = this.configService.get<string>('CRAWLER_CUSTOM_STARTING_POINTS', '').split(',');
    this.customStartingPoints = startingPoints.filter(point => point.trim() !== '');
  }

  getRateLimitConfig() {
    return this.rateLimitConfig.getConfig();
  }
}
 
                                                C:\Workspace\Web\Ai Business grow project\Back_end\src\crawler\config\inclusion-exclusion.service.ts 
import { Injectable } from '@nestjs/common';

export interface Rule {
    pattern: string;
    isRegex: boolean;
  }
  
@Injectable()
export class InclusionExclusionService {
  private inclusionRules: Rule[] = [];
  private exclusionRules: Rule[] = [];

  addInclusionRule(pattern: string, isRegex: boolean = false): void {
    this.inclusionRules.push({ pattern, isRegex });
  }

  addExclusionRule(pattern: string, isRegex: boolean = false): void {
    this.exclusionRules.push({ pattern, isRegex });
  }

  removeInclusionRule(pattern: string): void {
    this.inclusionRules = this.inclusionRules.filter(rule => rule.pattern !== pattern);
  }

  removeExclusionRule(pattern: string): void {
    this.exclusionRules = this.exclusionRules.filter(rule => rule.pattern !== pattern);
  }

  isUrlAllowed(url: string): boolean {
    if (this.inclusionRules.length > 0) {
      const isIncluded = this.inclusionRules.some(rule => this.matchRule(url, rule));
      if (!isIncluded) return false;
    }

    return !this.exclusionRules.some(rule => this.matchRule(url, rule));
  }

  private matchRule(url: string, rule: Rule): boolean {
    if (rule.isRegex) {
      const regex = new RegExp(rule.pattern);
      return regex.test(url);
    } else {
      return url.includes(rule.pattern);
    }
  }

  getInclusionRules(): Rule[] {
    return [...this.inclusionRules];
  }

  getExclusionRules(): Rule[] {
    return [...this.exclusionRules];
  }
}
 
                                                    C:\Workspace\Web\Ai Business grow project\Back_end\src\crawler\config\sub-configs\async-operations.config.ts 
import { ConfigService } from '@nestjs/config';
import { getNumberConfig, getBooleanConfig } from '../utils/config-helpers';

export class AsyncOperationsConfig {
  constructor(private configService: ConfigService) {}

  getConfig() {
    return {
      concurrencyLimit: getNumberConfig(this.configService, 'CRAWLER_ASYNC_CONCURRENCY_LIMIT', 10),
      useAsyncHttpRequests: getBooleanConfig(this.configService, 'CRAWLER_USE_ASYNC_HTTP_REQUESTS', true),
      asyncBatchSize: getNumberConfig(this.configService, 'CRAWLER_ASYNC_BATCH_SIZE', 5),
      asyncTimeout: getNumberConfig(this.configService, 'CRAWLER_ASYNC_TIMEOUT', 30000),
    };
  }
}
 
                                                    C:\Workspace\Web\Ai Business grow project\Back_end\src\crawler\config\sub-configs\directory-tree.config.ts 
import { ConfigService } from '@nestjs/config';
import { getBooleanConfig, getNumberConfig, getArrayConfig } from '../utils/config-helpers';

export class DirectoryTreeConfig {
  constructor(private configService: ConfigService) {}

  getConfig() {
    return {
      directoryTreeEnabled: getBooleanConfig(this.configService, 'CRAWLER_DIRECTORY_TREE_ENABLED', true),
      directoryTreeMaxDepth: getNumberConfig(this.configService, 'CRAWLER_DIRECTORY_TREE_MAX_DEPTH', 5),
      directoryTreeAllowedExtensions: getArrayConfig(this.configService, 'CRAWLER_DIRECTORY_TREE_ALLOWED_EXTENSIONS', ['html', 'htm', 'php', 'asp', 'aspx']),
      directoryTreeExcludePatterns: getArrayConfig(this.configService, 'CRAWLER_DIRECTORY_TREE_EXCLUDE_PATTERNS', ['private', 'admin', 'backup']),
    };
  }
} 
                                                    C:\Workspace\Web\Ai Business grow project\Back_end\src\crawler\config\sub-configs\general.config.ts 
import { ConfigService } from '@nestjs/config';
import { getNumberConfig, getStringConfig, getBooleanConfig, getArrayConfig } from '../utils/config-helpers';

export class GeneralConfig {
  constructor(private configService: ConfigService) {}

  getConfig() {
    return {
      defaultUrlLimit: getNumberConfig(this.configService, 'CRAWLER_DEFAULT_URL_LIMIT', 1000),
      defaultDepthLimit: getNumberConfig(this.configService, 'CRAWLER_DEFAULT_DEPTH_LIMIT', 5),
      userAgent: getStringConfig(this.configService, 'CRAWLER_USER_AGENT', 'SeoOptimizer Crawler/1.0'),
      respectRobotsTxt: getBooleanConfig(this.configService, 'CRAWLER_RESPECT_ROBOTS_TXT', true),
      crawlDelay: getNumberConfig(this.configService, 'CRAWLER_CRAWL_DELAY', 1000),
      followInternalLinks: getBooleanConfig(this.configService, 'CRAWLER_FOLLOW_INTERNAL_LINKS', true),
      followExternalLinks: getBooleanConfig(this.configService, 'CRAWLER_FOLLOW_EXTERNAL_LINKS', false),
      followSubfolderLinks: getBooleanConfig(this.configService, 'CRAWLER_FOLLOW_SUBFOLDER_LINKS', true),
    };
  }
}
 
                                                    C:\Workspace\Web\Ai Business grow project\Back_end\src\crawler\config\sub-configs\http-header.config.ts 
import { ConfigService } from '@nestjs/config';
import { getBooleanConfig, getNumberConfig } from '../utils/config-helpers';

export class HttpHeaderConfig {
  constructor(private configService: ConfigService) {}

  getConfig() {
    return {
      // Add these lines to the existing config
      xRobotsTagEnabled: getBooleanConfig(this.configService, 'X_ROBOTS_TAG_ENABLED', true),
      xRobotsTagMaxLength: getNumberConfig(this.configService, 'X_ROBOTS_TAG_MAX_LENGTH', 1000),
    };
  }
}
 
                                                    C:\Workspace\Web\Ai Business grow project\Back_end\src\crawler\config\sub-configs\multithreading.config.ts 
import { ConfigService } from '@nestjs/config';
import { getNumberConfig, getBooleanConfig } from '../utils/config-helpers';

export class MultithreadingConfig {
  constructor(private configService: ConfigService) {}

  getConfig() {
    return {
      enableMultithreading: getBooleanConfig(this.configService, 'CRAWLER_ENABLE_MULTITHREADING', true),
      maxThreads: getNumberConfig(this.configService, 'CRAWLER_MAX_THREADS', 4),
      threadPoolSize: getNumberConfig(this.configService, 'CRAWLER_THREAD_POOL_SIZE', 10),
    };
  }
}
 
                                                    C:\Workspace\Web\Ai Business grow project\Back_end\src\crawler\config\sub-configs\rate-limit.config.ts 
import { ConfigService } from '@nestjs/config';
import { getNumberConfig } from '../utils/config-helpers';

export class RateLimitConfig {
  constructor(private configService: ConfigService) {}

  getConfig() {
    return {
      bucketCapacity: getNumberConfig(this.configService, 'RATE_LIMITER_BUCKET_CAPACITY', 60),
      refillRate: getNumberConfig(this.configService, 'RATE_LIMITER_REFILL_RATE', 1),
      enabled: getNumberConfig(this.configService, 'RATE_LIMITER_ENABLED', 1),
    };
  }
}
 
                                                    C:\Workspace\Web\Ai Business grow project\Back_end\src\crawler\config\sub-configs\sitemap.config.ts 
import { ConfigService } from '@nestjs/config';
import { getBooleanConfig, getArrayConfig, getNumberConfig, getStringConfig } from '../utils/config-helpers';

export class SitemapConfig {
  constructor(private configService: ConfigService) {}

  getConfig() {
    return {
      sitemapEnabled: getBooleanConfig(this.configService, 'CRAWLER_SITEMAP_ENABLED', true),
      sitemapTypes: getArrayConfig(this.configService, 'CRAWLER_SITEMAP_TYPES', ['xml', 'rss', 'atom', 'txt']),
      sitemapLimit: getNumberConfig(this.configService, 'CRAWLER_SITEMAP_LIMIT', 1000),
      sitemapPriority: getStringConfig(this.configService, 'CRAWLER_SITEMAP_PRIORITY', 'high'),
      extractSitemapsFromRobots: getBooleanConfig(this.configService, 'CRAWLER_EXTRACT_SITEMAPS_FROM_ROBOTS', true),
      extractSitemapsFromHtml: getBooleanConfig(this.configService, 'CRAWLER_EXTRACT_SITEMAPS_FROM_HTML', true),
    };
  }
}
 
                                                        C:\Workspace\Web\Ai Business grow project\Back_end\src\crawler\config\utils\config-helpers.ts 
import { ConfigService } from '@nestjs/config';

export function getNumberConfig(configService: ConfigService, key: string, defaultValue: number): number {
  const value = configService.get<number>(key);
  return value !== undefined ? value : defaultValue;
}

export function getStringConfig(configService: ConfigService, key: string, defaultValue: string): string {
  const value = configService.get<string>(key);
  return value !== undefined ? value : defaultValue;
}

export function getBooleanConfig(configService: ConfigService, key: string, defaultValue: boolean): boolean {
  const value = configService.get<string>(key);
  if (value === undefined) return defaultValue;
  return value.toLowerCase() === 'true';
}

export function getArrayConfig(configService: ConfigService, key: string, defaultValue: string[]): string[] {
  const value = configService.get<string>(key);
  return value ? value.split(',').map(item => item.trim()) : defaultValue;
}
 
                                                            C:\Workspace\Web\Ai Business grow project\Back_end\src\crawler\core\crawler.controller.ts 
import { Controller, Post, Query, Body, ValidationPipe, Get } from '@nestjs/common';
import { CrawlerService } from '../services/crawler.service';
import { CrawlerConfigService } from '../config/crawler-config.service';
import { SpecificUrlListDto } from '../dto/specific-url-list.dto';
import { SitemapCrawlerService } from '../services/sitemap/sitemap-crawler.service';
import { ConfigService } from '@nestjs/config';
import { CrawlOptionsDto } from '../dto/crawl-options.dto';

@Controller('crawler')
export class CrawlerController {
  constructor(
    private readonly crawlerService: CrawlerService,
    private readonly crawlerConfigService: CrawlerConfigService,
    private readonly sitemapCrawlerService: SitemapCrawlerService,
    private readonly configService: ConfigService
  ) {}

  @Post('crawl')
  async crawlWebsite(
    @Body() crawlOptionsDto: CrawlOptionsDto
  ) {
    const {
      url,
      urlLimit,
      depthLimit,
      followInternalLinks,
      followExternalLinks,
      followSubfolderLinks,
      addInclusionRule,
      addExclusionRule,
      removeInclusionRule,
      removeExclusionRule,
      useDirectoryTreeCrawling,
      directoryTreeRootPath,
      specificUrlList,
      customStartingPoints,
      sitemapEnabled
    } = crawlOptionsDto;

    if (addInclusionRule) {
      this.crawlerConfigService.addInclusionRule(addInclusionRule);
    }
    if (addExclusionRule) {
      this.crawlerConfigService.addExclusionRule(addExclusionRule);
    }
    if (removeInclusionRule) {
      this.crawlerConfigService.removeInclusionRule(removeInclusionRule);
    }
    if (removeExclusionRule) {
      this.crawlerConfigService.removeExclusionRule(removeExclusionRule);
    }

    return this.crawlerService.crawlWebsite(url, {
      urlLimit,
      depthLimit,
      followInternalLinks,
      followExternalLinks,
      followSubfolderLinks,
      specificUrlList: specificUrlList?.urls,
      useDirectoryTreeCrawling,
      directoryTreeRootPath,
      customStartingPoints,
      sitemapEnabled
    });
  }

  @Post('crawl-specific-urls')
  async crawlSpecificUrls(
    @Body(new ValidationPipe()) specificUrlListDto: SpecificUrlListDto,
    @Query('urlLimit') urlLimit?: number,
    @Query('depthLimit') depthLimit?: number
  ) {
    return this.crawlerService.crawlWebsite(specificUrlListDto.urls[0], {
      urlLimit,
      depthLimit,
      specificUrlList: specificUrlListDto.urls
    });
  }

  @Get('crawl-sitemap')
  async crawlSitemap(@Query('url') url: string) {
    const sitemaps = await this.sitemapCrawlerService.discoverSitemaps(url);
    const crawlLimit = this.configService.get<number>('MANUAL_SITEMAP_CRAWL_LIMIT', 1000);
    let allUrls: string[] = [];

    for (const sitemap of sitemaps) {
      const urls = await this.sitemapCrawlerService.fetchSitemap(sitemap);
      allUrls = [...allUrls, ...urls];
      if (allUrls.length >= crawlLimit) {
        allUrls = allUrls.slice(0, crawlLimit);
        break;
      }
    }

    return this.crawlerService.crawlWebsite(url, {
      specificUrlList: allUrls,
      urlLimit: crawlLimit
    });
  }

  @Post('crawl-directory-tree')
  async crawlDirectoryTree(
    @Query('rootPath') rootPath: string,
    @Query('urlLimit') urlLimit?: number,
    @Query('depthLimit') depthLimit?: number
  ) {
    return this.crawlerService.crawlWebsite(rootPath, {
      urlLimit,
      depthLimit,
      useDirectoryTreeCrawling: true,
      directoryTreeRootPath: rootPath
    });
  }
} 
                                                            C:\Workspace\Web\Ai Business grow project\Back_end\src\crawler\core\crawler.gateway.ts 
import { WebSocketGateway, WebSocketServer } from '@nestjs/websockets';
import { OnEvent } from '@nestjs/event-emitter';
import { Server } from 'socket.io';

@WebSocketGateway({
  cors: {
    origin: 'http://localhost:3000',
    methods: ['GET', 'POST'],
    credentials: true,
  },
})
export class CrawlerGateway {
  @WebSocketServer()
  server: Server;

  @OnEvent('crawling.progress')
  handleCrawlingProgress(payload: { crawlingId: string; percentage: number; currentUrl: string }) {
    this.server.emit('crawlingProgress', payload);
  }

  @OnEvent('crawling.completed')
  handleCrawlingCompleted(payload: { crawlingId: string; averageScores: Record<string, number> }) {
    this.server.emit('crawlingCompleted', payload);
  }
}

 
                                                            C:\Workspace\Web\Ai Business grow project\Back_end\src\crawler\core\crawler.module.ts 
import { Module } from '@nestjs/common';
import { CacheModule } from '@nestjs/cache-manager';
import { MongooseModule } from '@nestjs/mongoose';
import { ConfigModule, ConfigService } from '@nestjs/config';
import { HttpModule } from '@nestjs/axios';
import { CrawlerController } from './crawler.controller';
import { CrawlerService } from '../services/crawler.service';
import { CrawlerGateway } from './crawler.gateway';
import { CrawlingSession, CrawlingSessionSchema } from '../schemas/crawling-session.schema';
import { CrawlingData, CrawlingDataSchema } from '../schemas/crawling-data.schema';
import { SitemapModule } from '../../seo/sitemap/sitemap.module';
import { EventEmitterModule } from '@nestjs/event-emitter';
import { ContentExtractor } from '../services/extraction/content-extractor';
import { SEOAnalyzer } from '../services/analysis/seo-analyzer';
import { UrlExtractor } from '../services/extraction/url-extractor';
import { CrawlingDataRepository } from '../repository/crawling-data.repository';
import { CrawlerConfigService } from '../config/crawler-config.service';
import { RobotsTxtService } from '../services/robot/robots-txt.service';
import { InclusionExclusionService } from '../config/inclusion-exclusion.service';
import { SitemapCrawlerService } from '../services/sitemap/sitemap-crawler.service';
import { SitemapParser } from '../services/sitemap/sitemap-parser';
import { DirectoryTreeCrawlerService } from '../services/directory-tree/directory-tree-crawler.service';
import { DirectoryTreeAnalyzer } from '../services/analysis/directory-tree-analyzer';
import { CrawlerWorker } from '../services/crawler-worker.service';
import { AsyncHttpService } from '../services/async-http.service';
import { ProgressService } from '../services/progress.service';
import { RateLimiterService } from '../services/rate-limiter.service';
import { PerformanceMonitorService } from '../services/performance-monitor.service';
import { QueuedTask, QueuedTaskSchema } from '../schemas/queued-task.schema';
import { UrlAnalyzerService } from '../services/analysis/url-analyzer.service';
import { HttpHeaderService } from '../services/analysis/http-header.service';
import { ContentTypeAnalyzerService } from '../services/analysis/content-type-analyzer.service';
import { OnPageElementService } from '../services/analysis/on-page-element.service';
import { SiteKeywordAnalyzerService } from '../services/analysis/site-keyword-analyzer.service';
import { CrawlingSessionService } from '../services/crawling-session.service';
import { KeywordExtractionService } from '../services/analysis/keyword-extraction.service';
import { ContentAnalysisService } from '../services/analysis/content-analysis.service';
import { ImageAnalysisService } from '../services/analysis/image-analysis.service';
import { JavaScriptRenderingService } from '../services/javascript-rendering.service';
import { JavaRenderingScriptAnalysisService } from '../services/analysis/java-rendering-script-analysis.service';
import { TechnicalSeoAnalysisService } from '../services/analysis/technical-seo-analysis.service';
import { TechnicalMobileAnalysisService } from '../services/analysis/technical-mobile-analysis.service';
import { AmpAnalysisService } from '../services/analysis/amp-analysis.service';
import { ResourceUsageAnalysisService } from '../services/analysis/resource-usage-analysis.service';
import { CookieAnalysisService } from '../services/analysis/cookie-analysis.service';
import { StructuredDataAnalysisService } from '../services/analysis/structured-data-analysis.service';


  @Module({
    imports: [
      ConfigModule.forRoot({
        isGlobal: true,
        envFilePath: '.env',
      }),
      MongooseModule.forRootAsync({
        imports: [ConfigModule],
        useFactory: async (configService: ConfigService) => ({
          uri: configService.get<string>('MONGO_URI'),
          useNewUrlParser: true,
          useUnifiedTopology: true,
          maxPoolSize: configService.get<number>('MONGO_POOL_SIZE', 10),
          maxIdleTimeMS: configService.get<number>('MONGO_MAX_IDLE_TIME_MS', 30000),
          connectTimeoutMS: configService.get<number>('MONGO_CONNECT_TIMEOUT_MS', 30000),
        }),
        inject: [ConfigService],
      }),
      MongooseModule.forFeature([
        { name: CrawlingSession.name, schema: CrawlingSessionSchema },
        { name: CrawlingData.name, schema: CrawlingDataSchema },
        { name: QueuedTask.name, schema: QueuedTaskSchema },
      ]),
      CacheModule.register(),
      SitemapModule,
      EventEmitterModule.forRoot(),
      HttpModule,
    ],
    controllers: [CrawlerController],
    providers: [
      CrawlerService,
      CrawlerGateway,
      ContentExtractor,
      SEOAnalyzer,
      UrlExtractor,
      CrawlingDataRepository,
      CrawlerConfigService,
      RobotsTxtService,
      InclusionExclusionService,
      SitemapCrawlerService,
      SitemapParser,
      DirectoryTreeCrawlerService,
      DirectoryTreeAnalyzer,
      CrawlerWorker,
      AsyncHttpService,
      ProgressService,
      RateLimiterService,
      PerformanceMonitorService,
      UrlAnalyzerService,
      HttpHeaderService,
      ContentTypeAnalyzerService,
      OnPageElementService,
      SiteKeywordAnalyzerService,
      CrawlingSessionService,
      KeywordExtractionService,
      ContentAnalysisService,
      ImageAnalysisService,
      JavaScriptRenderingService,
      JavaRenderingScriptAnalysisService,
      TechnicalSeoAnalysisService,
      TechnicalMobileAnalysisService,
      AmpAnalysisService,
      ResourceUsageAnalysisService,
      CookieAnalysisService,
      StructuredDataAnalysisService,
    ],
    exports: [CrawlerService, UrlAnalyzerService, ImageAnalysisService,TechnicalMobileAnalysisService,
      AmpAnalysisService,
      ResourceUsageAnalysisService,
      CookieAnalysisService,],
  })
export class CrawlerModule {}  
                                                                C:\Workspace\Web\Ai Business grow project\Back_end\src\crawler\dto\crawl-options.dto.ts 
import { IsOptional, IsString, IsNumber, IsBoolean, IsArray } from 'class-validator';
import { Type } from 'class-transformer';
import { SpecificUrlListDto } from './specific-url-list.dto';

export class CrawlOptionsDto {
  @IsString()
  url: string;

  @IsOptional()
  @IsNumber()
  urlLimit?: number;

  @IsOptional()
  @IsNumber()
  depthLimit?: number;

  @IsOptional()
  @IsBoolean()
  followInternalLinks?: boolean;

  @IsOptional()
  @IsBoolean()
  followExternalLinks?: boolean;

  @IsOptional()
  @IsBoolean()
  followSubfolderLinks?: boolean;

  @IsOptional()
  @IsString()
  addInclusionRule?: string;

  @IsOptional()
  @IsString()
  addExclusionRule?: string;

  @IsOptional()
  @IsString()
  removeInclusionRule?: string;

  @IsOptional()
  @IsString()
  removeExclusionRule?: string;

  @IsOptional()
  @IsBoolean()
  useDirectoryTreeCrawling?: boolean;

  @IsOptional()
  @IsString()
  directoryTreeRootPath?: string;

  @IsOptional()
  @Type(() => SpecificUrlListDto)
  specificUrlList?: SpecificUrlListDto;

  @IsOptional()
  @IsArray()
  @IsString({ each: true })
  customStartingPoints?: string[];

  @IsOptional()
  @IsBoolean()
  sitemapEnabled?: boolean;
}
 
                                                                C:\Workspace\Web\Ai Business grow project\Back_end\src\crawler\dto\specific-url-list.dto.ts 
import { IsArray, IsUrl, ArrayMinSize } from 'class-validator';

export class SpecificUrlListDto {
  urls: string[];
}
 
                                                                    C:\Workspace\Web\Ai Business grow project\Back_end\src\crawler\exceptions\crawler.exceptions.ts 
export class RateLimitExceededException extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'RateLimitExceededException';
  }
}

export class CrawlerNetworkException extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'CrawlerNetworkException';
  }
}

export class CrawlerParsingException extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'CrawlerParsingException';
  }
}
 
                                                                        C:\Workspace\Web\Ai Business grow project\Back_end\src\crawler\interfaces\technical-seo.interface.ts 
export interface MobileFriendlinessAnalysis {
  viewport: {
    hasViewport: boolean;
    isResponsive: boolean;
    viewportContent: string;
    issues: string[];
  };
  touchElements: {
    elementsWithSmallTargets: {
      selector: string;
      size: number;
      spacing: number;
    }[];
    totalIssues: number;
  };
  fontSize: {
    tooSmallElements: {
      selector: string;
      size: number;
    }[];
    totalIssues: number;
  };
  contentWidth: {
    exceedsViewport: boolean;
    horizontalScrolling: boolean;
    contentWidth: number;
    viewportWidth: number;
  };
  mediaQueries: {
    hasResponsiveImages: boolean;
    responsiveBreakpoints: number[];
    missingBreakpoints: string[];
  };
  score: number;
  recommendations: string[];
}

export interface AmpAnalysis {
  isAmpPage: boolean;
  ampVersion: string;
  ampComponents: {
    name: string;
    valid: boolean;
    errors?: string[];
  }[];
  canonicalRelation: {
    hasCanonical: boolean;
    canonicalUrl: string;
    isValid: boolean;
  };
  ampSize: {
    size: number;
    exceedsLimit: boolean;
  };
  score: number;
  recommendations: string[];
}

export interface ResourceUsageAnalysis {
  iframes: {
    count: number;
    elements: {
      src: string;
      hasSandbox: boolean;
      securityAttributes: {
        sandbox?: string;
        allowScripts?: boolean;
        allowSameOrigin?: boolean;
      };
      loading: string;
    }[];
    exceedsLimit: boolean;
    securityIssues: string[];
  };
  flash: {
    detected: boolean;
    elements: {
      type: string;
      src: string;
      hasAlternative: boolean;
    }[];
    alternatives: string[];
  };
  score: number;
  recommendations: string[];
}

export interface CookieAnalysis {
  cookies: {
    name: string;
    domain: string;
    value: string;
    size: number;
    httpOnly: boolean;
    secure: boolean;
    sameSite: string;
    category?: string;
  }[];
  statistics: {
    totalCount: number;
    totalSize: number;
    categoryCounts: Record<string, number>;
    exceedsLimit: boolean;
  };
  gdprCompliance: {
    hasConsentManager: boolean;
    necessaryOnly: boolean;
    issues: string[];
  };
  score: number;
  recommendations: string[];
}
 
                                                                            C:\Workspace\Web\Ai Business grow project\Back_end\src\crawler\repository\crawling-data.repository.ts 
import { Injectable } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { CrawlingData } from '../schemas/crawling-data.schema';
import {  Inject } from '@nestjs/common';
import { CACHE_MANAGER } from '@nestjs/cache-manager';
import { Cache } from 'cache-manager';

@Injectable()
export class CrawlingDataRepository {
  constructor(
    @InjectModel(CrawlingData.name) private crawlingDataModel: Model<CrawlingData>,
    @Inject(CACHE_MANAGER) private cacheManager: Cache
  ) {}

  async bulkUpdateCrawlingData(pagesData: any[]): Promise<void> {
    const bulkOps = pagesData.map(pageData => ({
      updateOne: {
        filter: { crawlingId: pageData.crawlingId, pageUrlRelative: pageData.pageUrlRelative },
        update: pageData,
        upsert: true
      }
    }));

    await this.crawlingDataModel.bulkWrite(bulkOps);
  }

  async getCrawlingDataById(crawlingId: string): Promise<CrawlingData[]> {
    const cacheKey = `crawling_data_${crawlingId}`;
    const cachedData = await this.cacheManager.get<CrawlingData[]>(cacheKey);

    if (cachedData) {
      return cachedData;
    }

    const data = await this.crawlingDataModel.find({ crawlingId }).exec();
    await this.cacheManager.set(cacheKey, data,  3600 ); // Cache for 1 hour

    return data;
  }

  async updateDirectoryTreeData(crawlingId: string, directoryTreeData: any): Promise<void> {
    const { directoryTree, depth, fileCount, folderCount, fileTypes } = this.processDirectoryTree(directoryTreeData);

    await this.crawlingDataModel.findOneAndUpdate(
      { crawlingId },
      {
        directoryTree,
        directoryTreeDepth: depth,
        directoryTreeFileCount: fileCount,
        directoryTreeFolderCount: folderCount,
        directoryTreeFileTypes: fileTypes,
      },
      { upsert: true, new: true }
    );
  }

  private processDirectoryTree(tree: any, depth = 0): any {
    let fileCount = 0;
    let folderCount = 0;
    const fileTypes = new Set<string>();

    const processNode = (node: any, currentDepth: number) => {
      if (node.type === 'file') {
        fileCount++;
        const fileExtension = node.name.split('.').pop();
        if (fileExtension) {
          fileTypes.add(fileExtension.toLowerCase());
        }
      } else if (node.type === 'directory') {
        folderCount++;
        if (node.children) {
          node.children.forEach((child: any) => processNode(child, currentDepth + 1));
        }
      }
    };

    processNode(tree, 0);

    return {
      directoryTree: tree,
      depth,
      fileCount,
      folderCount,
      fileTypes: Array.from(fileTypes),
    };
  }

  async calculateAverageScores(crawlingId: string): Promise<Record<string, number>> {
    const aggregationResult = await this.crawlingDataModel.aggregate([
      { $match: { crawlingId } },
      { $group: {
          _id: null,
          totalScores: { $push: "$seoScores" },
          count: { $sum: 1 }
        }
      }
    ]);

    if (aggregationResult.length === 0) {
      return {};
    }

    const { totalScores, count } = aggregationResult[0];
    const averageScores: Record<string, number> = {};

    Object.keys(totalScores[0]).forEach(key => {
      const sum = totalScores.reduce((acc, scores) => acc + (scores[key] || 0), 0);
      averageScores[key] = sum / count;
    });

    return averageScores;
  }
} 
                                                                                C:\Workspace\Web\Ai Business grow project\Back_end\src\crawler\schemas\crawling-data.schema.ts 
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document } from 'mongoose';

@Schema({ 
  timestamps: true,
  toJSON: { virtuals: true },
  toObject: { virtuals: true }
})
export class CrawlingData extends Document {
  @Prop({ index: true })
  crawlingId: string;

  @Prop()
  pageTitle: string;

  @Prop({ index: true })
  pageUrlRelative: string;

  @Prop({ type: Object })
  pageMetaData: Record<string, string>;

  @Prop({ type: Array })
  imageData: any[];

  @Prop()
  mainContent: string;

  @Prop()
  wordCount: number;

  @Prop()
  loadTime: number;

  @Prop({ type: Object })
  urlStructure: Record<string, string>;

  @Prop({ type: Object })
  brandingElements: Record<string, boolean>;

  @Prop({ type: [String] })
  structuredData: string[];

  @Prop({ type: Object })
  seoScores: Record<string, number>;

  @Prop({ type: Object })
  directoryTree: {
    name: string;
    type: string;
    children: any[];
  };

  @Prop()
  directoryTreeDepth: number;

  @Prop()
  directoryTreeFileCount: number;

  @Prop()
  directoryTreeFolderCount: number;

  @Prop({ type: [String] })
  directoryTreeFileTypes: string[];

  @Prop({ type: Object })
  urlAnalysis: {
    isValid: boolean;
    protocol?: string;
    hostname?: string;
    pathname?: string;
    search?: string;
    hash?: string;
    isClean?: boolean;
    depth?: number;
    pattern?: string;
    isWithinDepthLimit?: boolean;
    isLowercase?: boolean;
    hasPreferredProtocol?: boolean;
    queryStringAnalysis?: {
      paramCount: number;
      exceedsMaxParams: boolean;
      params: { key: string; value: string }[];
    };
    fragmentAnalysis?: {
      hasFragment: boolean;
      fragmentLength: number;
      exceedsMaxLength: boolean;
    };
  };

  @Prop({ type: Object })
  urlParameterAnalysis: {
    parameterCount: number;
    parameterDetails: {
      name: string;
      value: string;
      length: number;
    }[];
    exceedsMaxCount: boolean;
    exceedsMaxLength: boolean;
  };

  @Prop({ type: Object })
  urlLengthAnalysis: {
    totalLength: number;
    pathLength: number;
    queryLength: number;
    fragmentLength: number;
    exceedsTotalLength: boolean;
    exceedsPathLength: boolean;
    exceedsQueryLength: boolean;
    exceedsFragmentLength: boolean;
  };

  @Prop({ type: Object })
  httpStatusCodeAnalysis: {
    statusCode: number;
    category: string;
    seoImpact: string;
  };

  @Prop({ type: Object })
  contentTypeAnalysis: {
    contentType: string;
    category: string;
    isAllowed: boolean;
    exceedsMaxSize: boolean;
  };

  @Prop({ type: Object })
  xRobotsTagAnalysis?: {
    present: boolean;
    value?: string;
    directives?: {
      noindex: boolean;
      nofollow: boolean;
      none: boolean;
      noarchive: boolean;
      nosnippet: boolean;
      notranslate: boolean;
      noimageindex: boolean;
      unavailable_after: string | null;
    };
    exceedsMaxLength?: boolean;
  };

  @Prop({ type: Object })
  securityHeaderAnalysis?: {
    analyzed: boolean;
    headers?: {
      [key: string]: {
        present: boolean;
        value: string;
      };
    };
  };

  @Prop({ type: Object })
  titleTagAnalysis?: {
    content: string;
    length: number;
    pixelWidth: number;
    isTooShort: boolean;
    isTooLong: boolean;
    isPixelWidthTooNarrow: boolean;
    isPixelWidthTooWide: boolean;
  };

  @Prop({ type: Object })
  metaDescriptionAnalysis?: {
    content: string;
    length: number;
    isTooShort: boolean;
    isTooLong: boolean;
    keywordCount: number;
    hasEnoughKeywords: boolean;
  };

  @Prop({ type: Object })
  headingAnalysis: {
    headingCounts: {
      counts: Record<string, number>;
      hasIdealH1Count: boolean;
      exceedsMaxCounts: Record<string, boolean>;
    };
    headingOrder: {
      isCorrectOrder: boolean;
      headingSequence: string[];
    };
    headingContent: {
      [key: string]: { content: string; length: number; exceedsMaxLength: boolean }[];
    };
  };

  @Prop({ type: Object })
  metaKeywordsAnalysis?: {
    content: string;
    keywordCount: number;
    keywords: string[];
    exceedsMaxCount: boolean;
  };

  @Prop({ type: Object })
  metaRobotsTagAnalysis?: {
    content: string;
    length: number;
    isTooLong: boolean;
    directives: Record<string, boolean>;
    stats: {
      noindexCount: number;
      nofollowCount: number;
      otherDirectivesCount: number;
    };
  };

  @Prop({ type: Object })
  canonicalTagAnalysis?: {
    href: string | null;
    isValid: boolean;
    issues: string[];
  };

  @Prop({ type: Object })
  relLinkAnalysis?: {
    nextLink: string | null;
    prevLink: string | null;
    isPartOfSeries: boolean;
  };

  @Prop({ type: Object })
  hreflangAnalysis?: {
    tags: { hreflang: string; href: string }[];
    count: number;
    hasXDefault: boolean;
    exceedsMaxTags: boolean;
    missingRequiredAttributes: boolean;
  };

  @Prop({ type: Object })
openGraphAnalysis?: {
  properties: { property: string; content: string }[];
  missingRequiredProperties: string[];
  isValid: boolean;
  contentQualityAnalysis: {
    titleQuality: { length: number; isOptimal: boolean };
    descriptionQuality: { length: number; isOptimal: boolean };
    imageQuality: { url: string; dimensions: { width: number; height: number } | null; isOptimal: boolean };
  };
  recommendations: string[];
};

@Prop({ type: Object })
twitterCardAnalysis?: {
  properties: { name: string; content: string }[];
  missingRequiredProperties: string[];
  isValid: boolean;
  contentQualityAnalysis: {
    cardType: string;
    titleQuality: { length: number; isOptimal: boolean };
    descriptionQuality: { length: number; isOptimal: boolean };
    imageQuality: { url: string; dimensions: { width: number; height: number } | null; isOptimal: boolean };
  };
  recommendations: string[];
};

@Prop({ type: Object })
viewportAnalysis?: {
  content: string | undefined;
  isPresent: boolean;
  isRecommendedValue: boolean;
  properties: { [key: string]: string };
  responsiveAnalysis: {
    isResponsive: boolean;
    hasInitialScale: boolean;
    initialScaleValue: number | null;
  };
  recommendations: string[];
};

@Prop({ type: Object })
keywordDensity: Record<string, number>;

@Prop({ type: Object })
keywordUsage: Record<string, number>;

@Prop()
detectedLanguage: string;

@Prop()
contentToHtmlRatio: number;

@Prop()
contentHash: string;

@Prop()
characterCount: number;

@Prop()
sentenceCount: number;

@Prop()
paragraphCount: number;

@Prop()
readabilityScore: number;

@Prop({ type: Object })
topKeywords: Record<string, number>;

@Prop({ type: Object })
thinContentAnalysis: {
  isThinContent: boolean;
  wordCount: number;
  charCount: number;
  contentDensity: number;
  contentToHtmlRatio: number;
  mainContentWordCount: number;
  fullPageWordCount: number;
  specificElementsAnalysis: {
    hasMain: boolean;
    hasArticle: boolean;
    hasContentWrapper: boolean;
  };
};

@Prop({ type: Object })
readabilityAnalysis: {
  fleschKincaidGrade: number;
  automatedReadabilityIndex: number;
  colemanLiauIndex: number;
  averageGradeLevel: number;
  sentenceCount: number;
  wordCount: number;
  syllableCount: number;
  averageWordLength: number;
  averageSyllablesPerWord: number;
  averageWordsPerSentence: number;
};

@Prop({ type: [Object] })
imageAnalysis: {
  url: string;
  altText: {
    present: boolean;
    content: string;
    length: number;
    keywordsPresent: string[];
  };
  titleAttribute: {
    present: boolean;
    content: string;
  };
  fileSize?: number;
  dimensions?: {
    width: number;
    height: number;
  };
  fileFormat?: string;
  isBroken: boolean;
  textInImage?: {
    hasText: boolean;
    text: string;
    confidence: number;
  };
  seoAnalysis?: {
    altTextQuality: string;
    fileSizeOptimized: boolean;
    dimensionsOptimal: boolean;
    formatOptimal: boolean;
    textInImageIssue: boolean;
  };
}[];

@Prop()
totalImages: number;

@Prop()
brokenImages: number;

@Prop()
imagesWithoutAlt: number;

@Prop()
imagesWithoutTitle: number;

@Prop()
oversizedImages: number;

@Prop()
imagesWithTextContent: number;

@Prop({ type: Object })
imageFormatDistribution: Record<string, number>;

@Prop({ type: [String] })
uniqueImageUrls: string[];

@Prop({ type: Object })
jsRenderingAnalysis: {
  contentDifference: {
    textLengthDifference: number;
    wordCountDifference: number;
    newHeadings: { [key: string]: string[] };
    newParagraphs: number;
    newImages: { src: string; alt: string }[];
    newLinks: { href: string; text: string }[];
  };
  dynamicElements: {
    lazyLoadedImages: {
      count: number;
      urls: string[];
    };
    infiniteScroll: boolean;
    dynamicTabs: boolean;
    ajaxForms: boolean;
  };
  seoImpact: {
    titleChange: {
      changed: boolean;
      original: string;
      rendered: string;
    };
    metaDescriptionChange: {
      changed: boolean;
      original: string;
      rendered: string;
    };
    canonicalUrlChange: {
      changed: boolean;
      original: string;
      rendered: string;
    };
    structuredDataChange: {
      changed: boolean;
      original: any[];
      rendered: any[];
    };
    hreflangChange: {
      changed: boolean;
      original: { hreflang: string; href: string }[];
      rendered: { hreflang: string; href: string }[];
    };
  };
};

@Prop()
renderedContent: string;

@Prop({ type: Object })
ajaxContent: {
  [key: string]: string;
};

@Prop({ type: [Object] })
spaRoutes: {
  path: string;
  content: string;
}[];

@Prop({ type: Object })
technicalSeoAnalysis: {
  performance: {
    ttfb: number;
    domLoadTime: number;
    fullLoadTime: number;
    firstContentfulPaint: number;
    speedIndex: number;
    performanceScore: number;
    resourceLoadTimes: {
      url: string;
      type: string;
      duration: number;
      size: number;
      protocol: string;
    }[];
    issues: string[];
  };
  compression: {
    type: string;
    originalSize: number;
    compressedSize: number;
    compressionRatio: number;
    isOptimal: boolean;
    suggestions: string[];
    compressionScore: number;
  };
  http2: {
    enabled: boolean;
    serverPushEnabled: boolean;
    multiplexingUsed: boolean;
    concurrentStreams: number;
    connectionEfficiency: number;
    http2Score: number;
    suggestions: string[];
  };
  pageSize: {
    totalSize: number;
    htmlSize: number;
    resourceSizes: {
      js: number;
      css: number;
      images: number;
      fonts: number;
      other: number;
    };
    exceedsLimits: boolean;
    pageSizeScore: number;
    suggestions: string[];
  };
  resourceOptimization: {
    totalResources: number;
    resourcesByType: {
      js: number;
      css: number;
      images: number;
      fonts: number;
      other: number;
    };
    blockingResources: {
      js: string[];
      css: string[];
    };
    deferredResources: {
      js: string[];
      css: string[];
    };
    optimizationScore: number;
    suggestions: string[];
  };
  caching: {
    resourcesCached: number;
    totalResources: number;
    cachingScore: number;
    cacheHeaders: {
      resource: string;
      cacheControl: string;
      expires: string;
      etag: boolean;
    }[];
    suggestions: string[];
  };
  cdnUsage: {
    enabled: boolean;
    provider: string;
    resourcesServed: number;
    cdnScore: number;
    suggestions: string[];
  };
  overallTechnicalScore: number;
  mobileFriendliness: {
    viewport: {
      hasViewport: boolean;
      isResponsive: boolean;
      viewportContent: string;
      issues: string[];
    };
    touchElements: {
      elementsWithSmallTargets: {
        selector: string;
        size: number;
        spacing: number;
      }[];
      totalIssues: number;
    };
    fontSize: {
      tooSmallElements: {
        selector: string;
        size: number;
      }[];
      totalIssues: number;
    };
    contentWidth: {
      exceedsViewport: boolean;
      horizontalScrolling: boolean;
      contentWidth: number;
      viewportWidth: number;
    };
    mediaQueries: {
      hasResponsiveImages: boolean;
      responsiveBreakpoints: number[];
      missingBreakpoints: string[];
    };
    score: number;
    recommendations: string[];
  };
  ampAnalysis: {
    isAmpPage: boolean;
    ampVersion: string;
    ampComponents: {
      name: string;
      valid: boolean;
      errors?: string[];
    }[];
    canonicalRelation: {
      hasCanonical: boolean;
      canonicalUrl: string;
      isValid: boolean;
    };
    ampSize: {
      size: number;
      exceedsLimit: boolean;
    };
    score: number;
    recommendations: string[];
  };
  resourceUsageAnalysis: {
    iframes: {
      count: number;
      elements: {
        src: string;
        hasSandbox: boolean;
        securityAttributes: {
          sandbox?: string;
          allowScripts?: boolean;
          allowSameOrigin?: boolean;
        };
        loading: string;
      }[];
      exceedsLimit: boolean;
      securityIssues: string[];
    };
    flash: {
      detected: boolean;
      elements: {
        type: string;
        src: string;
        hasAlternative: boolean;
      }[];
      alternatives: string[];
    };
    score: number;
    recommendations: string[];
  };
  cookieAnalysis: {
    cookies: {
      name: string;
      domain: string;
      value: string;
      size: number;
      httpOnly: boolean;
      secure: boolean;
      sameSite: string;
      category?: string;
    }[];
    statistics: {
      totalCount: number;
      totalSize: number;
      categoryCounts: Record<string, number>;
      exceedsLimit: boolean;
    };
    gdprCompliance: {
      hasConsentManager: boolean;
      necessaryOnly: boolean;
      issues: string[];
    };
    score: number;
    recommendations: string[];
  };

};

@Prop({ type: Object })
structuredDataAnalysis: {
  jsonLd: {
    data: any[];
    count: number;
    valid: boolean;
    errors: {
      type: string;
      message: string;
      severity: string;
    }[];
  };
  microdata: {
    data: any[];
    count: number;
    nestingValid: boolean;
    errors: {
      type: string;
      message: string;
      severity: string;
    }[];
  };
  rdfa: {
    data: any[];
    count: number;
    prefixesValid: boolean;
    errors: {
      type: string;
      message: string;
      severity: string;
    }[];
  };
  schemaTypes: {
    identifiedTypes: string[];
    deprecatedTypes: string[];
    missingRecommendedTypes: string[];
    coverage: number;
  };
  richSnippets: {
    eligibleSnippets: {
      type: string;
      confidence: number;
      enhancementPossibilities: {
        property: string;
        impact: string;
        recommendation: string;
      }[];
    }[];
    missingRequirements: {
      type: string;
      missing: string[];
    }[];
    potentialImprovements: string[];
  };
  validation: {
    isValid: boolean;
    errors: {
      type: string;
      message: string;
      severity: string;
    }[];
    warnings: {
      type: string;
      message: string;
      impact: string;
    }[];
    errorCount: number;
    warningCount: number;
  };
  competitive: {
    industryStandardsAlignment: number;
    comprehensivenessScore: number;
    uniqueFeatures: string[];
    improvements: string[];
  };
  recommendations: {
    type: string;
    priority: string;
    message: string;
    impact: string;
    implementation: any;
  }[];
  implementationScore: number;
  seoImpact: {
    visibility: {
      score: number;
      factors: string[];
    };
    richSnippetPotential: {
      score: number;
      opportunities: string[];
    };
    competitiveAdvantage: {
      score: number;
      strengths: string[];
      weaknesses: string[];
    };
  };
};

}



export const CrawlingDataSchema = SchemaFactory.createForClass(CrawlingData);

CrawlingDataSchema.index({ crawlingId: 1, pageUrlRelative: 1 }, { unique: true }); 
                                                                                C:\Workspace\Web\Ai Business grow project\Back_end\src\crawler\schemas\crawling-session.schema.ts 
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document } from 'mongoose';

@Schema()
export class CrawlingSession extends Document {
  @Prop({ required: true, unique: true })
  crawlingId: string;

  @Prop({ required: true })
  websiteDomain: string;

  @Prop({ type: [String] })
  startingPoints: string[];

  @Prop({ type: [String] })
  extractedKeywords: string[];

  @Prop({ type: Object })
  canonicalConsistencyAnalysis: {
    isConsistent: boolean;
    inconsistencies: {
      canonicalUrl: string;
      conflictingUrls: string[];
    }[];
  };

  @Prop({ type: [{ url: String, duplicateUrls: [String] }] })
  duplicateContent: { url: string; duplicateUrls: string[] }[];

  @Prop({ type: [{ url: String, nearDuplicateUrls: [String] }] })
  nearDuplicateContent: { url: string; nearDuplicateUrls: string[] }[];
}
export const CrawlingSessionSchema = SchemaFactory.createForClass(CrawlingSession);
 
                                                                                C:\Workspace\Web\Ai Business grow project\Back_end\src\crawler\schemas\queued-task.schema.ts 
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document } from 'mongoose';

@Schema()
export class QueuedTask extends Document {
  @Prop({ required: true })
  url: string;

  @Prop({ required: true })
  priority: number;

  @Prop({ required: true })
  depth: number;
}

export const QueuedTaskSchema = SchemaFactory.createForClass(QueuedTask);
 
                                                                                    C:\Workspace\Web\Ai Business grow project\Back_end\src\crawler\services\async-http.service.ts 
import { Injectable, Logger } from '@nestjs/common';
import { HttpService } from '@nestjs/axios';
import { ConfigService } from '@nestjs/config';
import { AxiosRequestConfig, AxiosResponse, AxiosResponseHeaders, RawAxiosResponseHeaders } from 'axios';
import { RateLimiterService } from './rate-limiter.service';
import { firstValueFrom } from 'rxjs';
import { RateLimitExceededException, CrawlerNetworkException } from '../exceptions/crawler.exceptions';
import { HttpHeaderService } from './analysis/http-header.service';
import { ContentTypeAnalyzerService } from './analysis/content-type-analyzer.service';
import { TechnicalSeoAnalysisService } from './analysis/technical-seo-analysis.service';
import { JSDOM } from 'jsdom';
import * as cheerio from 'cheerio';


@Injectable()
export class AsyncHttpService {
  private readonly logger = new Logger(AsyncHttpService.name);

  constructor(
    private readonly configService: ConfigService,
    private readonly httpService: HttpService,
    private readonly rateLimiterService: RateLimiterService,
    private readonly httpHeaderService: HttpHeaderService,
    private readonly contentTypeAnalyzerService: ContentTypeAnalyzerService,
    private readonly technicalSeoAnalysisService: TechnicalSeoAnalysisService
  ) {}

  async get(url: string, config?: AxiosRequestConfig): Promise<EnhancedAxiosResponse> {
    const startTime = performance.now();
    const resourceTimings = [];
    const resourcePromises = [];
    let loadTime: number;
  
    try {
      await this.rateLimiterService.acquire();
      
      const response = await firstValueFrom(
        this.httpService.get(url, {
          ...config,
          timeout: this.configService.get<number>('CRAWLER_REQUEST_TIMEOUT', 30000),
          headers: {
            ...config?.headers,
            'User-Agent': this.configService.get<string>('CRAWLER_USER_AGENT', 'SeoOptimizerCrawler/1.0'),
          },
          responseType: 'arraybuffer',
          onDownloadProgress: (progressEvent) => {
            loadTime = performance.now();
          }
        })
      );

      const dom = new JSDOM(response.data.toString());
      const document = dom.window.document;
      const $ = cheerio.load(response.data);
      const scripts:any  = document.getElementsByTagName('script');
      for (const script of scripts) {
        if (script.src) {
          resourcePromises.push(this.trackResource(script.src, 'javascript', resourceTimings));
        }
      }
  
      // Track CSS resources
      const styles:any[]  = document.getElementsByTagName('link');
      for (const style of styles) {
        if (style.rel === 'stylesheet') {
          resourcePromises.push(this.trackResource(style.href, 'stylesheet', resourceTimings));
        }
      }
  
      // Track Images
      const images:any  = document.getElementsByTagName('img');
      for (const img of images) {
        if (img.src) {
          resourcePromises.push(this.trackResource(img.src, 'image', resourceTimings));
        }
      }
  
      // Track Fonts
      const fonts:any = Array.from(styles).filter(style => style.rel === 'preload' && style.as === 'font');
      for (const font of fonts) {
        if (font.href) {
          resourcePromises.push(this.trackResource(font.href, 'font', resourceTimings));
        }
      }

      await Promise.allSettled(resourcePromises);
        
      const timing = {
        startTime,
        ttfb: performance.now(),
        domContentLoadedTime: performance.now(),
        loadTime: loadTime,
        resourceTimings
      };
      
      const stringHeaders = this.convertHeadersToStringRecord(response.headers);
      const contentTypeAnalysis = this.httpHeaderService.analyzeContentType(stringHeaders);
      const mimeTypeAnalysis = this.contentTypeAnalyzerService.analyzeMimeType(contentTypeAnalysis.contentType, url);
      const xRobotsTagAnalysis = this.httpHeaderService.analyzeXRobotsTag(stringHeaders);
  
      // Perform technical SEO analysis
      const performanceMetrics = await this.technicalSeoAnalysisService.analyzePerformance(response, timing);
      const compressionAnalysis = await this.technicalSeoAnalysisService.analyzeCompression(response);
      const http2Analysis = this.technicalSeoAnalysisService.analyzeHttp2(response);
      const pageSizeAnalysis = this.technicalSeoAnalysisService.analyzePageSize(response, timing.resourceTimings);
      const pageTechnicalSeoAnalysis = await this.technicalSeoAnalysisService.analyzePage($.html(), url, stringHeaders);
      return {
        ...response,
        contentTypeAnalysis,
        mimeTypeAnalysis,
        xRobotsTagAnalysis,
        technicalSeoAnalysis: {
          performanceMetrics,
          compressionAnalysis,
          http2Analysis,
          pageSizeAnalysis,
          ...pageTechnicalSeoAnalysis
         }
      }
    } catch (error) {
      this.logger.error(`Error fetching ${url}: ${error.message}`);
      throw new CrawlerNetworkException(`Failed to fetch ${url}: ${error.message}`);
    }
  }

  async post(url: string, data?: any, config?: AxiosRequestConfig): Promise<AxiosResponse> {
    const timeout = this.configService.get<number>('CRAWLER_REQUEST_TIMEOUT', 30000);
    const userAgent = this.configService.get<string>('CRAWLER_USER_AGENT', 'SeoOptimizer Crawler/1.0');

    try {
      await this.rateLimiterService.acquire();
    } catch (error) {
      if (error instanceof RateLimitExceededException) {
        this.logger.warn(`Rate limit exceeded for URL: ${url}. Skipping.`);
        throw error;
      }
    }

    try {
      const response = await firstValueFrom(this.httpService.post(url, data, {
        ...config,
        timeout,
        headers: {
          ...config?.headers,
          'User-Agent': userAgent,
        },
      }));
      return response;
    } catch (error) {
      this.logger.error(`Error posting to ${url}: ${error.message}`);
      throw new CrawlerNetworkException(`Failed to post to ${url}: ${error.message}`);
    }
  }

  private convertHeadersToStringRecord(headers: RawAxiosResponseHeaders | AxiosResponseHeaders): Record<string, string> {
    const stringHeaders: Record<string, string> = {};
    for (const [key, value] of Object.entries(headers)) {
      if (Array.isArray(value)) {
        stringHeaders[key] = value.join(', ');
      } else if (value !== undefined) {
        stringHeaders[key] = String(value);
      }
    }
    return stringHeaders;
  }

  async head(url: string, config?: AxiosRequestConfig): Promise<AxiosResponse> {
    const timeout = this.configService.get<number>('CRAWLER_REQUEST_TIMEOUT', 30000);
    const userAgent = this.configService.get<string>('CRAWLER_USER_AGENT', 'SeoOptimizer Crawler/1.0');

    try {
      await this.rateLimiterService.acquire();
    } catch (error) {
      if (error instanceof RateLimitExceededException) {
        this.logger.warn(`Rate limit exceeded for URL: ${url}. Skipping.`);
        throw error;
      }
    }

    try {
      const response = await firstValueFrom(this.httpService.head(url, {
        ...config,
        timeout,
        headers: {
          ...config?.headers,
          'User-Agent': userAgent,
        },
      }));
      return response;
    } catch (error) {
      this.logger.error(`Error making HEAD request to ${url}: ${error.message}`);
      throw new CrawlerNetworkException(`Failed to make HEAD request to ${url}: ${error.message}`);
    }
  }

  private async trackResource(url: string, type: string, resourceTimings: any[]): Promise<void> {
    const startTime = performance.now();
    try {
      const response = await firstValueFrom(
        this.httpService.head(url, {
          timeout: 5000,
          validateStatus: () => true
        })
      );
      
      const endTime = performance.now();
      resourceTimings.push({
        url,
        type,
        duration: endTime - startTime,
        size: parseInt(response.headers['content-length'] || '0'),
        protocol: response.request.protocol
      });
    } catch (error) {
      this.logger.warn(`Failed to track resource ${url}: ${error.message}`);
    }
  }
}

interface EnhancedAxiosResponse extends AxiosResponse {
  contentTypeAnalysis: {
    contentType: string;
    category: string;
    isAllowed: boolean;
    exceedsMaxSize: boolean;
  };
  mimeTypeAnalysis: {
    declaredMimeType: string;
    detectedMimeType: string;
    mimeTypeMatch: boolean;
    fileExtension: string;
  };
  xRobotsTagAnalysis: XRobotsTagAnalysis;
  technicalSeoAnalysis: {
    performanceMetrics: {
      ttfb: number;
      domLoadTime: number;
      fullLoadTime: number;
      firstContentfulPaint: number;
      speedIndex: number;
      resourceLoadTimes: {
        url: string;
        type: string;
        duration: number;
        size: number;
        protocol: string;
      }[];
    };
    compressionAnalysis: {
      type: string;
      originalSize: number;
      compressedSize: number;
      compressionRatio: number;
      isOptimal: boolean;
      suggestions: string[];
    };
    http2Analysis: {
      enabled: boolean;
      serverPushEnabled: boolean;
      multiplexingUsed: boolean;
      concurrentStreams: number;
      connectionEfficiency: number;
      suggestions: string[];
    };
    pageSizeAnalysis: {
      totalSize: number;
      htmlSize: number;
      resourceSizes: {
        js: number;
        css: number;
        images: number;
        fonts: number;
        other: number;
      };
      exceedsLimits: boolean;
      suggestions: string[];
    };
    mobileFriendlinessAnalysis;
    ampAnalysis;
    resourceUsageAnalysis;
    cookieAnalysis;
    overallScore; 
  };

}

interface XRobotsTagAnalysis {
  present: boolean;
  value?: string;
  directives?: {
    noindex: boolean;
    nofollow: boolean;
    none: boolean;
    noarchive: boolean;
    nosnippet: boolean;
    notranslate: boolean;
    noimageindex: boolean;
    unavailable_after: string | null;
  };
  exceedsMaxLength?: boolean;
} 
                                                                                    C:\Workspace\Web\Ai Business grow project\Back_end\src\crawler\services\crawler-worker.service.ts 
import { Injectable, Logger } from '@nestjs/common';
import { ContentExtractor } from './extraction/content-extractor';
import { SEOAnalyzer } from './analysis/seo-analyzer';
import { UrlExtractor } from './extraction/url-extractor';
import { CrawlingDataRepository } from '../repository/crawling-data.repository';
import { CrawlerConfigService } from '../config/crawler-config.service';
import { RobotsTxtService } from './robot/robots-txt.service';
import { InclusionExclusionService } from '../config/inclusion-exclusion.service';
import { DirectoryTreeAnalyzer } from './analysis/directory-tree-analyzer';
import { DirectoryTreeCrawlerService } from './directory-tree/directory-tree-crawler.service';
import { AsyncHttpService } from './async-http.service';
import * as cheerio from 'cheerio';
import { RateLimitExceededException, CrawlerNetworkException, CrawlerParsingException } from '../exceptions/crawler.exceptions';
import { UrlAnalyzerService } from './analysis/url-analyzer.service';
import { HttpHeaderService } from './analysis/http-header.service';
import { ContentTypeAnalyzerService } from './analysis/content-type-analyzer.service';
import { OnPageElementService } from './analysis/on-page-element.service';
import { CrawlingSessionService } from './crawling-session.service';
import { ContentAnalysisService } from './analysis/content-analysis.service';
import { ImageAnalysisService } from './analysis/image-analysis.service';
import { JavaScriptRenderingService } from './javascript-rendering.service';
import { JavaRenderingScriptAnalysisService } from './analysis/java-rendering-script-analysis.service';
import { StructuredDataAnalysisService } from './analysis/structured-data-analysis.service';



@Injectable()
export class CrawlerWorker {
  private contentExtractor: ContentExtractor;
  private seoAnalyzer: SEOAnalyzer;
  private urlExtractor: UrlExtractor;
  private readonly logger = new Logger(CrawlerWorker.name);

  constructor(
    private crawlingDataRepository: CrawlingDataRepository,
    private crawlerConfigService: CrawlerConfigService,
    private robotsTxtService: RobotsTxtService,
    private inclusionExclusionService: InclusionExclusionService,
    private directoryTreeAnalyzer: DirectoryTreeAnalyzer,
    private directoryTreeCrawlerService: DirectoryTreeCrawlerService,
    private asyncHttpService: AsyncHttpService,
    private urlAnalyzerService: UrlAnalyzerService,
    private httpHeaderService: HttpHeaderService,
    private contentTypeAnalyzerService: ContentTypeAnalyzerService,
    private onPageElementService: OnPageElementService,
    private crawlingSessionService: CrawlingSessionService,
    private contentAnalysisService: ContentAnalysisService,
    private imageAnalysisService: ImageAnalysisService,
    private javaRenderingScriptAnalysisService: JavaRenderingScriptAnalysisService,
    private javascriptRenderingService: JavaScriptRenderingService,
    private structuredDataAnalysisService: StructuredDataAnalysisService,

  ) {
    this.contentExtractor = new ContentExtractor();
    this.seoAnalyzer = new SEOAnalyzer(this.directoryTreeAnalyzer, crawlerConfigService);
    this.urlExtractor = new UrlExtractor(crawlerConfigService, robotsTxtService, inclusionExclusionService);
  }

  async crawlAndExtract(crawlingId: string, url: string, depth: number, crawlConfig: any): Promise<any> {
    try {
     
      const { $, loadTime, statusCode, contentTypeAnalysis, mimeTypeAnalysis, xRobotsTagAnalysis, headers, technicalSeoAnalysis  } = await this.fetchPageWithStatus(url);
     
      if (statusCode >= 400) {
        this.logger.warn(`Broken link detected: ${url} (Status: ${statusCode})`);
        return { 
          crawlingId,
          pageUrlRelative: url,
          isBroken: true,
          statusCode,
          depth,
          newUrls: []
        };
      }
     
      const urlAnalysis = this.urlAnalyzerService.analyzeUrl(url);
      const urlParameterAnalysis = this.urlAnalyzerService.analyzeUrlParameters(url);
      const urlLengthAnalysis = this.urlAnalyzerService.analyzeUrlLength(url);
      const httpStatusCodeAnalysis = this.httpHeaderService.analyzeHttpStatusCode(statusCode);
      const securityHeaderAnalysis = this.httpHeaderService.analyzeSecurityHeaders(headers);
      const securityHeaderScore = this.seoAnalyzer.calculateSecurityHeaderScore(securityHeaderAnalysis);
      const titleTagAnalysis = this.onPageElementService.analyzeTitleTag($);
      const titleTagScore = this.seoAnalyzer.calculateTitleTagScore(titleTagAnalysis);
      const siteKeywords = await this.crawlingSessionService.getExtractedKeywords(crawlingId);
      const metaDescriptionAnalysis = this.onPageElementService.analyzeMetaDescription($, siteKeywords);
      const metaDescriptionScore = this.seoAnalyzer.calculateMetaDescriptionScore(metaDescriptionAnalysis);
      const headingAnalysis = this.onPageElementService.analyzeHeadings($);
      const headingAnalysisScore = this.seoAnalyzer.calculateHeadingScore(headingAnalysis);
      const metaKeywordsAnalysis = this.onPageElementService.analyzeMetaKeywords($);
      const metaRobotsTagAnalysis = this.onPageElementService.analyzeMetaRobotsTag($);
      const metaRobotsTagScore =this.seoAnalyzer.calculateMetaRobotsTagScore(metaRobotsTagAnalysis);
      const canonicalTagAnalysis = this.onPageElementService.analyzeCanonicalTag($, url);
      const relLinkAnalysis = this.onPageElementService.analyzeRelLinks($);
      const relLinkScore = this.seoAnalyzer.calculateRelLinkScore(relLinkAnalysis);
      const openGraphAnalysis = this.onPageElementService.analyzeOpenGraphTags($);
      const twitterCardAnalysis = this.onPageElementService.analyzeTwitterCardTags($);
      const viewportAnalysis = this.onPageElementService.analyzeViewportMetaTag($);
      const openGraphScore = this.seoAnalyzer.calculateOpenGraphScore(openGraphAnalysis);
      const twitterCardScore = this.seoAnalyzer.calculateTwitterCardScore(twitterCardAnalysis);
      const viewportScore = this.seoAnalyzer.calculateViewportScore(viewportAnalysis);
      const detectedLanguage = await this.contentAnalysisService.detectLanguage($);
      const keywordDensity = this.contentAnalysisService.calculateKeywordDensity($, siteKeywords);
      const keywordUsage = this.contentAnalysisService.analyzeKeywordUsage($, siteKeywords);
      const textContent = this.contentAnalysisService.extractTextContent($);
      const contentToHtmlRatio = this.contentAnalysisService.calculateContentToHtmlRatio($);
      const contentHash = this.contentAnalysisService.generateContentHash(textContent);
      const wordCount = this.contentAnalysisService.countWords(textContent);
      const wordCountScore = this.seoAnalyzer.calculateWordCountScore(wordCount);
      const characterCount = textContent.length;
      const sentenceCount = this.contentAnalysisService.countSentences(textContent);
      const paragraphCount = this.contentAnalysisService.countParagraphs($);
      const topKeywords = this.contentAnalysisService.extractTopKeywords(textContent);
      const htmlContent = $.html();
      const thinContentAnalysis = this.contentAnalysisService.analyzeThinContent(htmlContent);
      const readabilityAnalysis = this.contentAnalysisService.calculateReadabilityScore(textContent);
      const imageAnalysisResults = await this.imageAnalysisService.analyzeImages($, url, siteKeywords);
      
      // Aggregate image analysis results
      const totalImages = imageAnalysisResults.length;
      const brokenImages = imageAnalysisResults.filter(img => img.isBroken).length;
      const imagesWithoutAlt = imageAnalysisResults.filter(img => !img.altText.present).length;
      const imagesWithoutTitle = imageAnalysisResults.filter(img => !img.titleAttribute.present).length;
      const oversizedImages = imageAnalysisResults.filter(img => img.fileSize > crawlConfig.maxImageSizeBytes).length;
      const imagesWithTextContent = imageAnalysisResults.filter(img => img.textInImage?.hasText).length;
      const imageAnalysisScore = this.seoAnalyzer.calculateImageSEOScore(imageAnalysisResults);
      const imageFormatDistribution = imageAnalysisResults.reduce((acc, img) => {
        acc[img.fileFormat] = (acc[img.fileFormat] || 0) + 1;
        return acc;
      }, {});

      const uniqueImageUrls = [...new Set(imageAnalysisResults.map(img => img.url))];

      const nonRenderedHtml = $.html();
      const renderedHtml = await this.javascriptRenderingService.renderPage(url);

      // Add JavaScript rendering
      await this.javascriptRenderingService.init();
      const renderedContent = await this.javascriptRenderingService.renderPage(url);
      const jsRenderingAnalysis = this.javaRenderingScriptAnalysisService.analyzeRenderedVsNonRendered(nonRenderedHtml, renderedHtml);

      const pageData = await this.contentExtractor.extractPageData($, url, loadTime);
      pageData.headingAnalysis = headingAnalysis;
      const seoScores = await this.seoAnalyzer.calculateSEOScores($, pageData);
      const newUrls = await this.urlExtractor.extractLinks($, url, depth, crawlConfig);

      const structuredDataAnalysis = await this.structuredDataAnalysisService.analyzeStructuredData($, url);


      return { 
        pageData: {
          ...pageData,
          crawlingId,
          seoScores: {
            ...seoScores,
            titleTag: titleTagScore,
            securityHeader: securityHeaderScore,
            metaDescription: metaDescriptionScore,
            metaRobotsTag: metaRobotsTagScore,
            heading: headingAnalysisScore,
            relLink: relLinkScore,
            openGraph: openGraphScore,
            twitterCard: twitterCardScore,
            viewport: viewportScore,
            wordCountScore,
            imageAnalysisScore,
            technical: technicalSeoAnalysis.performanceMetrics.performanceScore,
            compression: technicalSeoAnalysis.compressionAnalysis.compressionScore,
            http2: technicalSeoAnalysis.http2Analysis.http2Score,
            pageSize: technicalSeoAnalysis.pageSizeAnalysis.pageSizeScore,
            structuredData: this.seoAnalyzer.calculateStructuredDataScore(structuredDataAnalysis)
          },
          depth,
          statusCode,
          isBroken: false,
          urlAnalysis,
          urlParameterAnalysis,
          urlLengthAnalysis,
          httpStatusCodeAnalysis,
          contentTypeAnalysis,
          mimeTypeAnalysis,
          xRobotsTagAnalysis,
          securityHeaderAnalysis,
          metaDescriptionAnalysis,
          headingAnalysis,
          metaKeywordsAnalysis,
          metaRobotsTagAnalysis,
          canonicalTagAnalysis,
          relLinkAnalysis,
          openGraphAnalysis,
          twitterCardAnalysis,
          viewportAnalysis,
          wordCount,
          detectedLanguage,
          keywordDensity,
          keywordUsage,
          contentToHtmlRatio,
          contentHash,
          characterCount,
          sentenceCount,
          paragraphCount,
          topKeywords,
          thinContentAnalysis,
          readabilityAnalysis,
          imageAnalysis: imageAnalysisResults,
          totalImages,
          brokenImages,
          imagesWithoutAlt,
          imagesWithoutTitle,
          oversizedImages,
          imagesWithTextContent,
          imageFormatDistribution,
          uniqueImageUrls,
          jsRenderingAnalysis,
          renderedContent,
          technicalSeoAnalysis,
          structuredDataAnalysis
        },
        newUrls 
      };

    } catch (error) {
      if (error instanceof RateLimitExceededException) {
        this.logger.warn(`Rate limit exceeded for URL: ${url}. Skipping.`);
      } else if (error instanceof CrawlerNetworkException) {
        this.logger.error(`Network error crawling ${url}: ${error.message}`);
      } else if (error instanceof CrawlerParsingException) {
        this.logger.error(`Parsing error crawling ${url}: ${error.message}`);
      } else {
        this.logger.error(`Unexpected error crawling ${url}: ${error.message}`);
      }

      return { 
        crawlingId,
        pageUrlRelative: url,
        isBroken: true,
        error: error.message,
        depth,
        newUrls: []
      };
    }
  }

  private async fetchPageWithStatus(url: string): Promise<{ $: cheerio.CheerioAPI; loadTime: number; statusCode: number; contentTypeAnalysis: any; mimeTypeAnalysis: any, xRobotsTagAnalysis: any;headers: Record<string, string>;technicalSeoAnalysis: any }> {
    const startTime = Date.now();
    try {
      const response = await this.asyncHttpService.get(url);
      const loadTime = Date.now() - startTime;
      const $ = cheerio.load(response.data);
      return { 
        $, 
        loadTime, 
        statusCode: response.status,
        contentTypeAnalysis: response.contentTypeAnalysis,
        mimeTypeAnalysis: response.mimeTypeAnalysis,
        xRobotsTagAnalysis: response.xRobotsTagAnalysis,
        headers: response.headers as Record<string, string>,
        technicalSeoAnalysis : response.technicalSeoAnalysis
      };
    } catch (error) {
      if (error instanceof CrawlerNetworkException) {
        throw error;
      }
      const loadTime = Date.now() - startTime;
      return { 
        $: cheerio.load(''), 
        loadTime, 
        statusCode: error.response?.status || 0,
        contentTypeAnalysis: null,
        mimeTypeAnalysis: null,
        xRobotsTagAnalysis : null,
        headers: null,
        technicalSeoAnalysis : null
      };
    }
  }

  async crawlDirectoryTree(crawlingId: string, rootPath: string, crawlConfig: any): Promise<any> {
    const directoryTree = await this.directoryTreeCrawlerService.crawlDirectoryTree(rootPath);
    const analysis = await this.directoryTreeAnalyzer.analyzeDirectoryTree(directoryTree);
    await this.crawlingDataRepository.bulkUpdateCrawlingData([{
      crawlingId,
      directoryTree,
      directoryTreeAnalysis: analysis,
    }]);
    return { directoryTree, analysis };
  }
}
 
                                                                                    C:\Workspace\Web\Ai Business grow project\Back_end\src\crawler\services\crawler-worker.thread.ts 
import { parentPort, workerData } from 'worker_threads';
import { CrawlerWorker } from './crawler-worker.service';
import { CrawlingDataRepository } from '../repository/crawling-data.repository';
import { CrawlerConfigService } from '../config/crawler-config.service';
import { RobotsTxtService } from './robot/robots-txt.service';
import { InclusionExclusionService } from '../config/inclusion-exclusion.service';
import { DirectoryTreeAnalyzer } from './analysis/directory-tree-analyzer';
import { DirectoryTreeCrawlerService } from './directory-tree/directory-tree-crawler.service';
import { AsyncHttpService } from './async-http.service';
import { ConfigModule, ConfigService } from '@nestjs/config';
import { CrawlingData, CrawlingDataSchema } from '../schemas/crawling-data.schema';
import { Model, Connection, createConnection } from 'mongoose';
import { HttpService } from '@nestjs/axios';
import { RateLimiterService } from './rate-limiter.service'; 
import { Cache, Store  } from 'cache-manager';
import { EventEmitter } from 'stream';
import { UrlAnalyzerService } from './analysis/url-analyzer.service';
import { HttpHeaderService } from './analysis/http-header.service';
import { ContentTypeAnalyzerService } from './analysis/content-type-analyzer.service';
import { OnPageElementService } from './analysis/on-page-element.service';
import { CrawlingSessionService } from './crawling-session.service';
import {CrawlingSession, CrawlingSessionSchema } from '../schemas/crawling-session.schema';
import { ContentAnalysisService } from './analysis/content-analysis.service';
import { ImageAnalysisService } from './analysis/image-analysis.service';
import { JavaRenderingScriptAnalysisService } from './analysis/java-rendering-script-analysis.service';
import { JavaScriptRenderingService } from './javascript-rendering.service';
import { TechnicalSeoAnalysisService } from './analysis/technical-seo-analysis.service';
import { TechnicalMobileAnalysisService } from './analysis/technical-mobile-analysis.service';
import { AmpAnalysisService } from './analysis/amp-analysis.service';
import { ResourceUsageAnalysisService } from './analysis/resource-usage-analysis.service';
import { CookieAnalysisService } from './analysis/cookie-analysis.service';
import { StructuredDataAnalysisService } from './analysis/structured-data-analysis.service';


// Initialize ConfigModule
ConfigModule.forRoot({
  isGlobal: true,
  envFilePath: '.env',
});

const mockStore: Store = {
  get: async () => undefined,
  set: async () => undefined,
  del: async () => undefined,
  keys: async () => [],
  ttl: async () => 0,
  reset: async () => undefined,
  mset: async () => undefined,
  mget: async () => [],
  mdel: async () => undefined,
};

const mockCacheManager: Cache = {
  get: async () => undefined,
  set: async () => undefined,
  del: async () => undefined,
  reset: async () => undefined,
  wrap: async () => undefined,
  store: mockStore,
  on: (event: string | symbol, listener: (...args: any[]) => void) => new EventEmitter().on(event, listener),
  removeListener: (event: string | symbol, listener: (...args: any[]) => void) => new EventEmitter().removeListener(event, listener),
}

const configService = new ConfigService();
const connection: Connection = createConnection(configService.get<string>('MONGO_URI'));


// Create Mongoose model
const crawlingDataModel: Model<CrawlingData> = connection.model<CrawlingData>('CrawlingData', CrawlingDataSchema);
const crawlingDataModelSession: Model<CrawlingSession> = connection.model<CrawlingSession>('CrawlingSession', CrawlingSessionSchema);


// Create instances of required services
const crawlingDataRepository = new CrawlingDataRepository(crawlingDataModel, mockCacheManager);

const crawlerConfigService = new CrawlerConfigService(configService, new InclusionExclusionService());
const robotsTxtService = new RobotsTxtService(configService);
const inclusionExclusionService = new InclusionExclusionService();
const directoryTreeAnalyzer = new DirectoryTreeAnalyzer();
const directoryTreeCrawlerService = new DirectoryTreeCrawlerService(crawlerConfigService);
const httpService = new HttpService();
const rateLimiterService = new RateLimiterService(configService);
const contentTypeAnalyzerService = new ContentTypeAnalyzerService(crawlerConfigService);
const httpHeaderService = new HttpHeaderService(crawlerConfigService);


const mobileAnalysisService = new TechnicalMobileAnalysisService(crawlerConfigService);
const ampAnalysisService = new AmpAnalysisService(crawlerConfigService);
const resourceUsageAnalysisService = new ResourceUsageAnalysisService(crawlerConfigService);
const cookieAnalysisService = new CookieAnalysisService(crawlerConfigService);

const  technicalSeoAnalysisService = new TechnicalSeoAnalysisService(crawlerConfigService, mobileAnalysisService, ampAnalysisService, resourceUsageAnalysisService, cookieAnalysisService);
const asyncHttpService = new AsyncHttpService(configService, httpService, rateLimiterService, httpHeaderService, contentTypeAnalyzerService, technicalSeoAnalysisService);
const urlAnalyzerService = new UrlAnalyzerService(crawlerConfigService);
const onPageElementService = new OnPageElementService(crawlerConfigService);
const crawlingSessionService = new CrawlingSessionService(crawlingDataModelSession);
const contentAnalysisService = new ContentAnalysisService(crawlerConfigService);
const imageAnalysisService = new ImageAnalysisService(crawlerConfigService,asyncHttpService);
const javaRenderingScriptAnalysisService = new JavaRenderingScriptAnalysisService(crawlerConfigService);
const javascriptRenderingService = new JavaScriptRenderingService(crawlerConfigService);
const structuredDataAnalysisService = new  StructuredDataAnalysisService(crawlerConfigService);
// Initialize CrawlerWorker with injected dependencies
const crawlerWorker = new CrawlerWorker(
  crawlingDataRepository,
  crawlerConfigService,
  robotsTxtService,
  inclusionExclusionService,
  directoryTreeAnalyzer,
  directoryTreeCrawlerService,
  asyncHttpService,
  urlAnalyzerService,
  httpHeaderService,
  contentTypeAnalyzerService,
  onPageElementService,
  crawlingSessionService,
  contentAnalysisService,
  imageAnalysisService,
  javaRenderingScriptAnalysisService,
  javascriptRenderingService,
  structuredDataAnalysisService

);

if (parentPort) {
  parentPort.on('message', async (message) => {
    try {
      let result;
      switch (message.type) {
        case 'crawlAndExtract':
          result = await crawlerWorker.crawlAndExtract(message.crawlingId, message.url, message.depth, message.crawlConfig);
          break;
        case 'directoryTree':
          result = await crawlerWorker.crawlDirectoryTree(message.crawlingId, message.rootPath, message.crawlConfig);
          break;
        default:
          throw new Error(`Unknown task type: ${message.type}`);
      }
      parentPort.postMessage(result);
    } catch (error) {
      parentPort.postMessage({ error: error.message });
    }
  });
} 
                                                                                    C:\Workspace\Web\Ai Business grow project\Back_end\src\crawler\services\crawler.service.ts 
import { Injectable, Logger } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { CrawlingSession } from '../schemas/crawling-session.schema';
import { SitemapService } from '../../seo/sitemap/sitemap.service';
import { EventEmitter2 } from '@nestjs/event-emitter';
import { CrawlingDataRepository } from '../repository/crawling-data.repository';
import { CrawlerConfigService } from '../config/crawler-config.service';
import { SitemapCrawlerService } from './sitemap/sitemap-crawler.service';
import { Worker } from 'worker_threads';
import * as path from 'path';
import { AsyncHttpService } from './async-http.service';
import { CrawlerWorker } from './crawler-worker.service';
import { ProgressService } from './progress.service';
import * as pLimit from 'p-limit';
import { RateLimiterService } from './rate-limiter.service';
import { PerformanceMonitorService } from './performance-monitor.service';
import { SiteKeywordAnalyzerService } from './analysis/site-keyword-analyzer.service';
import { CrawlingSessionService } from  './crawling-session.service';
import { OnPageElementService } from './analysis/on-page-element.service';
import * as sjs from 'simhash-js';

interface CrawlOptions {
  urlLimit?: number;
  depthLimit?: number;
  followInternalLinks?: boolean;
  followExternalLinks?: boolean;
  followSubfolderLinks?: boolean;
  specificUrlList?: string[];
  useDirectoryTreeCrawling?: boolean;
  directoryTreeRootPath?: string;
  customStartingPoints?: string[];
  sitemapEnabled?: boolean;
}

@Injectable()
export class CrawlerService {
  private readonly logger = new Logger(CrawlerService.name);
  private workers: Worker[] = [];
  private activeWorkers: number = 0;
  private processedUrls: number = 0;
  private batchSize: number;
  private dataQueue: any[] = [];
  private crawlingSessionServiceId: string;
  private accumulatedKeywords: Set<string> = new Set();
  private canonicalData: { url: string; canonicalHref: string }[] = [];
  private simhashComparator: any;

  constructor(
    @InjectModel(CrawlingSession.name) private crawlingSessionModel: Model<CrawlingSession>,
    private readonly sitemapService: SitemapService,
    private eventEmitter: EventEmitter2,
    private crawlingDataRepository: CrawlingDataRepository,
    private crawlerConfigService: CrawlerConfigService,
    private sitemapCrawlerService: SitemapCrawlerService,
    private asyncHttpService: AsyncHttpService,
    private crawlerWorker: CrawlerWorker,
    private progressService: ProgressService,
    private rateLimiterService: RateLimiterService,
    private performanceMonitorService: PerformanceMonitorService,
    private siteKeywordAnalyzerService: SiteKeywordAnalyzerService,
    private crawlingSessionService: CrawlingSessionService,
    private onPageElementService: OnPageElementService,
  ) {
    this.initializeWorkers();
    this.batchSize = this.crawlerConfigService.getCrawlerConfig().batchUpdateSize || 100;
    this.simhashComparator = sjs.Comparator;
  }

  private initializeWorkers() {
    const { maxThreads } = this.crawlerConfigService.getMultithreadingConfig();
    for (let i = 0; i < maxThreads; i++) {
      const worker = new Worker(path.resolve(__dirname, 'crawler-worker.thread.js'), {
        workerData: { workerId: i }
      });
      this.workers.push(worker);
    }
  }

  async crawlWebsite(url: string, options: CrawlOptions = {}): Promise<any> {
    const domain = new URL(url).hostname;
    const crawlingSession = await this.initiateCrawlingSession(domain);
    this.crawlingSessionServiceId = crawlingSession.crawlingId;
    this.accumulatedKeywords = new Set();

    const config = this.crawlerConfigService.getCrawlerConfig();
    const asyncConfig = this.crawlerConfigService.getAsyncOperationsConfig();
    const finalUrlLimit = options.urlLimit || config.defaultUrlLimit;
    const finalDepthLimit = options.depthLimit || config.defaultDepthLimit;
    
    this.crawlerConfigService.validateCrawlLimits(finalUrlLimit, finalDepthLimit);

    const crawlConfig = {
      ...config,
      ...options,
      urlLimit: finalUrlLimit,
      depthLimit: finalDepthLimit,
    };

    let result;
    if (options.useDirectoryTreeCrawling && options.directoryTreeRootPath) {
      result = await this.crawlDirectoryTree(crawlingSession.crawlingId, options.directoryTreeRootPath, crawlConfig);
    } else if (options.specificUrlList && options.specificUrlList.length > 0) {
      result = await this.crawlSpecificUrlList(crawlingSession.crawlingId, options.specificUrlList, crawlConfig);
    } else {
      result = await this.performRegularCrawl(crawlingSession.crawlingId, url, crawlConfig, asyncConfig);
    }

    // Process any remaining data in the queue
    while (this.dataQueue.length > 0) {
      await this.processBatch();
    }

    const averageScores = await this.crawlingDataRepository.calculateAverageScores(crawlingSession.crawlingId);
    this.eventEmitter.emit('crawling.completed', { crawlingId: crawlingSession.crawlingId, averageScores });

    this.performanceMonitorService.logPerformanceMetrics();

    const canonicalConsistencyAnalysis = this.onPageElementService.analyzeCanonicalConsistency(this.canonicalData);
    this.canonicalData = [];
    await this.crawlingSessionService.updateCanonicalConsistencyAnalysis(crawlingSession.crawlingId, canonicalConsistencyAnalysis);
    await this.performContentComparison(crawlingSession.crawlingId);
    return { ...result, averageScores,canonicalConsistencyAnalysis };
  }

  private async performContentComparison(crawlingId: string): Promise<void> {
    const allPages = await this.crawlingDataRepository.getCrawlingDataById(crawlingId);
    const duplicates: Map<string, string[]> = new Map();
    const nearDuplicates: Map<string, string[]> = new Map();

    for (let i = 0; i < allPages.length; i++) {
      const page = allPages[i];
      for (let j = i + 1; j < allPages.length; j++) {
        const comparePage = allPages[j];
        const similarity = this.simhashComparator.similarity(page.contentHash, comparePage.contentHash);
        if (similarity === 1) {
          this.addToDuplicateMap(duplicates, page.pageUrlRelative, comparePage.pageUrlRelative);
          this.addToDuplicateMap(duplicates, comparePage.pageUrlRelative, page.pageUrlRelative);
        } else if (similarity >= 0.9) { // Adjust this threshold as needed
          this.addToDuplicateMap(nearDuplicates, page.pageUrlRelative, comparePage.pageUrlRelative);
          this.addToDuplicateMap(nearDuplicates, comparePage.pageUrlRelative, page.pageUrlRelative);
        }
      }
    }

    await this.crawlingSessionService.updateDuplicateContent(crawlingId, duplicates, nearDuplicates);
  }

  private addToDuplicateMap(map: Map<string, string[]>, key: string, value: string): void {
    if (!map.has(key)) {
      map.set(key, []);
    }
    map.get(key).push(value);
  }

  private async performRegularCrawl(crawlingId: string, url: string, crawlConfig: any, asyncConfig: any): Promise<any> {
    let urlsToVisit: { url: string; priority: number }[] = [];

    if (crawlConfig.sitemapEnabled !== false) {
      const sitemaps = await this.sitemapCrawlerService.discoverSitemaps(url);
      const sitemapUrlPromises = sitemaps.map(sitemap => this.sitemapCrawlerService.fetchSitemap(sitemap));
      const sitemapUrls = await Promise.all(sitemapUrlPromises);
      urlsToVisit = sitemapUrls.flat().map(url => ({ url, priority: 1 }));
    }

    if (!urlsToVisit.some(item => item.url === url)) {
      urlsToVisit.unshift({ url, priority: 1 });
    }

    return this.distributeCrawlTasks(crawlingId, urlsToVisit, crawlConfig, asyncConfig);
  }

  private async distributeCrawlTasks(crawlingId: string, urlsToVisit: { url: string; priority: number }[], crawlConfig: any, asyncConfig: any): Promise<any> {
    const { concurrencyLimit, asyncBatchSize } = asyncConfig;
    const limit = pLimit(parseInt(concurrencyLimit));
    const taskQueue = urlsToVisit.slice(0, crawlConfig.urlLimit);
    const processedUrls = new Set<string>();
    let processedCount = 0;
  
    const config = this.crawlerConfigService.getCrawlerConfig();
    let batchCount = 0;
  
    while (taskQueue.length > 0 && processedCount < crawlConfig.urlLimit) {
      const batch = taskQueue.splice(0, asyncBatchSize).filter(({ url }) => !processedUrls.has(url));
      
      const tasks = batch.map(({ url }) => {
        processedUrls.add(url);
        return limit(async () => {
          const startTime = Date.now();
          const result = await this.crawlAndExtractWithWorker(crawlingId, url, 0, crawlConfig);
          const endTime = Date.now();
          this.performanceMonitorService.recordResponseTime(endTime - startTime);
          this.performanceMonitorService.incrementMetric('totalRequests');
          if (result.error) {
            this.performanceMonitorService.incrementMetric('failedRequests');
          } else {
            this.performanceMonitorService.incrementMetric('successfulRequests');
          }
          return result;
        });
      });
      const results = await Promise.all(tasks);
  
      processedCount += batch.length;
      const siteKeywords = await this.siteKeywordAnalyzerService.analyzeSiteKeywords(results);
      siteKeywords.forEach(keyword => this.accumulatedKeywords.add(keyword));
      await this.crawlingSessionService.updateExtractedKeywords(this.crawlingSessionServiceId, Array.from(this.accumulatedKeywords));
      for (const result of results) {
        if (result.pageData) {
          await this.queueData(result.pageData);
        }
        // Handle newUrls if needed
      }

      const newUrls = results.filter(Boolean).flatMap(result => result?.newUrls || []);
      const processedBatchUrls = results.filter(result => result?.pageData?.pageUrlRelative).map(result => result.pageData.pageUrlRelative);
      const percentage = this.progressService.updateProgress(crawlingId, newUrls, this.processedUrls);
      batchCount++;
  
      if (batchCount >= config.batchUpdateSize) {
        const lastProcessedUrl = processedBatchUrls[processedBatchUrls.length - 1] || 'Unknown';
        this.emitProgress(crawlingId, percentage, lastProcessedUrl);
        batchCount = 0;
      }
  
      if (processedCount < crawlConfig.urlLimit) {
        const uniqueNewUrls = newUrls.filter(url => !processedUrls.has(url));
        taskQueue.push(...uniqueNewUrls.map(url => ({ url, priority: 0 })));
      }

      this.performanceMonitorService.updatePeakMemoryUsage();
    }
  
    const finalPercentage = this.progressService.updateProgress(crawlingId, [], this.processedUrls);
    this.emitProgress(crawlingId, finalPercentage, 'Completed');
  
    return { crawlingId };
  }

  getAccumulatedKeywords(): string[] {
    return Array.from(this.accumulatedKeywords);
  }

  private async crawlAndExtractWithWorker(crawlingId: string, url: string, depth: number, crawlConfig: any): Promise<any> {
    const worker = this.getAvailableWorker();
    this.activeWorkers++;
   
    return new Promise((resolve, reject) => {
      worker.postMessage({ type: 'crawlAndExtract', crawlingId, url, depth, crawlConfig });
      worker.once('message', (result) => {
        this.activeWorkers--;
        if (result.error) {
          this.performanceMonitorService.incrementMetric('failedRequests');
          console.error('Error in worker:', result.error);
        } else {
          this.performanceMonitorService.incrementMetric('successfulRequests');
          if (result.pageData && result.pageData.canonicalTagAnalysis) {
            this.canonicalData.push({
                url: result.pageData.pageUrlRelative,
                canonicalHref: result.pageData.canonicalTagAnalysis.href
            });
          }
          resolve(result);
          this.processedUrls++;
        }
        resolve(result);
      });
    });
  }

  private getAvailableWorker(): Worker {
    const worker = this.workers.shift();
    this.workers.push(worker);
    return worker;
  }

  private emitProgress(crawlingId: string, percentage: number, currentUrl: string) {
    this.eventEmitter.emit('crawling.progress', { crawlingId, percentage, currentUrl });
  }

  private async initiateCrawlingSession(domain: string): Promise<CrawlingSession> {
    let session = await this.crawlingSessionModel.findOne({ websiteDomain: domain }).exec();
    if (!session) {
      session = new this.crawlingSessionModel({
        crawlingId: this.generateCrawlingId(domain),
        websiteDomain: domain,
      });
      await session.save();
    }
    return session;
  }

  private generateCrawlingId(domain: string): string {
    return `crawl_${domain.replace(/[^a-zA-Z0-9]/g, '_')}`;
  }

  private async crawlDirectoryTree(crawlingId: string, rootPath: string, crawlConfig: any): Promise<any> {
    const worker = this.getAvailableWorker();
    this.activeWorkers++;

    return new Promise((resolve, reject) => {
      worker.postMessage({ type: 'directoryTree', crawlingId, rootPath, crawlConfig });
      worker.once('message', (result) => {
        this.activeWorkers--;

        if (result.error) {
          this.performanceMonitorService.incrementMetric('failedRequests');
          reject(new Error(result.error));
        } else {
          this.performanceMonitorService.incrementMetric('successfulRequests');
          resolve(result);
        }
      });
    });
  }

  private async crawlSpecificUrlList(crawlingId: string, urlList: string[], crawlConfig: any): Promise<any> {
    const urlsToVisit = urlList.map(url => ({ url, priority: 1 }));
    return this.distributeCrawlTasks(crawlingId, urlsToVisit, crawlConfig, this.crawlerConfigService.getAsyncOperationsConfig());
  }

  private async queueData(data: any): Promise<void> {
    this.dataQueue.push(data);
    if (this.dataQueue.length >= this.batchSize) {
      await this.processBatch();
    }
  }

  private async processBatch(): Promise<void> {
    if (this.dataQueue.length === 0) return;

    const batch = this.dataQueue.splice(0, this.batchSize);
    try {
      await this.crawlingDataRepository.bulkUpdateCrawlingData(batch);
    } catch (error) {
      this.logger.error(`Error processing batch: ${error.message}`);
    }
  }
}
 
                                                                                    C:\Workspace\Web\Ai Business grow project\Back_end\src\crawler\services\crawling-session.service.ts 
import { Injectable } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { CrawlingSession } from '../schemas/crawling-session.schema';

@Injectable()
export class CrawlingSessionService {
  constructor(
    @InjectModel(CrawlingSession.name) private crawlingSessionModel: Model<CrawlingSession>
  ) {}


  async updateExtractedKeywords(crawlingId: string, keywords: string[]): Promise<void> {
    await this.crawlingSessionModel.findOneAndUpdate(
      { crawlingId },
      { $set: { extractedKeywords: keywords } },
      { new: true }
    );
  }

  async getExtractedKeywords(crawlingId: string): Promise<string[]> {
    const session = await this.crawlingSessionModel.findOne({ crawlingId }).exec();
    return session?.extractedKeywords || [];
  }

  async updateCanonicalConsistencyAnalysis(crawlingId: string, analysis: any): Promise<void> {
    await this.crawlingSessionModel.findOneAndUpdate(
      { crawlingId },
      { $set: { canonicalConsistencyAnalysis: analysis } },
      { new: true }
    );
  }

  async updateDuplicateContent(
    crawlingId: string, 
    duplicates: Map<string, string[]>, 
    nearDuplicates: Map<string, string[]>
  ): Promise<void> {
    console.log('updateDuplicateContent called with crawlingId:', crawlingId);
    const duplicateEntries = Array.from(duplicates.entries()).map(([url, duplicateUrls]) => ({
      url,
      duplicateUrls
    }));

    const nearDuplicateEntries = Array.from(nearDuplicates.entries()).map(([url, nearDuplicateUrls]) => ({
      url,
      nearDuplicateUrls
    }));

    await this.crawlingSessionModel.findOneAndUpdate(
      { crawlingId },
      {
        $set: {
          duplicateContent: duplicateEntries,
          nearDuplicateContent: nearDuplicateEntries
        }
      },
      { new: true }
    );
  }
}
 
                                                                                    C:\Workspace\Web\Ai Business grow project\Back_end\src\crawler\services\javascript-rendering.service.ts 
import { Injectable, Logger } from '@nestjs/common';
import { CrawlerConfigService } from '../config/crawler-config.service';
import * as puppeteer from 'puppeteer';

@Injectable()
export class JavaScriptRenderingService {
  private readonly logger = new Logger(JavaScriptRenderingService.name);
  private browser: puppeteer.Browser;

  constructor(private readonly crawlerConfigService: CrawlerConfigService) {}

  async init() {
    if(!!this.crawlerConfigService.getJavaScriptRenderingConfig().enabled) return
    try {
        this.browser = await puppeteer.launch({ headless: true });
        this.logger.log('Browser initialized successfully');
      } catch (error) {
        this.logger.error(`Failed to initialize browser: ${error.message}`);
        throw error;
      }
  }

  async close() {
    if (this.browser) {
      await this.browser.close();
    }
  }

  async renderPage(url: string): Promise<string> {

    const config = this.crawlerConfigService.getJavaScriptRenderingConfig();

    if(!!config.enabled){
      return null;
    }

    const page = await this.browser.newPage();

    try {
      await page.setUserAgent(config.userAgent);
      console.log({
        width: Math.floor(config.viewport.width),
        height: Math.floor(config.viewport.height),
        deviceScaleFactor: parseInt(config.viewport.deviceScaleFactor),
      });
      await page.setViewport({
        width: Math.floor(config.viewport.width),
        height: Math.floor(config.viewport.height),
        deviceScaleFactor: parseInt(config.viewport.deviceScaleFactor),
      });

      await page.goto(url, {
        waitUntil: config.waitUntil as puppeteer.WaitForOptions['waitUntil'],
        timeout: config.timeout,
      });

      // Wait for any remaining network connections to finish
      await page.waitForNetworkIdle({ timeout: config.timeout });

      // Execute any additional JavaScript if needed
      // await page.evaluate(() => { ... });

      const content = await page.content();
      return content;
    } catch (error) {
      this.logger.error(`Error rendering page ${url}: ${error.message}`);
      throw error;
    } finally {
      await page.close();
    }
  }

  async extractAjaxedContent(url: string): Promise<any> {
    const page = await this.browser.newPage();
    try {
      await page.goto(url, { waitUntil: 'networkidle0' });
      
      // Example: Extract content from a specific element that's loaded via AJAX
      const ajaxedContent = await page.evaluate(() => {
        const element = document.querySelector('#ajax-loaded-content');
        return element ? element.textContent : null;
      });

      return ajaxedContent;
    } finally {
      await page.close();
    }
  }

  async crawlSPA(url: string): Promise<any> {
    const page = await this.browser.newPage();
    try {
      await page.goto(url, { waitUntil: 'networkidle0' });

      // Example: Extract all links from the SPA
      const links = await page.evaluate(() => {
        return Array.from(document.querySelectorAll('a')).map(a => a.href);
      });

      // Example: Navigate through the SPA and extract content
      const content = [];
      for (const link of links) {
        await page.goto(link, { waitUntil: 'networkidle0' });
        const pageContent = await page.evaluate(() => document.body.innerText);
        content.push({ url: link, content: pageContent });
      }

      return content;
    } finally {
      await page.close();
    }
  }
}
 
                                                                                    C:\Workspace\Web\Ai Business grow project\Back_end\src\crawler\services\performance-monitor.service.ts 
import { Injectable, Logger } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { EventEmitter2 } from '@nestjs/event-emitter';

@Injectable()
export class PerformanceMonitorService {
  private readonly logger = new Logger(PerformanceMonitorService.name);
  private metrics: Map<string, number> = new Map();
  private startTime: number;

  constructor(
    private configService: ConfigService,
    private eventEmitter: EventEmitter2
  ) {
    this.startTime = Date.now();
    this.initializeMetrics();
  }

  private initializeMetrics(): void {
    this.metrics.set('totalRequests', 0);
    this.metrics.set('successfulRequests', 0);
    this.metrics.set('failedRequests', 0);
    this.metrics.set('rateLimitHits', 0);
    this.metrics.set('averageResponseTime', 0);
    this.metrics.set('peakMemoryUsage', 0);
  }

  incrementMetric(metric: string, value: number = 1): void {
    const currentValue = this.metrics.get(metric) || 0;
    this.metrics.set(metric, currentValue + value);
  }

  setMetric(metric: string, value: number): void {
    this.metrics.set(metric, value);
  }

  getMetric(metric: string): number {
    return this.metrics.get(metric) || 0;
  }

  recordResponseTime(time: number): void {
    const totalRequests = this.getMetric('totalRequests');
    const currentAverage = this.getMetric('averageResponseTime');
    const newAverage = (currentAverage * totalRequests + time) / (totalRequests + 1);
    this.setMetric('averageResponseTime', newAverage);
  }

  updatePeakMemoryUsage(): void {
    const memoryUsage = process.memoryUsage().heapUsed / 1024 / 1024; // Convert to MB
    const currentPeak = this.getMetric('peakMemoryUsage');
    if (memoryUsage > currentPeak) {
      this.setMetric('peakMemoryUsage', memoryUsage);
    }
  }

  logPerformanceMetrics(): void {
    const duration = (Date.now() - this.startTime) / 1000; // Convert to seconds
    const metrics = Object.fromEntries(this.metrics);
    
    this.logger.log(`Performance Metrics:
      Duration: ${duration.toFixed(2)} seconds
      Total Requests: ${metrics.totalRequests}
      Successful Requests: ${metrics.successfulRequests}
      Failed Requests: ${metrics.failedRequests}
      Rate Limit Hits: ${metrics.rateLimitHits}
      Average Response Time: ${metrics.averageResponseTime.toFixed(2)} ms
      Peak Memory Usage: ${metrics.peakMemoryUsage.toFixed(2)} MB
    `);

    this.eventEmitter.emit('crawler.performanceMetrics', {
      duration,
      ...metrics
    });
  }
}
 
                                                                                    C:\Workspace\Web\Ai Business grow project\Back_end\src\crawler\services\progress.service.ts 
import { Injectable, Logger } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { CrawlerConfigService } from '../config/crawler-config.service';

@Injectable()
export class ProgressService {
  private readonly logger = new Logger(ProgressService.name);
  private uniqueUrls: Set<string> = new Set();
  private estimatedTotalUrls: number = 0;
  private processedUrls: number = 0;
  private weightedProgress: number = 0;

  constructor(
    private configService: CrawlerConfigService,
  ) {}

  reset() {
    this.uniqueUrls.clear();
    this.estimatedTotalUrls = 0;
    this.processedUrls = 0;
    this.weightedProgress = 0;
  }

  updateProgress(crawlingId: string, newUrls: string[], processedUrlsLength: number) {
    this.processedUrls = processedUrlsLength;
    this.logger.debug(`Updating progress for crawling session ${crawlingId} , ${newUrls.length} new urls, ${processedUrlsLength} processed urls`);
    newUrls.forEach(url => this.uniqueUrls.add(url));
    this.estimatedTotalUrls = this.uniqueUrls.size;
    this.logger.debug(`estimatedTotalUrls ${this.estimatedTotalUrls}`)

    const percentage = this.calculatePercentage();
     this.logger.debug(`Updated progress for crawling session ${crawlingId} to ${percentage}%`);
    return percentage;
  }

  private calculatePercentage(): number {
    const percentage = (this.processedUrls / this.estimatedTotalUrls) * 100;
    return percentage;
  }

} 
                                                                                    C:\Workspace\Web\Ai Business grow project\Back_end\src\crawler\services\rate-limiter.service.ts 
import { Injectable, Logger } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { RateLimitExceededException } from '../exceptions/crawler.exceptions';

@Injectable()
export class RateLimiterService {
  private readonly logger = new Logger(RateLimiterService.name);
  private tokens: number;
  private lastRefillTimestamp: number;
  private readonly bucketCapacity: number;
  private readonly refillRate: number;

  constructor(private configService: ConfigService) {
    this.bucketCapacity = this.configService.get<number>('RATE_LIMITER_BUCKET_CAPACITY', 60);
    this.refillRate = this.configService.get<number>('RATE_LIMITER_REFILL_RATE', 1); // tokens per second
    this.tokens = this.bucketCapacity;
    this.lastRefillTimestamp = Date.now();
  }

  async acquire(): Promise<boolean> {
    this.refillTokens();

    if (this.tokens > 0) {
      this.tokens--;
      this.logger.debug(`Token acquired. Remaining tokens: ${this.tokens}`);
      return true;
    }

    this.logger.warn('Rate limit exceeded. Waiting for token refill.');
    throw new RateLimitExceededException('Rate limit exceeded');
  }

  private refillTokens(): void {
    const now = Date.now();
    const timePassed = (now - this.lastRefillTimestamp) / 1000; // Convert to seconds
    const tokensToAdd = Math.floor(timePassed * this.refillRate);

    if (tokensToAdd > 0) {
      this.tokens = Math.min(this.bucketCapacity, this.tokens + tokensToAdd);
      this.lastRefillTimestamp = now;
      this.logger.debug(`Refilled ${tokensToAdd} tokens. Current tokens: ${this.tokens}`);
    }
  }
} 
                                                                                    C:\Workspace\Web\Ai Business grow project\Back_end\src\crawler\services\url-analysis.service.ts 
 
                                                                                        C:\Workspace\Web\Ai Business grow project\Back_end\src\crawler\services\analysis\amp-analysis.service.ts 
import { Injectable } from '@nestjs/common';
import { CrawlerConfigService } from '../../config/crawler-config.service';
import { JSDOM } from 'jsdom';
import { AmpAnalysis } from '../../interfaces/technical-seo.interface';
import * as amphtmlValidator from 'amphtml-validator';

@Injectable()
export class AmpAnalysisService {
  constructor(private readonly crawlerConfigService: CrawlerConfigService) {}

  async analyzeAmp(html: string, url: string): Promise<AmpAnalysis> {
    const config = this.crawlerConfigService.getTechnicalSeoConfig().amp;
    const dom = new JSDOM(html);
    const document = dom.window.document;

    const isAmpPage = this.detectAmpPage(document);
    const ampVersion = this.getAmpVersion(document);
    const ampComponents = await this.validateAmpComponents(html);
    const canonicalRelation = this.analyzeCanonicalRelation(document, url);
    const ampSize = this.analyzeAmpSize(html);

    const score = this.calculateAmpScore(
      isAmpPage,
      ampComponents,
      canonicalRelation,
      ampSize
    );

    const recommendations = this.generateAmpRecommendations(
      isAmpPage,
      ampComponents,
      canonicalRelation,
      ampSize
    );

    return {
      isAmpPage,
      ampVersion,
      ampComponents,
      canonicalRelation,
      ampSize,
      score,
      recommendations
    };
  }

  private detectAmpPage(document: Document): boolean {
    const htmlTag = document.documentElement;
    return htmlTag.hasAttribute('amp') || htmlTag.hasAttribute('');
  }

  private getAmpVersion(document: Document): string {
    const ampRuntime = document.querySelector('script[src*="ampproject"]');
    const versionMatch = ampRuntime?.getAttribute('src')?.match(/v\d+/);
    return versionMatch ? versionMatch[0] : '';
  }

  private async validateAmpComponents(html: string) {
    const validator = await amphtmlValidator.getInstance();
    const result = validator.validateString(html);
    
    const components = new Set<string>();
    const validationResults = [];

    result.errors.forEach(error => {
      const componentMatch = error.code.match(/INVALID_(.+)_TAG/);
      if (componentMatch) {
        components.add(componentMatch[1].toLowerCase());
      }
    });

    Array.from(components).forEach(component => {
      validationResults.push({
        name: component,
        valid: !result.errors.some(error => 
          error.code.includes(component.toUpperCase())
        ),
        errors: result.errors
          .filter(error => error.code.includes(component.toUpperCase()))
          .map(error => error.message)
      });
    });

    return validationResults;
  }

  private analyzeCanonicalRelation(document: Document, url: string) {
    const canonical = document.querySelector('link[rel="canonical"]');
    const ampHtml = document.querySelector('link[rel="amphtml"]');
    
    return {
      hasCanonical: !!canonical,
      canonicalUrl: canonical?.getAttribute('href') || '',
      isValid: this.validateCanonicalAmpRelation(canonical?.getAttribute('href'), ampHtml?.getAttribute('href'), url)
    };
  }

  private validateCanonicalAmpRelation(canonical: string, amphtml: string, currentUrl: string): boolean {
    if (!canonical) return false;
    
    try {
      const canonicalUrl = new URL(canonical, currentUrl);
      const currentUrlObj = new URL(currentUrl);
      
      if (amphtml) {
        const amphtmlUrl = new URL(amphtml, currentUrl);
        return canonicalUrl.pathname === currentUrlObj.pathname;
      }
      
      return canonicalUrl.pathname === currentUrlObj.pathname;
    } catch (e) {
      return false;
    }
  }

  private analyzeAmpSize(html: string) {
    const config = this.crawlerConfigService.getTechnicalSeoConfig().amp;
    const sizeKB = Buffer.from(html).length / 1024;
    
    return {
      size: sizeKB,
      exceedsLimit: sizeKB > config.maxAmpSize
    };
  }

  private calculateAmpScore(
    isAmpPage: boolean,
    ampComponents: any[],
    canonicalRelation: any,
    ampSize: any
  ): number {
    if (!isAmpPage) return 0;

    let score = 100;

    // Component validation
    const invalidComponents = ampComponents.filter(c => !c.valid).length;
    score -= invalidComponents * 10;

    // Canonical relation
    if (!canonicalRelation.hasCanonical) score -= 20;
    if (!canonicalRelation.isValid) score -= 15;

    // Size analysis
    if (ampSize.exceedsLimit) score -= 25;

    return Math.max(0, Math.min(100, score));
  }

  private generateAmpRecommendations(
    isAmpPage: boolean,
    ampComponents: any[],
    canonicalRelation: any,
    ampSize: any
  ): string[] {
    const recommendations: string[] = [];

    if (!isAmpPage) {
      recommendations.push('Consider implementing AMP for better mobile performance');
      return recommendations;
    }

    ampComponents.forEach(component => {
      if (!component.valid) {
        recommendations.push(`Fix invalid AMP component: ${component.name}`);
        component.errors?.forEach(error => {
          recommendations.push(`  - ${error}`);
        });
      }
    });

    if (!canonicalRelation.hasCanonical) {
      recommendations.push('Add canonical link to AMP page');
    } else if (!canonicalRelation.isValid) {
      recommendations.push('Fix canonical relationship between AMP and non-AMP pages');
    }

    if (ampSize.exceedsLimit) {
      recommendations.push(
        `Reduce AMP page size (${ampSize.size.toFixed(2)}KB) to below ${this.crawlerConfigService.getTechnicalSeoConfig().amp.maxAmpSize}KB`
      );
    }

    return recommendations;
  }
}
 
                                                                                        C:\Workspace\Web\Ai Business grow project\Back_end\src\crawler\services\analysis\content-analysis.service.ts 
import { Injectable } from '@nestjs/common';
import { CrawlerConfigService } from '../../config/crawler-config.service';
import * as langdetect from 'langdetect';
import * as cheerio from 'cheerio';
import * as sjs from 'simhash-js';
import * as syllable from 'syllable';

@Injectable()
export class ContentAnalysisService {
  private simhash: any;
  constructor(private readonly crawlerConfigService: CrawlerConfigService) {
    this.simhash = new sjs.SimHash();
  }

  calculateContentToHtmlRatio($: cheerio.CheerioAPI): number {
    const htmlSize = $.html().length;
    const textContent = $.text().trim();
    const contentSize = textContent.length;
    return contentSize / htmlSize;
  }
 
  generateContentHash(content: string): number {
    return this.simhash.hash(content);
  }

  extractTextContent($: cheerio.CheerioAPI): string {
    $('script, style, iframe').remove();
    return $('body').text().replace(/\s{2,}/g, ' ') 
    .replace(/\n{2,}/g, '\n')
    .trim();
  }

  countSentences(text: string): number {
    return text.split(/[.!?]+/).filter(sentence => sentence.trim().length > 0).length;
  }

  countParagraphs($: cheerio.CheerioAPI): number {
    return $('p').length;
  }


  private countSyllables(text: string): number {
    return text.toLowerCase().split(/\s+/).reduce((count, word) => {
      return count + word.replace(/[^aeiouy]/g, '').length;
    }, 0);
  }

  extractTopKeywords(text: string): { [key: string]: number } {
    const words = text.toLowerCase().match(/\b\w+\b/g) || [];
    const wordCounts: { [key: string]: number } = {};
    words.forEach((word: string) => {
      if (word.length > 3) {
        wordCounts[word] = (wordCounts[word] || 0) + 1;
      }
    });
    return Object.fromEntries(
      Object.entries(wordCounts)
        .sort(([, a], [, b]) => b - a)
        .slice(0, 10)
    );
  }
  
  countWords(text: string): number {
    return text.split(/\s+/).filter(word => word.length > 0).length;
  }


  detectLanguage($: cheerio.CheerioAPI): string {
    const textContent = $('body').text();
    const { confidenceThreshold } = this.crawlerConfigService.getContentAnalysisConfig().languageDetection;
    const detection = langdetect.detect(textContent);
    if (detection && detection.length > 0) {
      const [detectedLang, confidence] = [detection[0].lang, detection[0].prob];
      return confidence >= confidenceThreshold ? detectedLang : 'und';
    }
    
    return 'und';
  }

  calculateKeywordDensity($: cheerio.CheerioAPI, keywords: string[]): Record<string, number> {
    const config = this.crawlerConfigService.getKeywordAnalysisConfig();
    const words =  $('body').text().toLowerCase().split(/\s+/);
    const totalWords = words.length;
    const keywordDensity: Record<string, number> = {};

    keywords.forEach(keyword => {
      const keywordCount = words.filter(word => word === keyword.toLowerCase()).length;
      const density = (keywordCount / totalWords) * 100;
      if (density >= config.densityThreshold) {
        keywordDensity[keyword] = parseFloat(density.toFixed(2));
      }
    });

    return keywordDensity;
  }

  analyzeKeywordUsage($: cheerio.CheerioAPI, keywords: string[]): Record<string, number> {
    const config = this.crawlerConfigService.getKeywordAnalysisConfig();
    const words = $('body').text().split(/\s+/);
    const keywordUsage: Record<string, number> = {};

    keywords.forEach(keyword => {
      const keywordCount = words.filter(word => word === keyword.toLowerCase()).length;
      if (keywordCount >= config.usageMinCount && keywordCount <= config.usageMaxCount) {
        keywordUsage[keyword] = keywordCount;
      }
    });

    return keywordUsage;
  }

  analyzeThinContent(html: string): ThinContentAnalysis {
    const $ = cheerio.load(html);
    const fullText = $('body').text();
    const mainContent = this.extractMainContent($);
    const { wordThreshold, charThreshold } = this.crawlerConfigService.getThinContentConfig();

    const wordCount = this.countWords(mainContent);
    const charCount = mainContent.length;
    const contentToHtmlRatio = this.calculateContentToHtmlRatioForThinContent(html, fullText);

    return {
      isThinContent: wordCount < wordThreshold || charCount < charThreshold,
      wordCount,
      charCount,
      contentDensity: charCount / wordCount,
      contentToHtmlRatio,
      specificElementsAnalysis: this.analyzeSpecificElements($),
      mainContentWordCount: this.countWords(mainContent),
      fullPageWordCount: this.countWords(fullText),
    };
  }

  private analyzeSpecificElements($: cheerio.CheerioAPI): SpecificElementsAnalysis {
    return {
      hasMain: $('main').length > 0,
      hasArticle: $('article').length > 0,
      hasContentWrapper: $('.content, #content').length > 0,
    };
  }

  private calculateContentToHtmlRatioForThinContent(html: string, text: string): number {
    const htmlLength = html.length;
    const textLength = text.length;
    return textLength / htmlLength;
  }

  private extractMainContent($: cheerio.CheerioAPI): string {
    const mainSelectors = ['main', 'article', '.content', '#content'];
    for (const selector of mainSelectors) {
      const element = $(selector);
      if (element.length) {
        return element.text();
      }
    }
    return $('body').text();
  }
  calculateReadabilityScore(content: string): ReadabilityAnalysis {
    const sentences = this.countSentences(content);
    const words = this.countWords(content);
    const syllables = this.countSyllables(content);

    const fleschKincaid = this.calculateFleschKincaid(sentences, words, syllables);
    const automatedReadability = this.calculateAutomatedReadabilityIndex(sentences, words, content);
    const colemanLiau = this.calculateColemanLiauIndex(sentences, words, content);

    return {
      fleschKincaidGrade: fleschKincaid,
      automatedReadabilityIndex: automatedReadability,
      colemanLiauIndex: colemanLiau,
      averageGradeLevel: (fleschKincaid + automatedReadability + colemanLiau) / 3,
      sentenceCount: sentences,
      wordCount: words,
      syllableCount: syllables,
      averageWordLength: content.length / words,
      averageSyllablesPerWord: syllables / words,
      averageWordsPerSentence: words / sentences,
    };
  }

  private calculateFleschKincaid(sentences: number, words: number, syllables: number): number {
    return 0.39 * (words / sentences) + 11.8 * (syllables / words) - 15.59;
  }

  private calculateAutomatedReadabilityIndex(sentences: number, words: number, content: string): number {
    const characters = content.replace(/\s/g, '').length;
    return 4.71 * (characters / words) + 0.5 * (words / sentences) - 21.43;
  }

  private calculateColemanLiauIndex(sentences: number, words: number, content: string): number {
    const characters = content.replace(/\s/g, '').length;
    const L = (characters / words) * 100;
    const S = (sentences / words) * 100;
    return 0.0588 * L - 0.296 * S - 15.8;
  }

}


interface ThinContentAnalysis {
  isThinContent: boolean;
  wordCount: number;
  charCount: number;
  contentDensity: number;
  contentToHtmlRatio: number;
  specificElementsAnalysis: SpecificElementsAnalysis;
  mainContentWordCount: number;
  fullPageWordCount: number;
}

interface SpecificElementsAnalysis {
  hasMain: boolean;
  hasArticle: boolean;
  hasContentWrapper: boolean;
}

interface ReadabilityAnalysis {
  fleschKincaidGrade: number;
  automatedReadabilityIndex: number;
  colemanLiauIndex: number;
  averageGradeLevel: number;
  sentenceCount: number;
  wordCount: number;
  syllableCount: number;
  averageWordLength: number;
  averageSyllablesPerWord: number;
  averageWordsPerSentence: number;
}
 
                                                                                        C:\Workspace\Web\Ai Business grow project\Back_end\src\crawler\services\analysis\content-type-analyzer.service.ts 
import { Injectable } from '@nestjs/common';
import { CrawlerConfigService } from '../../config/crawler-config.service';
import * as mime from 'mime-types';

@Injectable()
export class ContentTypeAnalyzerService {
  constructor(private readonly crawlerConfigService: CrawlerConfigService) {}

  analyzeMimeType(contentType: string, url: string): MimeTypeAnalysis {
    const [mimeType] = contentType.split(';');
    const extension = this.getFileExtension(url);
    const detectedMimeType = mime.lookup(extension) || mimeType;

    return {
      declaredMimeType: mimeType,
      detectedMimeType,
      mimeTypeMatch: mimeType === detectedMimeType,
      fileExtension: extension,
    };
  }

  private getFileExtension(url: string): string {
    const parsedUrl = new URL(url);
    const pathname = parsedUrl.pathname;
    const extension = pathname.split('.').pop() || '';
    return extension.toLowerCase();
  }
}

interface MimeTypeAnalysis {
  declaredMimeType: string;
  detectedMimeType: string;
  mimeTypeMatch: boolean;
  fileExtension: string;
}
 
                                                                                        C:\Workspace\Web\Ai Business grow project\Back_end\src\crawler\services\analysis\cookie-analysis.service.ts 
import { Injectable } from '@nestjs/common';
import { CrawlerConfigService } from '../../config/crawler-config.service';
import { CookieAnalysis } from '../../interfaces/technical-seo.interface';

@Injectable()
export class CookieAnalysisService {
  constructor(private readonly crawlerConfigService: CrawlerConfigService) {}

  async analyzeCookies(cookies: string[], headers: Record<string, string>, html: string): Promise<CookieAnalysis> {
    const config = this.crawlerConfigService.getTechnicalSeoConfig().cookies;
    
    const parsedCookies = this.parseCookies(cookies);
    const statistics = this.calculateCookieStatistics(parsedCookies);
    const gdprCompliance = this.analyzeGdprCompliance(parsedCookies, headers, html);
    
    const score = this.calculateCookieScore(statistics, gdprCompliance);
    const recommendations = this.generateCookieRecommendations(
      parsedCookies,
      statistics,
      gdprCompliance
    );

    return {
      cookies: parsedCookies,
      statistics,
      gdprCompliance,
      score,
      recommendations
    };
  }

  private parseCookies(cookies: string[]) {
    return cookies.map(cookie => {
      const parts = cookie.split(';').map(part => part.trim());
      const [nameValue, ...attributes] = parts;
      const [name, value] = nameValue.split('=').map(s => s.trim());

      const cookieObj = {
        name,
        value,
        domain: '',
        size: Buffer.from(cookie).length,
        httpOnly: false,
        secure: false,
        sameSite: 'Lax',
        category: this.categorizeCookie(name)
      };

      attributes.forEach(attr => {
        const [key, val] = attr.split('=').map(s => s.trim());
        if (key.toLowerCase() === 'domain') cookieObj.domain = val;
        if (key.toLowerCase() === 'httponly') cookieObj.httpOnly = true;
        if (key.toLowerCase() === 'secure') cookieObj.secure = true;
        if (key.toLowerCase() === 'samesite') cookieObj.sameSite = val;
      });

      return cookieObj;
    });
  }

  private categorizeCookie(name: string): string {
    const categories = {
      necessary: ['sess', 'auth', 'token', 'csrf', 'security'],
      preferences: ['theme', 'lang', 'timezone', 'prefs'],
      statistics: ['ga', 'analytics', 'stats', '_utm'],
      marketing: ['ad', 'track', 'pixel', 'campaign']
    };

    const lowerName = name.toLowerCase();
    
    for (const [category, patterns] of Object.entries(categories)) {
      if (patterns.some(pattern => lowerName.includes(pattern))) {
        return category;
      }
    }

    return 'unknown';
  }

  private calculateCookieStatistics(cookies: any[]) {
    const config = this.crawlerConfigService.getTechnicalSeoConfig().cookies;
    const categoryCounts = {};
    let totalSize = 0;

    cookies.forEach(cookie => {
      categoryCounts[cookie.category] = (categoryCounts[cookie.category] || 0) + 1;
      totalSize += cookie.size;
    });

    return {
      totalCount: cookies.length,
      totalSize,
      categoryCounts,
      exceedsLimit: cookies.length > config.maxCookiesPerDomain
    };
  }

  private analyzeGdprCompliance(cookies: any[], headers: Record<string, string>, html: string) {
    const hasConsentManager = this.detectConsentManager(html);
    const necessaryOnly = cookies.every(cookie => cookie.category === 'necessary');
    const issues = [];

    // Check for secure flag on sensitive cookies
    cookies.forEach(cookie => {
      if (cookie.category === 'necessary' && !cookie.secure) {
        issues.push(`Security cookie "${cookie.name}" missing secure flag`);
      }
      if (!cookie.sameSite) {
        issues.push(`Cookie "${cookie.name}" missing SameSite attribute`);
      }
    });

    // Check for appropriate security headers
    if (!headers['set-cookie']?.includes('SameSite')) {
      issues.push('Missing SameSite cookie policy in headers');
    }

    return {
      hasConsentManager,
      necessaryOnly,
      issues
    };
  }

  private detectConsentManager(html: string): boolean {
    const consentPatterns = [
      'cookieconsent',
      'gdpr',
      'cookie-law',
      'cookie-notice',
      'cookie-banner',
      'cookie-policy',
      'consent-manager',
      'usercentrics',
      'onetrust',
      'cookiebot'
    ];

    return consentPatterns.some(pattern => 
      html.toLowerCase().includes(pattern)
    );
  }

  private calculateCookieScore(statistics: any, gdprCompliance: any): number {
    let score = 100;
    const config = this.crawlerConfigService.getTechnicalSeoConfig().cookies;

    // Deduct points for excessive cookies
    if (statistics.exceedsLimit) {
      score -= 20;
    }

    // Deduct points for missing consent manager
    if (!gdprCompliance.hasConsentManager) {
      score -= 30;
    }

    // Deduct points for each compliance issue
    score -= gdprCompliance.issues.length * 10;

    // Deduct points for high proportion of marketing cookies
    const marketingRatio = (statistics.categoryCounts['marketing'] || 0) / statistics.totalCount;
    if (marketingRatio > 0.3) {
      score -= 15;
    }

    return Math.max(0, Math.min(100, score));
  }

  private generateCookieRecommendations(
    cookies: any[],
    statistics: any,
    gdprCompliance: any
  ): string[] {
    const recommendations: string[] = [];
    const config = this.crawlerConfigService.getTechnicalSeoConfig().cookies;

    if (statistics.exceedsLimit) {
      recommendations.push(
        `Reduce the number of cookies (current: ${statistics.totalCount}, limit: ${config.maxCookiesPerDomain})`
      );
    }

    if (!gdprCompliance.hasConsentManager) {
      recommendations.push('Implement a GDPR-compliant cookie consent manager');
    }

    gdprCompliance.issues.forEach(issue => {
      recommendations.push(issue);
    });

    if (statistics.totalSize > config.maxCookieSize * 1024) {
      recommendations.push(
        `Reduce total cookie size (current: ${(statistics.totalSize / 1024).toFixed(2)}KB, limit: ${config.maxCookieSize}KB)`
      );
    }

    const unsecuredNecessaryCookies = cookies.filter(
        c => c.category === 'necessary' && !c.secure
      ).length;
  
      if (unsecuredNecessaryCookies > 0) {
        recommendations.push(
          `Add secure flag to ${unsecuredNecessaryCookies} necessary cookies`
        );
      }
  
      const marketingCookies = cookies.filter(c => c.category === 'marketing').length;
      if (marketingCookies > 0) {
        recommendations.push(
          `Consider reducing marketing cookies (current: ${marketingCookies}) to improve privacy compliance`
        );
      }
  
      // Check for SameSite attribute
      const missingSameSite = cookies.filter(c => !c.sameSite).length;
      if (missingSameSite > 0) {
        recommendations.push(
          `Add SameSite attribute to ${missingSameSite} cookies for better security`
        );
      }
  
      // Third-party cookie recommendations
      const thirdPartyCookies = cookies.filter(
        c => c.domain && !c.domain.includes(window.location.hostname)
      ).length;
      if (thirdPartyCookies > 0) {
        recommendations.push(
          `Review necessity of ${thirdPartyCookies} third-party cookies`
        );
      }
  
      return recommendations;
    }
  }
   
                                                                                        C:\Workspace\Web\Ai Business grow project\Back_end\src\crawler\services\analysis\directory-tree-analyzer.ts 
import { Injectable } from '@nestjs/common';

@Injectable()
export class DirectoryTreeAnalyzer {
  analyzeDirectoryTree(directoryTree: any): Record<string, number | string | Record<string, number>> {
    const analysis: Record<string, number | string | Record<string, number>> = {
      totalFiles: 0,
      totalFolders: 0,
      maxDepth: 0,
      averageFilesPerFolder: 0,
      mostCommonFileType: '',
      fileTypeDistribution: {} as Record<string, number>,
    };

    this.traverseTree(directoryTree, 0, analysis);

    analysis.averageFilesPerFolder = analysis.totalFiles as number / (analysis.totalFolders as number);
    analysis.mostCommonFileType = this.getMostCommonFileType(analysis.fileTypeDistribution as Record<string, number>);

    return analysis;
  }

  private traverseTree(node: any, depth: number, analysis: Record<string, number | string | Record<string, number>>) {
    if (node.type === 'file') {
      analysis.totalFiles = (analysis.totalFiles as number) + 1;
      const fileType = this.getFileType(node.name);
      (analysis.fileTypeDistribution as Record<string, number>)[fileType] = ((analysis.fileTypeDistribution as Record<string, number>)[fileType] || 0) + 1;
    } else if (node.type === 'directory') {
      analysis.totalFolders = (analysis.totalFolders as number) + 1;
      analysis.maxDepth = Math.max(analysis.maxDepth as number, depth);
      if (node.children) {
        node.children.forEach((child: any) => this.traverseTree(child, depth + 1, analysis));
      }
    }
  }

  private getFileType(fileName: string): string {
    const parts = fileName.split('.');
    return parts.length > 1 ? parts[parts.length - 1].toLowerCase() : 'unknown';
  }

  private getMostCommonFileType(fileTypeDistribution: Record<string, number>): string {
    return Object.entries(fileTypeDistribution).reduce((a, b) => a[1] > b[1] ? a : b)[0];
  }

  generateInsights(analysis: Record<string, number | string | Record<string, number>>): string[] {
    const insights: string[] = [];

    insights.push(`The website contains ${analysis.totalFiles} files in ${analysis.totalFolders} folders.`);
    insights.push(`The deepest folder is ${analysis.maxDepth} levels deep.`);
    insights.push(`On average, there are ${(analysis.averageFilesPerFolder as number).toFixed(2)} files per folder.`);
    insights.push(`The most common file type is ${analysis.mostCommonFileType}.`);

    if ((analysis.maxDepth as number) > 5) {
      insights.push("The folder structure is quite deep. Consider simplifying for better organization.");
    }

    if ((analysis.averageFilesPerFolder as number) > 20) {
      insights.push("Some folders contain a large number of files. Consider reorganizing for better maintainability.");
    }

    return insights;
  }
} 
                                                                                        C:\Workspace\Web\Ai Business grow project\Back_end\src\crawler\services\analysis\http-header.service.ts 
import { Injectable } from '@nestjs/common';
import { CrawlerConfigService } from '../../config/crawler-config.service';

@Injectable()
export class HttpHeaderService {
  constructor(private readonly crawlerConfigService: CrawlerConfigService) {}

  analyzeHttpStatusCode(statusCode: number): HttpStatusCodeAnalysis {
    const category = this.categorizeStatusCode(statusCode);
    const seoImpact = this.assessSeoImpact(statusCode, category);

    return {
      statusCode,
      category,
      seoImpact,
    };
  }

  private categorizeStatusCode(statusCode: number): HttpStatusCategory {
    const config = this.crawlerConfigService.getHttpStatusCodeConfig();

    if (statusCode >= config.informational.min && statusCode <= config.informational.max) {
      return 'Informational';
    } else if (statusCode >= config.success.min && statusCode <= config.success.max) {
      return 'Success';
    } else if (statusCode >= config.redirection.min && statusCode <= config.redirection.max) {
      return 'Redirection';
    } else if (statusCode >= config.clientError.min && statusCode <= config.clientError.max) {
      return 'ClientError';
    } else if (statusCode >= config.serverError.min && statusCode <= config.serverError.max) {
      return 'ServerError';
    }
    return 'Unknown';
  }

  private assessSeoImpact(statusCode: number, category: HttpStatusCategory): SeoImpact {
    switch (category) {
      case 'Success':
        return 'Positive';
      case 'Redirection':
        return statusCode === 301 ? 'Neutral' : 'Negative';
      case 'ClientError':
      case 'ServerError':
        return 'Negative';
      default:
        return 'Neutral';
    }
  }

  extractContentType(headers: Record<string, string>): string {
    return headers['content-type'] || 'application/octet-stream';
  }

  categorizeContentType(contentType: string): string {
    const config = this.crawlerConfigService.getContentTypeConfig();
    if (!config.enabled) {
      return 'unknown';
    }

    const [mimeType] = contentType.split(';');
    const lowerMimeType = mimeType.toLowerCase().trim();

    if (lowerMimeType.startsWith('text/html')) return 'HTML';
    if (lowerMimeType === 'application/pdf') return 'PDF';
    if (lowerMimeType.startsWith('image/')) return 'Image';
    if (lowerMimeType.startsWith('text/')) return 'Text';
    if (lowerMimeType.includes('javascript')) return 'JavaScript';
    if (lowerMimeType.includes('css')) return 'CSS';
    if (lowerMimeType.includes('xml')) return 'XML';
    if (lowerMimeType.includes('json')) return 'JSON';

    return 'Other';
  }

  analyzeContentType(headers: Record<string, string>): ContentTypeAnalysis {
    const contentType = this.extractContentType(headers);
    const category = this.categorizeContentType(contentType);
    const config = this.crawlerConfigService.getContentTypeConfig();

    return {
      contentType,
      category,
      isAllowed: config.allowedTypes.includes(contentType),
      exceedsMaxSize: parseInt(headers['content-length'] || '0', 10) > config.maxSize,
    };
  }

  private parseXRobotsTagDirectives(xRobotsTag: string): XRobotsTagDirectives {
    const directives: XRobotsTagDirectives = {
      noindex: false,
      nofollow: false,
      none: false,
      noarchive: false,
      nosnippet: false,
      notranslate: false,
      noimageindex: false,
      unavailable_after: null,
    };

    const parts = xRobotsTag.toLowerCase().split(',').map(part => part.trim());
    
    for (const part of parts) {
      if (part === 'none') {
        directives.none = true;
        directives.noindex = true;
        directives.nofollow = true;
      } else if (part in directives) {
        directives[part] = true;
      } else if (part.startsWith('unavailable_after:')) {
        directives.unavailable_after = part.split(':')[1].trim();
      }
    }

    return directives;
  }

  analyzeXRobotsTag(headers: Record<string, string>): XRobotsTagAnalysis {
    const config = this.crawlerConfigService.getHttpHeaderConfig();
    if (!config.xRobotsTagEnabled) {
      return { present: false };
    }

    const xRobotsTag = headers['x-robots-tag'];
    if (!xRobotsTag) {
      return { present: false };
    }

    const directives = this.parseXRobotsTagDirectives(xRobotsTag);
    return {
      present: true,
      value: xRobotsTag,
      directives,
      exceedsMaxLength: xRobotsTag.length > config.xRobotsTagMaxLength,
    };
  }

  analyzeSecurityHeaders(headers: Record<string, string>): SecurityHeaderAnalysis {
    const config = this.crawlerConfigService.getSecurityHeaderConfig();
    if (!config.enabled) {
      return { analyzed: false };
    }

    const analysis: SecurityHeaderAnalysis = {
      analyzed: true,
      headers: {},
    };

    for (const header of config.headersToCheck) {
      const value = headers[header.toLowerCase()];
      analysis.headers[header] = {
        present: !!value,
        value: value || '',
      };
    }

    return analysis;
  }
 
}

type HttpStatusCategory = 'Informational' | 'Success' | 'Redirection' | 'ClientError' | 'ServerError' | 'Unknown';
type SeoImpact = 'Positive' | 'Neutral' | 'Negative';

interface HttpStatusCodeAnalysis {
  statusCode: number;
  category: HttpStatusCategory;
  seoImpact: SeoImpact;
}

interface SecurityHeaderAnalysis {
    analyzed: boolean;
    headers?: {
      [key: string]: {
        present: boolean;
        value: string;
      };
    };
  }

interface ContentTypeAnalysis {
    contentType: string;
    category: string;
    isAllowed: boolean;
    exceedsMaxSize: boolean;
}

interface XRobotsTagDirectives {
    noindex: boolean;
    nofollow: boolean;
    none: boolean;
    noarchive: boolean;
    nosnippet: boolean;
    notranslate: boolean;
    noimageindex: boolean;
    unavailable_after: string | null;
}

interface XRobotsTagAnalysis {
    present: boolean;
    value?: string;
    directives?: XRobotsTagDirectives;
    exceedsMaxLength?: boolean;
}
 
                                                                                        C:\Workspace\Web\Ai Business grow project\Back_end\src\crawler\services\analysis\image-analysis.service.ts 

import { Injectable, Logger } from '@nestjs/common';
import { CrawlerConfigService } from '../../config/crawler-config.service';
import * as cheerio from 'cheerio';
import { AsyncHttpService } from '../async-http.service';
import * as probe from 'probe-image-size';
 

@Injectable()
export class ImageAnalysisService {
  private readonly logger = new Logger(ImageAnalysisService.name);
  private config: any;

  constructor(
    private readonly crawlerConfigService: CrawlerConfigService,
    private readonly asyncHttpService: AsyncHttpService
  ) {
    this.config = this.crawlerConfigService.getImageAnalysisConfig();
  }

  async analyzeImages($: cheerio.CheerioAPI, baseUrl: string,  keyWords:string[]): Promise<ImageAnalysisResult[]> {
    const images = $('img');
    const analysisPromises = images.map((_, img) => this.analyzeImage($(img), baseUrl,  keyWords)).get();
    return Promise.all(analysisPromises);
  }

  private async analyzeImage(image: any, baseUrl: string, keyWords:string[]): Promise<ImageAnalysisResult> {
    const src = this.getFullUrl(image.attr('src'), baseUrl);
    const alt = image.attr('alt');
    const title = image.attr('title');

    const result: ImageAnalysisResult = {
      url: src,
      altText: {
        present: !!alt,
        content: alt || '',
        length: (alt || '').length,
        keywordUsage: this.analyzeKeywordUsageInAltText(alt, keyWords),
      },
      titleAttribute: {
        present: !!title,
        content: title || '',
      },
      isBroken: false,
    };

    try {
      const probeResult = await probe(src);
      result.fileSize = probeResult.length;
      result.dimensions = { width: probeResult.width, height: probeResult.height };
      result.fileFormat = probeResult.mime;
      result.isBroken = false;

      this.analyzeImageSEO(result);
    } catch (error) {
      this.logger.error(`Error analyzing image ${src}: ${error.message}`);
      result.isBroken = true;
    }

    return result;
  }

  private getFullUrl(src: string, baseUrl: string): string {
    if (src.startsWith('http')) return src;
    return new URL(src, baseUrl).href;
  }

  private analyzeKeywordUsageInAltText(alt: string, keywords: string[]): number {
    if (!alt) return 0;
    return keywords.filter(keyword => alt.toLowerCase().includes(keyword.toLowerCase())).length;
  }

  private analyzeKeywordUsageInTitle(title: string, keywords: string[]): number {
    if (!title) return 0;
    return keywords.filter(keyword => title.toLowerCase().includes(keyword.toLowerCase())).length;
  }

  private analyzeImageSEO(result: ImageAnalysisResult): void {
    result.seoAnalysis = {
      altTextQuality: this.analyzeAltTextQuality(result.altText),
      fileSizeOptimized: result.fileSize <= this.config.maxSizeMB * 1024 * 1024,
      dimensionsOptimal: this.analyzeDimensions(result.dimensions),
      formatOptimal: this.analyzeFormat(result.fileFormat),
    };
  }

  private analyzeAltTextQuality(altText: AltTextAnalysis): string {
    if (!altText.present) return 'Missing alt text';
    if (altText.length < 5) return 'Alt text too short';
    if (altText.length > 125) return 'Alt text too long';
    if (altText.keywordUsage === 0) return 'No relevant keywords in alt text';
    return 'Good';
  }

  private analyzeDimensions(dimensions: ImageDimensions): boolean {
    return dimensions.width >= this.config.minWidth && dimensions.height >= this.config.minHeight;
  }

  private analyzeFormat(format: string): boolean {
    return this.config.allowedFormats.includes(format.split('/')[1]);
  }


}

interface ImageAnalysisResult {
  url: string;
  altText: AltTextAnalysis;
  titleAttribute: {
    present: boolean;
    content: string;
  };
  fileSize?: number;
  dimensions?: ImageDimensions;
  fileFormat?: string;
  isBroken: boolean;
  textInImage?: TextInImageResult;
  seoAnalysis?: ImageSEOAnalysis;
}

interface AltTextAnalysis {
  present: boolean;
  content: string;
  length: number;
  keywordUsage: number;
}

interface ImageDimensions {
  width: number;
  height: number;
}

interface TextInImageResult {
  hasText: boolean;
  text: string;
  confidence: number;
}

interface ImageSEOAnalysis {
  altTextQuality: string;
  fileSizeOptimized: boolean;
  dimensionsOptimal: boolean;
  formatOptimal: boolean;
}
 
                                                                                        C:\Workspace\Web\Ai Business grow project\Back_end\src\crawler\services\analysis\java-rendering-script-analysis.service.ts 
import { Injectable, Logger } from '@nestjs/common';
import { CrawlerConfigService } from '../../config/crawler-config.service';
import * as cheerio from 'cheerio';

@Injectable()
export class JavaRenderingScriptAnalysisService {
  private readonly logger = new Logger(JavaRenderingScriptAnalysisService.name);

  constructor(private readonly crawlerConfigService: CrawlerConfigService) {}

  analyzeRenderedVsNonRendered(nonRenderedHtml: string, renderedHtml: string): RenderedVsNonRenderedAnalysis {

    if(!!this.crawlerConfigService.getJavaScriptRenderingConfig().enabled){
      return null;
    }

    const $nonRendered = cheerio.load(nonRenderedHtml);
    const $rendered = cheerio.load(renderedHtml);

    return {
      contentDifference: this.analyzeContentDifference($nonRendered, $rendered),
      dynamicElements: this.analyzeDynamicElements($nonRendered, $rendered),
      seoImpact: this.analyzeSEOImpact($nonRendered, $rendered),
    };
  }

  private analyzeContentDifference($nonRendered: cheerio.CheerioAPI, $rendered: cheerio.CheerioAPI): ContentDifferenceAnalysis {
    const nonRenderedText = $nonRendered('body').text().trim();
    const renderedText = $rendered('body').text().trim();

    return {
      textLengthDifference: renderedText.length - nonRenderedText.length,
      wordCountDifference: this.countWords(renderedText) - this.countWords(nonRenderedText),
      newHeadings: this.analyzeNewHeadings($nonRendered, $rendered),
      newParagraphs: this.countNewElements($nonRendered, $rendered, 'p'),
      newImages: this.analyzeNewImages($nonRendered, $rendered),
      newLinks: this.analyzeNewLinks($nonRendered, $rendered),
    };
  }

  private analyzeDynamicElements($nonRendered: cheerio.CheerioAPI, $rendered: cheerio.CheerioAPI): DynamicElementsAnalysis {
    return {
      lazyLoadedImages: this.analyzeLazyLoadedImages($nonRendered, $rendered),
      infiniteScroll: this.detectInfiniteScroll($rendered),
      dynamicTabs: this.detectDynamicTabs($rendered),
      ajaxForms: this.detectAjaxForms($rendered),
    };
  }

  private analyzeSEOImpact($nonRendered: cheerio.CheerioAPI, $rendered: cheerio.CheerioAPI): SEOImpactAnalysis {
    return {
      titleChange: this.compareTitles($nonRendered, $rendered),
      metaDescriptionChange: this.compareMetaDescriptions($nonRendered, $rendered),
      canonicalUrlChange: this.compareCanonicalUrls($nonRendered, $rendered),
      structuredDataChange: this.compareStructuredData($nonRendered, $rendered),
      hreflangChange: this.compareHreflang($nonRendered, $rendered),
    };
  }

  private countWords(text: string): number {
    return text.split(/\s+/).filter(word => word.length > 0).length;
  }

  private analyzeNewHeadings($nonRendered: cheerio.CheerioAPI, $rendered: cheerio.CheerioAPI): NewHeadingsAnalysis {
    const headings = ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'];
    const result: NewHeadingsAnalysis = {};

    headings.forEach(tag => {
      const nonRenderedHeadings = new Set($nonRendered(tag).map((_, el) => $nonRendered(el).text()).get());
      const renderedHeadings = $rendered(tag).map((_, el) => $rendered(el).text()).get();
      result[tag] = renderedHeadings.filter(heading => !nonRenderedHeadings.has(heading));
    });

    return result;
  }

  private countNewElements($nonRendered: cheerio.CheerioAPI, $rendered: cheerio.CheerioAPI, selector: string): number {
    return $rendered(selector).length - $nonRendered(selector).length;
  }

  private analyzeNewImages($nonRendered: cheerio.CheerioAPI, $rendered: cheerio.CheerioAPI): NewImagesAnalysis {
    const nonRenderedImages = new Set($nonRendered('img').map((_, el) => $nonRendered(el).attr('src')).get());
    const renderedImages = $rendered('img').map((_, el) => ({
      src: $rendered(el).attr('src') || '',
      alt: $rendered(el).attr('alt') || '',
    })).get();
  
    return {
      newImages: renderedImages.filter(img => !nonRenderedImages.has(img.src))
    };
  }

  private analyzeNewLinks($nonRendered: cheerio.CheerioAPI, $rendered: cheerio.CheerioAPI): NewLinksAnalysis {
    const nonRenderedLinks = new Set($nonRendered('a').map((_, el) => $nonRendered(el).attr('href')).get());
    const renderedLinks = $rendered('a').map((_, el) => ({
      href: $rendered(el).attr('href') || '',
      text: $rendered(el).text(),
    })).get();
  
    return {
      newLinks: renderedLinks.filter(link => !nonRenderedLinks.has(link.href))
    };
  }
  private analyzeLazyLoadedImages($nonRendered: cheerio.CheerioAPI, $rendered: cheerio.CheerioAPI): LazyLoadedImagesAnalysis {
    const nonRenderedImages = new Set($nonRendered('img').map((_, el) => $nonRendered(el).attr('src')).get());
    const renderedImages = $rendered('img').map((_, el) => $rendered(el).attr('src')).get();

    return {
      count: renderedImages.filter(src => !nonRenderedImages.has(src)).length,
      urls: renderedImages.filter(src => !nonRenderedImages.has(src)),
    };
  }

  private detectInfiniteScroll($rendered: cheerio.CheerioAPI): boolean {
    // This is a simplified check. In reality, you'd need to analyze the page's JavaScript.
    return $rendered('[data-infinite-scroll]').length > 0 || $rendered('.infinite-scroll').length > 0;
  }

  private detectDynamicTabs($rendered: cheerio.CheerioAPI): boolean {
    return $rendered('.tab-content').length > 0 || $rendered('[role="tabpanel"]').length > 0;
  }

  private detectAjaxForms($rendered: cheerio.CheerioAPI): boolean {
    return $rendered('form[data-remote="true"]').length > 0 || $rendered('form.ajax-form').length > 0;
  }

  private compareTitles($nonRendered: cheerio.CheerioAPI, $rendered: cheerio.CheerioAPI): TitleChangeAnalysis {
    const nonRenderedTitle = $nonRendered('title').text();
    const renderedTitle = $rendered('title').text();

    return {
      changed: nonRenderedTitle !== renderedTitle,
      original: nonRenderedTitle,
      rendered: renderedTitle,
    };
  }

  private compareMetaDescriptions($nonRendered: cheerio.CheerioAPI, $rendered: cheerio.CheerioAPI): MetaDescriptionChangeAnalysis {
    const nonRenderedDesc = $nonRendered('meta[name="description"]').attr('content');
    const renderedDesc = $rendered('meta[name="description"]').attr('content');

    return {
      changed: nonRenderedDesc !== renderedDesc,
      original: nonRenderedDesc,
      rendered: renderedDesc,
    };
  }

  private compareCanonicalUrls($nonRendered: cheerio.CheerioAPI, $rendered: cheerio.CheerioAPI): CanonicalUrlChangeAnalysis {
    const nonRenderedCanonical = $nonRendered('link[rel="canonical"]').attr('href');
    const renderedCanonical = $rendered('link[rel="canonical"]').attr('href');

    return {
      changed: nonRenderedCanonical !== renderedCanonical,
      original: nonRenderedCanonical,
      rendered: renderedCanonical,
    };
  }

  private compareStructuredData($nonRendered: cheerio.CheerioAPI, $rendered: cheerio.CheerioAPI): StructuredDataChangeAnalysis {
    const nonRenderedData = this.extractStructuredData($nonRendered);
    const renderedData = this.extractStructuredData($rendered);

    return {
      changed: JSON.stringify(nonRenderedData) !== JSON.stringify(renderedData),
      original: nonRenderedData,
      rendered: renderedData,
    };
  }

  private extractStructuredData($: cheerio.CheerioAPI): any[] {
    return $('script[type="application/ld+json"]')
      .map((_, el) => {
        try {
          return JSON.parse($(el).html() || '');
        } catch (error) {
          this.logger.warn(`Error parsing structured data: ${error.message}`);
          return null;
        }
      })
      .get()
      .filter(data => data !== null);
  }

  private compareHreflang($nonRendered: cheerio.CheerioAPI, $rendered: cheerio.CheerioAPI): HreflangChangeAnalysis {
    const nonRenderedHreflang = this.extractHreflang($nonRendered);
    const renderedHreflang = this.extractHreflang($rendered);

    return {
      changed: JSON.stringify(nonRenderedHreflang) !== JSON.stringify(renderedHreflang),
      original: nonRenderedHreflang,
      rendered: renderedHreflang,
    };
  }

  private extractHreflang($: cheerio.CheerioAPI): HreflangEntry[] {
    return $('link[rel="alternate"][hreflang]')
      .map((_, el) => ({
        hreflang: $(el).attr('hreflang'),
        href: $(el).attr('href'),
      }))
      .get();
  }
}

interface RenderedVsNonRenderedAnalysis {
  contentDifference: ContentDifferenceAnalysis;
  dynamicElements: DynamicElementsAnalysis;
  seoImpact: SEOImpactAnalysis;
}

interface ContentDifferenceAnalysis {
  textLengthDifference: number;
  wordCountDifference: number;
  newHeadings: NewHeadingsAnalysis;
  newParagraphs: number;
  newImages: NewImagesAnalysis;
  newLinks: NewLinksAnalysis;
}

interface NewHeadingsAnalysis {
  [key: string]: string[];
}

interface NewImagesAnalysis {
    newImages: { src: string; alt: string }[];
  }
  
  interface NewLinksAnalysis {
    newLinks: { href: string; text: string }[];
  }

interface DynamicElementsAnalysis {
  lazyLoadedImages: LazyLoadedImagesAnalysis;
  infiniteScroll: boolean;
  dynamicTabs: boolean;
  ajaxForms: boolean;
}

interface LazyLoadedImagesAnalysis {
  count: number;
  urls: string[];
}

interface SEOImpactAnalysis {
  titleChange: TitleChangeAnalysis;
  metaDescriptionChange: MetaDescriptionChangeAnalysis;
  canonicalUrlChange: CanonicalUrlChangeAnalysis;
  structuredDataChange: StructuredDataChangeAnalysis;
  hreflangChange: HreflangChangeAnalysis;
}

interface TitleChangeAnalysis {
  changed: boolean;
  original: string | undefined;
  rendered: string | undefined;
}

interface MetaDescriptionChangeAnalysis {
  changed: boolean;
  original: string | undefined;
  rendered: string | undefined;
}

interface CanonicalUrlChangeAnalysis {
  changed: boolean;
  original: string | undefined;
  rendered: string | undefined;
}

interface StructuredDataChangeAnalysis {
  changed: boolean;
  original: any[];
  rendered: any[];
}

interface HreflangChangeAnalysis {
  changed: boolean;
  original: HreflangEntry[];
  rendered: HreflangEntry[];
}

interface HreflangEntry {
  hreflang: string | undefined;
  href: string | undefined;
} 
                                                                                        C:\Workspace\Web\Ai Business grow project\Back_end\src\crawler\services\analysis\keyword-extraction.service.ts 
import { Injectable } from '@nestjs/common';
import { CrawlerConfigService } from '../../config/crawler-config.service';
import * as natural from 'natural';
import * as sw from 'stopword';

@Injectable()
export class KeywordExtractionService {
  private tokenizer: natural.WordTokenizer;
  private config: KeywordExtractionConfig;

  constructor(private crawlerConfigService: CrawlerConfigService) {
    this.tokenizer = new natural.WordTokenizer();
    this.config = this.crawlerConfigService.getKeywordExtractionConfig();
  }

  extractKeywords(text: string): string[] {
    const tokens = this.tokenizer.tokenize(text.toLowerCase());
    const filteredTokens = tokens.filter(token => token.length >= this.config.minWordLength);
    
    const tfidf = new natural.TfIdf();
    tfidf.addDocument(filteredTokens);

    const keywordScores = filteredTokens.map(token => ({
      word: token,
      score: tfidf.tfidf(token, 0)
    }));

    const sortedKeywords = keywordScores
      .sort((a, b) => b.score - a.score)
      .filter(item => item.score >= this.config.minOccurrence)
      .slice(0, this.config.maxKeywords);

    return sortedKeywords.map(item => item.word);
  }

  identifyImportantTerms(text: string, language: string = 'en'): string[] {
     
     if (!text || !language) {
       return [];
     }

     text = this.extractTextFromHtml(text);

    const tokens = this.tokenizer.tokenize(text.toLowerCase());

    const filteredTokens = sw.removeStopwords(tokens, sw[language]);

    const ngrams = this.generateNgrams(filteredTokens, 3);
    const tfidf = new natural.TfIdf();
    tfidf.addDocument(ngrams);

    const termScores = ngrams.map(term => ({
      term,
      score: tfidf.tfidf(term, 0)
    }));

    const sortedTerms = termScores
      .sort((a, b) => b.score - a.score)
      .filter(item => item.score >= this.config.minOccurrence)
      .slice(0, this.config.maxKeywords);
      
    return sortedTerms.map(item => item.term);
  }

  private generateNgrams(tokens: string[], maxGram: number): string[] {
    let ngrams: string[] = [];
    for (let n = 1; n <= maxGram; n++) {
      for (let i = 0; i <= tokens.length - n; i++) {
        ngrams.push(tokens.slice(i, i + n).join(' '));
      }
    }
    return ngrams;
  }

  extractTextFromHtml(html: string): string {
    const cheerio = require('cheerio');
    const $ = cheerio.load(html);
    
    // Remove script and style elements
    $('script, style').remove();
    
    // Get the text content
    let text = $('body').text();
    
    // Remove extra whitespace
    text = text.replace(/\s+/g, ' ').trim();
    
    return text;
  }

}



interface KeywordExtractionConfig {
    minWordLength: number;
    maxKeywords: number;
    minOccurrence: number;
  }
 
                                                                                        C:\Workspace\Web\Ai Business grow project\Back_end\src\crawler\services\analysis\on-page-element.service.ts 
import { Injectable } from '@nestjs/common';
import { CrawlerConfigService } from '../../config/crawler-config.service';
import * as cheerio from 'cheerio';
import * as textWidth from 'text-width';

@Injectable()
export class OnPageElementService {
  private fontOptions: any;

  constructor(private readonly crawlerConfigService: CrawlerConfigService) {
    this.fontOptions = {
      family: 'Arial',
      size: 16
    };
  }

  analyzeMetaKeywords($: cheerio.CheerioAPI): MetaKeywordsAnalysis {
    const metaKeywordsElement = $('meta[name="keywords"]');
    const metaKeywordsContent = metaKeywordsElement.attr('content') || '';
    const config = this.crawlerConfigService.getMetaKeywordsConfig();

    const keywords = metaKeywordsContent
      .split(',')
      .map(keyword => keyword.trim())
      .filter(keyword => keyword.length > 0);

    return {
      content: metaKeywordsContent,
      keywordCount: keywords.length,
      keywords: keywords.slice(0, config.maxCount),
      exceedsMaxCount: keywords.length > config.maxCount,
    };
  }

    analyzeMetaRobotsTag($: cheerio.CheerioAPI): MetaRobotsTagAnalysis {
      const metaRobotsElement = $('meta[name="robots"]');
      const metaContent = metaRobotsElement.attr('content') || '';
      const config = this.crawlerConfigService.getMetaRobotsConfig();

      const directives = this.parseMetaRobotsDirectives(metaContent);
      const directiveAnalysis = this.analyzeMetaRobotsDirectives(directives, config.directivesToCheck);

      const stats = {
        noindexCount: directiveAnalysis.noindex ? 1 : 0,
        nofollowCount: directiveAnalysis.nofollow ? 1 : 0,
        otherDirectivesCount: Object.values(directiveAnalysis).filter(v => v).length,
      };

      return {
        content: metaContent,
        length: metaContent.length,
        isTooLong: metaContent.length > config.maxLength,
        directives: directiveAnalysis,
        stats: stats,
      };
    }

    parseMetaRobotsDirectives(content: string): string[] {
      return content.toLowerCase().split(',').map(directive => directive.trim());
    }
  
    analyzeMetaRobotsDirectives(directives: string[], directivesToCheck: string[]): Record<string, boolean> {
      const analysis: Record<string, boolean> = {};
      directivesToCheck.forEach(directive => {
        analysis[directive] = directives.includes(directive);
      });
      return analysis;
    }
  

    analyzeTitleTag($: cheerio.CheerioAPI): TitleTagAnalysis {
      const titleElement = $('title');
      const titleContent = titleElement.text().trim();
      const titleLength = titleContent.length;
      const pixelWidth = this.calculatePixelWidth(titleContent);
      const config = this.crawlerConfigService.getTitleTagConfig();

      return {
        content: titleContent,
        length: titleLength,
        pixelWidth,
        isTooShort: titleLength < config.minLength,
        isTooLong: titleLength > config.maxLength,
        isPixelWidthTooNarrow: pixelWidth < config.minPixelWidth,
        isPixelWidthTooWide: pixelWidth > config.maxPixelWidth,
      };
    }

  private calculatePixelWidth(text: string): number {
    return Math.ceil(textWidth(text, this.fontOptions));
  }

  analyzeMetaDescription($: cheerio.CheerioAPI, keywords: string[]): MetaDescriptionAnalysis {
    const metaDescriptionElement = $('meta[name="description"]');
    const metaContent = metaDescriptionElement.attr('content') || '';
    const contentLength = metaContent.length;
    const config = this.crawlerConfigService.getMetaDescriptionConfig();

    const keywordCount = this.countKeywords(metaContent, keywords);

    return {
      content: metaContent,
      length: contentLength,
      isTooShort: contentLength < config.minLength,
      isTooLong: contentLength > config.maxLength,
      keywordCount,
      hasEnoughKeywords: keywordCount >= config.keywordMinCount,
    };
  }

  private countKeywords(text: string, keywords: string[]): number {
    const lowerText = text.toLowerCase();
    return keywords.reduce((count, keyword) => {
      const regex = new RegExp(keyword.toLowerCase(), 'g');
      return count + (lowerText.match(regex) || []).length;
    }, 0);
  }

  analyzeHeadings($: cheerio.CheerioAPI): HeadingAnalysis {
    const config = this.crawlerConfigService.getHeadingAnalysisConfig();
    const headings: HeadingElement[] = ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'].map(tag => ({
      tag,
      elements: $(tag).toArray().map(el => ({
        content: $(el).text().trim(),
        order: $(el).index('h1, h2, h3, h4, h5, h6'),
        tag
      }))
    }));

    return {
      headingCounts: this.analyzeHeadingCounts(headings, config),
      headingOrder: this.analyzeHeadingOrder(headings),
      headingContent: this.analyzeHeadingContent(headings, config)
    };
  }

  private analyzeHeadingCounts(headings: HeadingElement[], config: any): HeadingCountAnalysis {
    const counts = headings.reduce((acc, { tag, elements }) => {
      acc[tag] = elements.length;
      return acc;
    }, {} as Record<string, number>);

    return {
      counts,
      hasIdealH1Count: counts.h1 === config.idealH1Count,
      exceedsMaxCounts: {
        h1: counts.h1 > config.maxH1Count,
        h2: counts.h2 > config.maxH2Count,
        h3: counts.h3 > config.maxH3Count,
        h4: counts.h4 > config.maxH4Count,
        h5: counts.h5 > config.maxH5Count,
        h6: counts.h6 > config.maxH6Count,
      }
    };
  }

  private analyzeHeadingOrder(headings: HeadingElement[]): HeadingOrderAnalysis {
    const flatHeadings = headings.flatMap(h => h.elements);
    const sortedHeadings = flatHeadings.sort((a, b) => a.order - b.order);
    
    const isCorrectOrder = sortedHeadings.every((heading, index) => {
      if (index === 0) return true;
      const prevLevel = parseInt(sortedHeadings[index - 1].tag.charAt(1));
      const currentLevel = parseInt(heading.tag.charAt(1));
      return currentLevel >= prevLevel - 1;
    });

    return {
      isCorrectOrder,
      headingSequence: sortedHeadings.map(h => h.tag)
    };
  }

  private analyzeHeadingContent(headings: HeadingElement[], config: any): HeadingContentAnalysis {
    return headings.reduce((acc, { tag, elements }) => {
      acc[tag] = elements.map(el => ({
        content: el.content,
        length: el.content.length,
        exceedsMaxLength: el.content.length > config.maxLength
      }));
      return acc;
    }, {} as HeadingContentAnalysis);
  }

  analyzeCanonicalTag($: cheerio.CheerioAPI, currentUrl: string): CanonicalTagAnalysis {
    const canonicalElement = $('link[rel="canonical"]');
    const canonicalHref = canonicalElement.attr('href');
    const config = this.crawlerConfigService.getCanonicalTagConfig();

    let isValid = true;
    let issues: string[] = [];

    if (!canonicalHref) {
      isValid = false;
      issues.push('Missing canonical tag');
    } else {
      if (canonicalHref.length > config.maxLength) {
        isValid = false;
        issues.push('Canonical URL exceeds maximum length');
      }

      if (!config.allowRelative && !this.isAbsoluteUrl(canonicalHref)) {
        isValid = false;
        issues.push('Relative canonical URL not allowed');
      }

      if (this.isSelfReferencing(canonicalHref, currentUrl)) {
        issues.push('Self-referencing canonical tag');
      }
    }

    return {
      href: canonicalHref,
      isValid,
      issues,
    };
  }

  private isAbsoluteUrl(url: string): boolean {
    return /^(?:[a-z]+:)?\/\//i.test(url);
  }

  private isSelfReferencing(canonicalHref: string, currentUrl: string): boolean {
    try {
      const canonicalUrl = new URL(canonicalHref, currentUrl);
      const currentPageUrl = new URL(currentUrl);
      return canonicalUrl.href === currentPageUrl.href;
    } catch (error) {
      return false;
    }
  }

  analyzeCanonicalConsistency(pages: { url: string; canonicalHref: string }[]): CanonicalConsistencyAnalysis {
    const canonicalGroups = new Map<string, string[]>();

    pages.forEach(page => {
      if (page.canonicalHref) {
        const group = canonicalGroups.get(page.canonicalHref) || [];
        group.push(page.url);
        canonicalGroups.set(page.canonicalHref, group);
      }
    });

    const inconsistencies = Array.from(canonicalGroups.entries())
      .filter(([canonical, urls]) => urls.length > 1 && !urls.includes(canonical))
      .map(([canonical, urls]) => ({
        canonicalUrl: canonical,
        conflictingUrls: urls,
      }));

    return {
      isConsistent: inconsistencies.length === 0,
      inconsistencies,
    };
  }

  analyzeRelLinks($: cheerio.CheerioAPI): RelLinkAnalysis {
    const config = this.crawlerConfigService.getRelLinkConfig();

    if (!config.enabled) {
      return { nextLink: null, prevLink: null, isPartOfSeries: false };
    }

    const nextLink = $('link[rel="next"]').attr('href') || null;
    const prevLink = $('link[rel="prev"]').attr('href') || null;

    return {
      nextLink,
      prevLink,
      isPartOfSeries: !!(nextLink || prevLink),
    };
  }

  analyzeHreflangTags($: cheerio.CheerioAPI): HreflangAnalysis {
    const hreflangConfig = this.crawlerConfigService.getHreflangConfig();
    const hreflangTags = $('link[rel="alternate"][hreflang]');
    const hreflangData: HreflangTag[] = [];

    hreflangTags.each((_, element) => {
      const $element = $(element);
      const hreflang = $element.attr('hreflang');
      const href = $element.attr('href');

      if (hreflang && href) {
        hreflangData.push({ hreflang, href });
      }
    });

    const analysis: HreflangAnalysis = {
      tags: hreflangData,
      count: hreflangData.length,
      hasXDefault: hreflangData.some(tag => tag.hreflang === 'x-default'),
      exceedsMaxTags: hreflangData.length > hreflangConfig.maxTags,
      missingRequiredAttributes: this.checkMissingAttributes($, hreflangTags, hreflangConfig.requiredAttributes),
    };

    return analysis;
  }

  private checkMissingAttributes($: cheerio.CheerioAPI, tags: any, requiredAttributes: string[]): boolean {
    return tags.toArray().some(element => {
      return requiredAttributes.some(attr => !$(element).attr(attr));
    });
  }

  analyzeOpenGraphTags($: cheerio.CheerioAPI): OpenGraphAnalysis {
    const ogConfig = this.crawlerConfigService.getOpenGraphConfig();
    const ogTags = $('meta[property^="og:"]').toArray();
    const ogProperties = ogTags.map(tag => ({
      property: $(tag).attr('property'),
      content: $(tag).attr('content')
    }));

    const missingRequiredProperties = ogConfig.requiredProperties.filter(
      prop => !ogProperties.some(ogProp => ogProp.property === prop)
    );

    const contentQualityAnalysis = this.analyzeOGContentQuality(ogProperties);

    return {
      properties: ogProperties,
      missingRequiredProperties,
      isValid: missingRequiredProperties.length === 0,
      contentQualityAnalysis,
      recommendations: this.generateOGRecommendations(ogProperties, missingRequiredProperties, contentQualityAnalysis)
    };
  }

  analyzeTwitterCardTags($: cheerio.CheerioAPI): TwitterCardAnalysis {
    const twitterConfig = this.crawlerConfigService.getTwitterCardConfig();
    const twitterTags = $('meta[name^="twitter:"]').toArray();
    const twitterProperties = twitterTags.map(tag => ({
      name: $(tag).attr('name'),
      content: $(tag).attr('content')
    }));

    const missingRequiredProperties = twitterConfig.requiredProperties.filter(
      prop => !twitterProperties.some(twitterProp => twitterProp.name === prop)
    );

    const contentQualityAnalysis = this.analyzeTwitterContentQuality(twitterProperties);

    return {
      properties: twitterProperties,
      missingRequiredProperties,
      isValid: missingRequiredProperties.length === 0,
      contentQualityAnalysis,
      recommendations: this.generateTwitterRecommendations(twitterProperties, missingRequiredProperties, contentQualityAnalysis)
    };
  }

  analyzeViewportMetaTag($: cheerio.CheerioAPI): ViewportAnalysis {
    const viewportConfig = this.crawlerConfigService.getViewportConfig();
    const viewportTag = $('meta[name="viewport"]');
    const viewportContent = viewportTag.attr('content');

    const viewportProperties = viewportContent ? this.parseViewportContent(viewportContent) : {};
    const responsiveAnalysis = this.analyzeResponsiveness(viewportProperties);

    return {
      content: viewportContent,
      isPresent: viewportTag.length > 0,
      isRecommendedValue: viewportContent === viewportConfig.recommendedValue,
      properties: viewportProperties,
      responsiveAnalysis,
      recommendations: this.generateViewportRecommendations(viewportProperties, responsiveAnalysis)
    };
  }

  private analyzeOGContentQuality(properties: { property: string; content: string }[]): OGContentQualityAnalysis {
    const analysis: OGContentQualityAnalysis = {
      titleQuality: { length: 0, isOptimal: false },
      descriptionQuality: { length: 0, isOptimal: false },
      imageQuality: { url: '', dimensions: null, isOptimal: false }
    };

    properties.forEach(prop => {
      switch (prop.property) {
        case 'og:title':
          analysis.titleQuality.length = prop.content.length;
          analysis.titleQuality.isOptimal = prop.content.length >= 10 && prop.content.length <= 60;
          break;
        case 'og:description':
          analysis.descriptionQuality.length = prop.content.length;
          analysis.descriptionQuality.isOptimal = prop.content.length >= 50 && prop.content.length <= 200;
          break;
        case 'og:image':
          analysis.imageQuality.url = prop.content;
          // Here you would typically check the image dimensions by loading the image
          // For this example, we'll assume it's optimal
          analysis.imageQuality.isOptimal = true;
          break;
      }
    });

    return analysis;
  }

  private analyzeTwitterContentQuality(properties: { name: string; content: string }[]): TwitterContentQualityAnalysis {
    const analysis: TwitterContentQualityAnalysis = {
      cardType: '',
      titleQuality: { length: 0, isOptimal: false },
      descriptionQuality: { length: 0, isOptimal: false },
      imageQuality: { url: '', dimensions: null, isOptimal: false }
    };

    properties.forEach(prop => {
      switch (prop.name) {
        case 'twitter:card':
          analysis.cardType = prop.content;
          break;
        case 'twitter:title':
          analysis.titleQuality.length = prop.content.length;
          analysis.titleQuality.isOptimal = prop.content.length >= 10 && prop.content.length <= 70;
          break;
        case 'twitter:description':
          analysis.descriptionQuality.length = prop.content.length;
          analysis.descriptionQuality.isOptimal = prop.content.length >= 50 && prop.content.length <= 200;
          break;
        case 'twitter:image':
          analysis.imageQuality.url = prop.content;
          // Here you would typically check the image dimensions by loading the image
          // For this example, we'll assume it's optimal
          analysis.imageQuality.isOptimal = true;
          break;
      }
    });

    return analysis;
  }

  private parseViewportContent(content: string): ViewportProperties {
    const properties: ViewportProperties = {};
    content.split(',').forEach(prop => {
      const [key, value] = prop.trim().split('=');
      properties[key] = value;
    });
    return properties;
  }

  private analyzeResponsiveness(properties: ViewportProperties): ResponsiveAnalysis {
    const analysis: ResponsiveAnalysis = {
      isResponsive: false,
      hasInitialScale: false,
      initialScaleValue: null
    };

    if (properties['width'] === 'device-width') {
      analysis.isResponsive = true;
    }

    if ('initial-scale' in properties) {
      analysis.hasInitialScale = true;
      analysis.initialScaleValue = parseFloat(properties['initial-scale']);
    }

    return analysis;
  }

  private generateOGRecommendations(properties: any[], missingProperties: string[], qualityAnalysis: OGContentQualityAnalysis): string[] {
    const recommendations: string[] = [];

    missingProperties.forEach(prop => {
      recommendations.push(`Add missing Open Graph property: ${prop}`);
    });

    if (!qualityAnalysis.titleQuality.isOptimal) {
      recommendations.push(`Optimize og:title length. Current length: ${qualityAnalysis.titleQuality.length}. Recommended: 10-60 characters.`);
    }

    if (!qualityAnalysis.descriptionQuality.isOptimal) {
      recommendations.push(`Optimize og:description length. Current length: ${qualityAnalysis.descriptionQuality.length}. Recommended: 50-200 characters.`);
    }

    if (!qualityAnalysis.imageQuality.isOptimal) {
      recommendations.push('Ensure og:image is present and has optimal dimensions (1200x630 pixels recommended for Facebook).');
    }

    return recommendations;
  }

  private generateTwitterRecommendations(properties: any[], missingProperties: string[], qualityAnalysis: TwitterContentQualityAnalysis): string[] {
    const recommendations: string[] = [];

    missingProperties.forEach(prop => {
      recommendations.push(`Add missing Twitter Card property: ${prop}`);
    });

    if (!qualityAnalysis.titleQuality.isOptimal) {
      recommendations.push(`Optimize twitter:title length. Current length: ${qualityAnalysis.titleQuality.length}. Recommended: 10-70 characters.`);
    }

    if (!qualityAnalysis.descriptionQuality.isOptimal) {
      recommendations.push(`Optimize twitter:description length. Current length: ${qualityAnalysis.descriptionQuality.length}. Recommended: 50-200 characters.`);
    }

    if (!qualityAnalysis.imageQuality.isOptimal) {
      recommendations.push('Ensure twitter:image is present and has optimal dimensions (1200x675 pixels recommended for Twitter).');
    }

    return recommendations;
  }

  private generateViewportRecommendations(properties: ViewportProperties, responsiveAnalysis: ResponsiveAnalysis): string[] {
    const recommendations: string[] = [];

    if (!responsiveAnalysis.isResponsive) {
      recommendations.push('Set viewport width to device-width for better responsiveness.');
    }

    if (!responsiveAnalysis.hasInitialScale) {
      recommendations.push('Add initial-scale=1.0 to the viewport meta tag.');
    } else if (responsiveAnalysis.initialScaleValue !== 1.0) {
      recommendations.push('Set initial-scale to 1.0 for optimal viewing experience.');
    }

    return recommendations;
  }
}

interface OpenGraphAnalysis {
  properties: { property: string; content: string }[];
  missingRequiredProperties: string[];
  isValid: boolean;
  contentQualityAnalysis: OGContentQualityAnalysis;
  recommendations: string[];
}

interface TwitterCardAnalysis {
  properties: { name: string; content: string }[];
  missingRequiredProperties: string[];
  isValid: boolean;
  contentQualityAnalysis: TwitterContentQualityAnalysis;
  recommendations: string[];
}

interface ViewportAnalysis {
  content: string | undefined;
  isPresent: boolean;
  isRecommendedValue: boolean;
  properties: ViewportProperties;
  responsiveAnalysis: ResponsiveAnalysis;
  recommendations: string[];
}

interface OGContentQualityAnalysis {
  titleQuality: { length: number; isOptimal: boolean };
  descriptionQuality: { length: number; isOptimal: boolean };
  imageQuality: { url: string; dimensions: { width: number; height: number } | null; isOptimal: boolean };
}

interface TwitterContentQualityAnalysis {
  cardType: string;
  titleQuality: { length: number; isOptimal: boolean };
  descriptionQuality: { length: number; isOptimal: boolean };
  imageQuality: { url: string; dimensions: { width: number; height: number } | null; isOptimal: boolean };
}

interface ViewportProperties {
  [key: string]: string;
}

interface ResponsiveAnalysis {
  isResponsive: boolean;
  hasInitialScale: boolean;
  initialScaleValue: number | null;
}

interface HreflangTag {
  hreflang: string;
  href: string;
}

interface HreflangAnalysis {
  tags: HreflangTag[];
  count: number;
  hasXDefault: boolean;
  exceedsMaxTags: boolean;
  missingRequiredAttributes: boolean;
}

interface CanonicalTagAnalysis {
  href: string | null;
  isValid: boolean;
  issues: string[];
}

interface CanonicalConsistencyAnalysis {
  isConsistent: boolean;
  inconsistencies: {
    canonicalUrl: string;
    conflictingUrls: string[];
  }[];
}

interface TitleTagAnalysis {
  content: string;
  length: number;
  pixelWidth: number;
  isTooShort: boolean;
  isTooLong: boolean;
  isPixelWidthTooNarrow: boolean;
  isPixelWidthTooWide: boolean;
}

interface MetaDescriptionAnalysis {
    content: string;
    length: number;
    isTooShort: boolean;
    isTooLong: boolean;
    keywordCount: number;
    hasEnoughKeywords: boolean;
}

interface HeadingElement {
  tag: string;
  elements: { content: string; order: number; tag: string }[];
}

interface HeadingAnalysis {
  headingCounts: HeadingCountAnalysis;
  headingOrder: HeadingOrderAnalysis;
  headingContent: HeadingContentAnalysis;
}

interface HeadingCountAnalysis {
  counts: Record<string, number>;
  hasIdealH1Count: boolean;
  exceedsMaxCounts: Record<string, boolean>;
}

interface HeadingOrderAnalysis {
  isCorrectOrder: boolean;
  headingSequence: string[];
}

interface HeadingContentAnalysis {
  [key: string]: { content: string; length: number; exceedsMaxLength: boolean }[];
}

interface MetaKeywordsAnalysis {
  content: string;
  keywordCount: number;
  keywords: string[];
  exceedsMaxCount: boolean;
}

interface MetaRobotsTagAnalysis {
  content: string;
  length: number;
  isTooLong: boolean;
  directives: Record<string, boolean>;
  stats: {
    noindexCount: number;
    nofollowCount: number;
    otherDirectivesCount: number;
  };
}


interface RelLinkAnalysis {
  nextLink: string | null;
  prevLink: string | null;
  isPartOfSeries: boolean;
} 
                                                                                        C:\Workspace\Web\Ai Business grow project\Back_end\src\crawler\services\analysis\resource-usage-analysis.service.ts 
import { Injectable } from '@nestjs/common';
import { CrawlerConfigService } from '../../config/crawler-config.service';
import { JSDOM } from 'jsdom';
import { ResourceUsageAnalysis } from '../../interfaces/technical-seo.interface';

@Injectable()
export class ResourceUsageAnalysisService {
  constructor(private readonly crawlerConfigService: CrawlerConfigService) {}

  async analyzeResourceUsage(html: string): Promise<ResourceUsageAnalysis> {
    const config = this.crawlerConfigService.getTechnicalSeoConfig().resourceUsage;
    const dom = new JSDOM(html);
    const document = dom.window.document;

    const iframeAnalysis = this.analyzeIframes(document);
    const flashAnalysis = this.analyzeFlashContent(document);

    const score = this.calculateResourceScore(iframeAnalysis, flashAnalysis);
    const recommendations = this.generateResourceRecommendations(iframeAnalysis, flashAnalysis);

    return {
      iframes: iframeAnalysis,
      flash: flashAnalysis,
      score,
      recommendations
    };
  }

  private analyzeIframes(document: Document) {
    const config = this.crawlerConfigService.getTechnicalSeoConfig().resourceUsage.iframe;
    const iframes = document.querySelectorAll('iframe');
    const iframeElements = [];
    const securityIssues = [];

    iframes.forEach((iframe: HTMLIFrameElement) => {
      const sandboxAttr = iframe.getAttribute('sandbox');
      const element = {
        src: iframe.src,
        hasSandbox: !!sandboxAttr,
        securityAttributes: {
          sandbox: sandboxAttr,
          allowScripts: iframe.hasAttribute('allow-scripts'),
          allowSameOrigin: iframe.hasAttribute('allow-same-origin')
        },
        loading: iframe.loading || 'eager'
      };

      if (!sandboxAttr) {
        securityIssues.push(`Iframe missing sandbox attribute: ${iframe.src}`);
      }

      if (iframe.loading !== 'lazy') {
        securityIssues.push(`Iframe not using lazy loading: ${iframe.src}`);
      }

      iframeElements.push(element);
    });

    return {
      count: iframes.length,
      elements: iframeElements,
      exceedsLimit: iframes.length > config.maxIframes,
      securityIssues
    };
  }

  private analyzeFlashContent(document: Document) {
    const flashElements = [];
    const alternatives = [];

    // Check for object elements
    document.querySelectorAll('object').forEach((obj: HTMLObjectElement) => {
      if (obj.type?.includes('flash') || obj.data?.endsWith('.swf')) {
        flashElements.push({
          type: 'object',
          src: obj.data,
          hasAlternative: this.checkForAlternative(obj)
        });
      }
    });

    // Check for embed elements
    document.querySelectorAll('embed').forEach((embed: HTMLEmbedElement) => {
      if (embed.type?.includes('flash') || embed.src?.endsWith('.swf')) {
        flashElements.push({
          type: 'embed',
          src: embed.src,
          hasAlternative: this.checkForAlternative(embed)
        });
      }
    });

    if (flashElements.length > 0) {
      alternatives.push('Consider using HTML5 video/audio elements');
      alternatives.push('Implement JavaScript-based interactive content');
      alternatives.push('Use modern Web APIs for animations and interactivity');
    }

    return {
      detected: flashElements.length > 0,
      elements: flashElements,
      alternatives
    };
  }

  private checkForAlternative(element: HTMLElement): boolean {
    // Check for HTML5 alternatives within the same parent
    const parent = element.parentElement;
    if (!parent) return false;

    return !!(
      parent.querySelector('video') ||
      parent.querySelector('audio') ||
      parent.querySelector('canvas') ||
      parent.querySelector('[data-alternative]')
    );
  }

  private calculateResourceScore(iframeAnalysis: any, flashAnalysis: any): number {
    let score = 100;

    // Iframe penalties
    if (iframeAnalysis.exceedsLimit) {
      score -= 20;
    }
    score -= iframeAnalysis.securityIssues.length * 5;
    
    // Flash penalties
    if (flashAnalysis.detected) {
      score -= 30;
      score -= flashAnalysis.elements.filter(e => !e.hasAlternative).length * 10;
    }

    return Math.max(0, Math.min(100, score));
  }

  private generateResourceRecommendations(iframeAnalysis: any, flashAnalysis: any): string[] {
    const recommendations: string[] = [];
    const config = this.crawlerConfigService.getTechnicalSeoConfig().resourceUsage.iframe;

    // Iframe recommendations
    if (iframeAnalysis.exceedsLimit) {
      recommendations.push(
        `Reduce the number of iframes (current: ${iframeAnalysis.count}, limit: ${config.maxIframes})`
      );
    }

    iframeAnalysis.securityIssues.forEach(issue => {
      recommendations.push(issue);
    });

    // Add lazy loading recommendations
    const nonLazyIframes = iframeAnalysis.elements.filter(e => e.loading !== 'lazy').length;
    if (nonLazyIframes > 0) {
      recommendations.push(
        `Add lazy loading to ${nonLazyIframes} iframes to improve page performance`
      );
    }

    // Flash recommendations
    if (flashAnalysis.detected) {
      recommendations.push('Remove Flash content as it is no longer supported by modern browsers');
      flashAnalysis.elements.forEach(element => {
        if (!element.hasAlternative) {
          recommendations.push(`Provide HTML5 alternative for Flash content: ${element.src}`);
        }
      });
      flashAnalysis.alternatives.forEach(alt => recommendations.push(alt));
    }

    return recommendations;
  }
}
 
                                                                                        C:\Workspace\Web\Ai Business grow project\Back_end\src\crawler\services\analysis\seo-analyzer.ts 
import * as cheerio from 'cheerio';
import { Injectable } from '@nestjs/common';
import { DirectoryTreeAnalyzer } from './directory-tree-analyzer';
 import { CrawlerConfigService } from '../../config/crawler-config.service';

@Injectable()
export class SEOAnalyzer {
  constructor(private readonly directoryTreeAnalyzer: DirectoryTreeAnalyzer, private readonly crawlerConfigService: CrawlerConfigService) {}

  calculateSEOScores($: cheerio.CheerioAPI, pageData: any): Record<string, number> {
    const scores: Record<string, number> = {};
  
    scores.performance = this.calculatePerformanceScore(pageData.loadTime);
    scores.content = this.calculateContentScore(pageData.mainContent);
    scores.seoBestPractices = this.calculateSEOBestPracticesScore($, pageData);
    scores.technicalSEO = this.calculateTechnicalSEOScore($, pageData);
    scores.userExperience = this.calculateUserExperienceScore($, pageData);
    scores.mobileFriendliness = this.calculateMobileFriendlinessScore($);
    scores.directoryStructure = this.calculateDirectoryStructureScore(pageData.directoryTree);
    
    return scores;
  }
  
  private calculatePerformanceScore(loadTime: number): number {
     return Math.min(100, Math.max(0, 100 - (loadTime - 1000) / 100));
  }

  calculateStructuredDataScore(analysis: any): number {
    const weights = {
      implementation: 0.3,
      validation: 0.2,
      richSnippets: 0.2,
      competitive: 0.2,
      seoImpact: 0.1
    };
  
    const implementationScore = analysis.implementationScore || 0;
    const validationScore = analysis.validation?.isValid ? 1 : 
      Math.max(0, 1 - ((analysis.validation?.errorCount || 0) * 0.1));
    const richSnippetScore = analysis.richSnippets?.eligibleSnippets?.length > 0 ? 1 : 0;
    const competitiveScore = analysis.competitive?.industryStandardsAlignment || 0;
  
    // Calculate SEO impact score only if the property exists
    const seoImpactScore = analysis.seoImpact ? (
      (analysis.seoImpact.visibility?.score || 0) +
      (analysis.seoImpact.richSnippetPotential?.score || 0) +
      (analysis.seoImpact.competitiveAdvantage?.score || 0)
    ) / 3 : 0;
  
    return (
      implementationScore * weights.implementation +
      validationScore * weights.validation +
      richSnippetScore * weights.richSnippets +
      competitiveScore * weights.competitive +
      seoImpactScore * weights.seoImpact
    );
  }

  calculateMetaRobotsTagScore(metaRobotsTagAnalysis: any): number {
    let score = 100;

    if (metaRobotsTagAnalysis.isTooLong) {
      score -= 20;
    }

    if (metaRobotsTagAnalysis.directives.noindex) {
      score -= 50;
    }

    if (metaRobotsTagAnalysis.directives.nofollow) {
      score -= 30;
    }

    return Math.max(0, score);
  }

  async calculateMetaKeywordsScore(metaKeywordsAnalysis: MetaKeywordsAnalysis, siteKeywords: string[] ): Promise<number> {
    if (!metaKeywordsAnalysis.content) {
      return 0;
    }
  
    let score = 100;
  
    // Analyze keyword count
    if (metaKeywordsAnalysis.keywordCount === 0) {
      score -= 50;
    } else if (metaKeywordsAnalysis.keywordCount < 3) {
      score -= 30;
    } else if (metaKeywordsAnalysis.keywordCount > 10) {
      score -= 20 + (metaKeywordsAnalysis.keywordCount - 10) * 2; // Penalize for each additional keyword over 10
    }
  
    // Analyze keyword relevance
    const matchingKeywords = metaKeywordsAnalysis.keywords.filter(keyword => siteKeywords.includes(keyword));
    const matchPercentage = (matchingKeywords.length / metaKeywordsAnalysis.keywords.length) * 100;
  
    if (matchPercentage < 30) {
      score -= 40;
    } else if (matchPercentage < 50) {
      score -= 30;
    } else if (matchPercentage < 75) {
      score -= 15;
    }
  
    // Analyze keyword length and quality
    const averageKeywordLength = metaKeywordsAnalysis.keywords.reduce((sum, keyword) => sum + keyword.length, 0) / metaKeywordsAnalysis.keywordCount;
    if (averageKeywordLength < 4) {
      score -= 20; // Penalize for very short keywords
    }
  
    // Check for duplicate keywords
    const uniqueKeywords = new Set(metaKeywordsAnalysis.keywords);
    if (uniqueKeywords.size < metaKeywordsAnalysis.keywordCount) {
      score -= 15; // Penalize for duplicate keywords
    }
  
    // Check for keyword stuffing
    const contentLowerCase = metaKeywordsAnalysis.content.toLowerCase();
    const keywordDensity = metaKeywordsAnalysis.keywords.reduce((sum, keyword) => {
      const regex = new RegExp(keyword.toLowerCase(), 'g');
      return sum + (contentLowerCase.match(regex) || []).length;
    }, 0) / metaKeywordsAnalysis.content.split(' ').length;
  
    if (keywordDensity > 0.1) {
      score -= 30; // Penalize for keyword stuffing
    }
  
    return Math.max(0, Math.min(100, score)); // Ensure score is between 0 and 100
  }
  
  private calculateContentScore(content: string): number {
    if (!content) return 0;
  
    const text = cheerio.load(content).text();
    const wordCount = text.split(/\s+/).length;
    const linkDensity = Math.min(1, (content.match(/<a /g) || []).length / wordCount);
    const headingDensity = Math.min(1, (content.match(/<h[1-6]/g) || []).length / wordCount);
    const paragraphDensity = Math.min(1, (content.match(/<p/g) || []).length / wordCount);
  
    let score = wordCount;
    score *= (1 - linkDensity);
    score *= (1 + headingDensity * 0.5);
    score *= (1 + paragraphDensity * 0.5);
  
    if (content.includes('<article')) score *= 1.2;
    if (content.includes('<section')) score *= 1.1;
    if (content.includes('<figure')) score *= 1.05;
  
    return 1 + 99 / (1 + Math.exp(-score / 1000));
  }

   calculateHeadingScore(headingAnalysis: any): number {
    let score = 100;
    if (!headingAnalysis.headingCounts.hasIdealH1Count) {
      score -= 20;
    }
  
    Object.values(headingAnalysis.headingCounts.exceedsMaxCounts).forEach((exceeds: boolean) => {
      if (exceeds) score -= 5;
    });
  
    if (!headingAnalysis.headingOrder.isCorrectOrder) {
      score -= 15;
    }
  
    Object.values(headingAnalysis.headingContent).flat().forEach((heading: any) => {
      if (heading.exceedsMaxLength) score -= 2;
    });
  
    return Math.max(0, score);
  }

  calculateRelLinkScore(relLinkAnalysis: any): number {
    if (!relLinkAnalysis) return 0;

    let score = 100;

    if (relLinkAnalysis.isPartOfSeries) {
      if (!relLinkAnalysis.nextLink && !relLinkAnalysis.prevLink) {
        score -= 50; // Penalize if part of a series but missing both next and prev links
      } else if (!relLinkAnalysis.nextLink || !relLinkAnalysis.prevLink) {
        score -= 25; // Minor penalty if only one of next or prev is missing
      }
    }

    return score;
  }
  
  private calculateSEOBestPracticesScore($: cheerio.CheerioAPI, pageData: any): number {
    let score = 100;
  
    if (!$('title').length) score -= 10;
    if (!$('meta[name="description"]').length) score -= 10;
    if (!$('h1').length) score -= 10;
    if ($('h2').length < 2) score -= 5;
  
    const imagesWithoutAlt = $('img:not([alt])').length;
    score -= imagesWithoutAlt * 2;
  
    const internalLinks = $('a[href^="/"], a[href^="' + pageData.urlStructure.hostname + '"]').length;
    if (internalLinks < 5) score -= 10;
  
    return Math.max(0, score);
  }
  
  private calculateTechnicalSEOScore($: cheerio.CheerioAPI, pageData: any): number {
    let score = 100;
  
    if (!$('link[rel="canonical"]').length) score -= 10;
    if (!pageData.sitemapPresent) score -= 10;
    if (!pageData.robotsTxtPresent) score -= 10;
    if (pageData.urlStructure.protocol !== 'https:') score -= 20;
    if (!$('meta[name="viewport"]').length) score -= 10;

    if (pageData.xRobotsTagAnalysis) {
      if (pageData.xRobotsTagAnalysis.present) {
        const directives = pageData.xRobotsTagAnalysis.directives;
        if (directives.noindex) {
          score -= 20; // Significant impact on SEO
        }
        if (directives.nofollow) {
          score -= 10;
        }
        if (directives.none) {
          score -= 30; // Most restrictive, highest impact
        }
        if (directives.noarchive || directives.nosnippet || directives.notranslate || directives.noimageindex) {
          score -= 5; // Minor impact for each of these directives
        }
        if (directives.unavailable_after) {
          const unavailableDate = new Date(directives.unavailable_after);
          if (unavailableDate > new Date()) {
            score -= 15; // Content will become unavailable in the future
          }
        }
        if (pageData.xRobotsTagAnalysis.exceedsMaxLength) {
          score -= 5; // Penalize for exceeding max length
        }
      }
    } else {
      score -= 5; // Minor penalty for not having X-Robots-Tag (it's optional but can be beneficial)
    }
  
    return Math.max(0, score);
  }
  
  private calculateUserExperienceScore($: cheerio.CheerioAPI, pageData: any): number {
    let score = 100;
  
    const readabilityScore = this.calculateReadabilityScore(pageData.mainContent);
    score -= Math.max(0, 20 - readabilityScore);
  
    if (!$('*:contains("contact"), *:contains("email"), *:contains("phone")').length) score -= 10;
    if (!$('a[href*="facebook"], a[href*="twitter"], a[href*="linkedin"], a[href*="instagram"]').length) score -= 10;
    if (!$('nav, #nav, .nav, #menu, .menu').length) score -= 10;
  
    return Math.max(0, score);
  }
  
  private calculateMobileFriendlinessScore($: cheerio.CheerioAPI): number {
    let score = 100;
  
    if (!$('meta[name="viewport"]').length) score -= 50;
  
    const smallButtons = $('button, .button, [role="button"]').filter((_, el) => {
      const width = $(el).css('width');
      const height = $(el).css('height');
      return (width && parseInt(width) < 44) || (height && parseInt(height) < 44);
    }).length;
    score -= smallButtons * 5;
  
    const smallFonts = $('*').filter((_, el) => {
      const fontSize = $(el).css('font-size');
      return fontSize && parseInt(fontSize) < 12;
    }).length;
    score -= smallFonts * 2;
  
    return Math.max(0, score);
  }
  
  private calculateReadabilityScore(content: string): number {
    const text = cheerio.load(content).text();
    const words = text.split(/\s+/).length;
    const sentences = text.split(/[.!?]+/).length;
    const avgWordsPerSentence = words / sentences;
  
    return Math.max(0, 100 - Math.abs(avgWordsPerSentence - 15) * 5);
  }
      private calculateDirectoryStructureScore(directoryTree: any): number {
        if (!directoryTree) return 0;

        const analysis = this.directoryTreeAnalyzer.analyzeDirectoryTree(directoryTree);
        let score = 100;

        if ((analysis.maxDepth as number) > 5) score -= ((analysis.maxDepth as number) - 5) * 5;
        if ((analysis.averageFilesPerFolder as number) > 20) score -= ((analysis.averageFilesPerFolder as number) - 20) * 2;
        if ((analysis.totalFiles as number) > 1000) score -= 10;
        if ((analysis.totalFolders as number) > 100) score -= 10;

        const fileTypeVariety = Object.keys(analysis.fileTypeDistribution as Record<string, number>).length;
        if (fileTypeVariety < 3) score -= 10;
        if (fileTypeVariety > 10) score -= 5;

        return Math.max(0, score);
      }

      calculateTitleTagScore(titleTagAnalysis: TitleTagAnalysis): number {
        let score = 100;
        const config = this.crawlerConfigService.getTitleTagConfig();
    
        if (titleTagAnalysis.isTooShort) {
          score -= 20;
        } else if (titleTagAnalysis.isTooLong) {
          score -= 10;
        }
    
        if (titleTagAnalysis.isPixelWidthTooNarrow) {
          score -= 15;
        } else if (titleTagAnalysis.isPixelWidthTooWide) {
          score -= 15;
        }
    
        // Additional scoring criteria
        if (titleTagAnalysis.content.length < config.minLength / 2) {
          score -= 10; // Severely short title
        }
        if (titleTagAnalysis.content.length > config.maxLength * 1.5) {
          score -= 15; // Severely long title
        }
        if (!titleTagAnalysis.content.match(/[a-zA-Z]/)) {
          score -= 30; // Title doesn't contain any letters
        }
    
        return Math.max(0, Math.min(100, score));
      }


      calculateSecurityHeaderScore(securityHeaderAnalysis: SecurityHeaderAnalysis): number {
        if (!securityHeaderAnalysis.analyzed) {
          return 0;
        }
    
        let score = 100;
        const headers = securityHeaderAnalysis.headers;
    
        if (headers['X-XSS-Protection']) {
          score -= this.scoreXXSSProtection(headers['X-XSS-Protection'].value);
        }
        if (headers['X-Frame-Options']) {
          score -= this.scoreXFrameOptions(headers['X-Frame-Options'].value);
        }
        if (headers['Strict-Transport-Security']) {
          score -= this.scoreHSTS(headers['Strict-Transport-Security'].value);
        }
        if (headers['Content-Security-Policy']) {
          score -= this.scoreCSP(headers['Content-Security-Policy'].value);
        }
        if (headers['X-Content-Type-Options']) {
          score -= this.scoreXContentTypeOptions(headers['X-Content-Type-Options'].value);
        }
        if (headers['Referrer-Policy']) {
          score -= this.scoreReferrerPolicy(headers['Referrer-Policy'].value);
        }
    
        return Math.max(0, Math.min(100, score));
      }

      calculateWordCountScore(wordCount: number): number {
        const minWords = 300;
        const optimalWords = 1000;
        const maxWords = 2000;
      
        if (wordCount < minWords) {
          return (wordCount / minWords) * 100;
        } else if (wordCount <= optimalWords) {
          return 100;
        } else if (wordCount <= maxWords) {
          return 100 - ((wordCount - optimalWords) / (maxWords - optimalWords)) * 20;
        } else {
          return 80;
        }
      }

      calculateMetaDescriptionScore(metaDescriptionAnalysis: MetaDescriptionAnalysis): number {
        let score = 100;
        const config = this.crawlerConfigService.getMetaDescriptionConfig();
    
        if (metaDescriptionAnalysis.isTooShort) {
          score -= 20;
        } else if (metaDescriptionAnalysis.isTooLong) {
          score -= 10;
        }
    
        if (!metaDescriptionAnalysis.hasEnoughKeywords) {
          score -= 15;
        }
    
        // Additional scoring criteria
        if (metaDescriptionAnalysis.content.length < config.minLength / 2) {
          score -= 10; // Severely short meta description
        }
        if (metaDescriptionAnalysis.content.length > config.maxLength * 1.5) {
          score -= 15; // Severely long meta description
        }
        if (!metaDescriptionAnalysis.content.match(/[a-zA-Z]/)) {
          score -= 30; // Meta description doesn't contain any letters
        }
    
        return Math.max(0, Math.min(100, score));
      }
      
    
      private scoreXXSSProtection(value: string): number {
        return value === '1; mode=block' ? 0 : 10;
      }
    
      private scoreXFrameOptions(value: string): number {
        return ['DENY', 'SAMEORIGIN'].includes(value.toUpperCase()) ? 0 : 10;
      }
    
      private scoreHSTS(value: string): number {
        return value.includes('max-age=') && parseInt(value.split('max-age=')[1]) >= 31536000 ? 0 : 10;
      }
    
      private scoreCSP(value: string): number {
        return value ? 0 : 20; // Presence is good, but detailed analysis would be complex
      }
    
      private scoreXContentTypeOptions(value: string): number {
        return value.toLowerCase() === 'nosniff' ? 0 : 10;
      }
    
      private scoreReferrerPolicy(value: string): number {
        return ['no-referrer', 'strict-origin', 'strict-origin-when-cross-origin'].includes(value.toLowerCase()) ? 0 : 10;
      }

      calculateOpenGraphScore(analysis: OpenGraphAnalysis): number {
        let score = 0;
        if (analysis.isValid) score += 50;
        if (analysis.contentQualityAnalysis.titleQuality.isOptimal) score += 15;
        if (analysis.contentQualityAnalysis.descriptionQuality.isOptimal) score += 15;
        if (analysis.contentQualityAnalysis.imageQuality.isOptimal) score += 20;
        return score;
      }
      
      calculateTwitterCardScore(analysis: TwitterCardAnalysis): number {
        let score = 0;
        if (analysis.isValid) score += 50;
        if (analysis.contentQualityAnalysis.titleQuality.isOptimal) score += 15;
        if (analysis.contentQualityAnalysis.descriptionQuality.isOptimal) score += 15;
        if (analysis.contentQualityAnalysis.imageQuality.isOptimal) score += 20;
        return score;
      }
      
      calculateViewportScore(analysis: ViewportAnalysis): number {
        let score = 0;
        if (analysis.isPresent) score += 50;
        if (analysis.isRecommendedValue) score += 25;
        if (analysis.responsiveAnalysis.isResponsive) score += 25;
        return score;
      }

      calculateImageSEOScore(imageAnalysis: any[]): number {
        if (!imageAnalysis || imageAnalysis.length === 0) return 0;
    
        const totalImages = imageAnalysis.length;
        const imagesWithAlt = imageAnalysis.filter(img => img.altText.present).length;
        const imagesWithTitle = imageAnalysis.filter(img => img.titleAttribute.present).length;
        const optimizedImages = imageAnalysis.filter(img => img.seoAnalysis.fileSizeOptimized && img.seoAnalysis.dimensionsOptimal).length;
        const imagesWithoutTextIssues = imageAnalysis.filter(img => !img.seoAnalysis.textInImageIssue).length;
    
        const altTextScore = (imagesWithAlt / totalImages) * 100;
        const titleScore = (imagesWithTitle / totalImages) * 100;
        const optimizationScore = (optimizedImages / totalImages) * 100;
        const textIssueScore = (imagesWithoutTextIssues / totalImages) * 100;
    
        const overallScore = (altTextScore + titleScore + optimizationScore + textIssueScore) / 4;
        return Math.round(overallScore);
      }
      
    }

    interface OpenGraphAnalysis {
      properties: { property: string; content: string }[];
      missingRequiredProperties: string[];
      isValid: boolean;
      contentQualityAnalysis: OGContentQualityAnalysis;
      recommendations: string[];
    }
    
    interface TwitterCardAnalysis {
      properties: { name: string; content: string }[];
      missingRequiredProperties: string[];
      isValid: boolean;
      contentQualityAnalysis: TwitterContentQualityAnalysis;
      recommendations: string[];
    }
    
    interface ViewportAnalysis {
      content: string | undefined;
      isPresent: boolean;
      isRecommendedValue: boolean;
      properties: ViewportProperties;
      responsiveAnalysis: ResponsiveAnalysis;
      recommendations: string[];
    }

    interface OGContentQualityAnalysis {
      titleQuality: { length: number; isOptimal: boolean };
      descriptionQuality: { length: number; isOptimal: boolean };
      imageQuality: { url: string; dimensions: { width: number; height: number } | null; isOptimal: boolean };
    }
    
    interface TwitterContentQualityAnalysis {
      cardType: string;
      titleQuality: { length: number; isOptimal: boolean };
      descriptionQuality: { length: number; isOptimal: boolean };
      imageQuality: { url: string; dimensions: { width: number; height: number } | null; isOptimal: boolean };
    }
    
    interface ViewportProperties {
      [key: string]: string;
    }
    
    interface ResponsiveAnalysis {
      isResponsive: boolean;
      hasInitialScale: boolean;
      initialScaleValue: number | null;
    }

    interface SecurityHeaderAnalysis {
      analyzed: boolean;
      headers?: {
        [key: string]: {
          present: boolean;
          value: string;
        };
      };
    }

    interface TitleTagAnalysis {
      content: string;
      length: number;
      pixelWidth: number;
      isTooShort: boolean;
      isTooLong: boolean;
      isPixelWidthTooNarrow: boolean;
      isPixelWidthTooWide: boolean;
    }

    
interface MetaDescriptionAnalysis {
  content: string;
  length: number;
  isTooShort: boolean;
  isTooLong: boolean;
  keywordCount: number;
  hasEnoughKeywords: boolean;
}

interface MetaKeywordsAnalysis {
  content: string;
  keywordCount: number;
  keywords: string[];
  exceedsMaxCount: boolean;
}
 
                                                                                        C:\Workspace\Web\Ai Business grow project\Back_end\src\crawler\services\analysis\site-keyword-analyzer.service.ts 
import { Injectable } from '@nestjs/common';
import { KeywordExtractionService } from './keyword-extraction.service';
import { CrawlerConfigService } from '../../config/crawler-config.service';

@Injectable()
export class SiteKeywordAnalyzerService {
  private maxPagesToAnalyze: number;

  constructor(
    private keywordExtractionService: KeywordExtractionService,
    private crawlerConfigService: CrawlerConfigService
  ) {
    const config = this.crawlerConfigService.getKeywordExtractionConfig();
    this.maxPagesToAnalyze = config.maxPagesToAnalyze;
  }

  async analyzeSiteKeywords(pages: { url: string; pageData: any }[]): Promise<string[]> {
    const allKeywords: string[] = [];
    const analyzedPages = pages.slice(0, this.maxPagesToAnalyze);


    for (const page of analyzedPages) {
      const pageKeywords = this.keywordExtractionService.identifyImportantTerms(page?.pageData?.mainContent ? page.pageData.mainContent : '');
      allKeywords.push(...pageKeywords);
    }

    const keywordFrequency = this.calculateKeywordFrequency(allKeywords);
    const sortedKeywords = this.sortKeywordsByFrequency(keywordFrequency);

    return sortedKeywords.slice(0, this.crawlerConfigService.getKeywordExtractionConfig().maxKeywords);
  }

  private calculateKeywordFrequency(keywords: string[]): Map<string, number> {
    const frequency = new Map<string, number>();
    for (const keyword of keywords) {
      frequency.set(keyword, (frequency.get(keyword) || 0) + 1);
    }
    return frequency;
  }

  private sortKeywordsByFrequency(frequency: Map<string, number>): string[] {
    return Array.from(frequency.entries())
      .sort((a, b) => b[1] - a[1])
      .map(entry => entry[0]);
  }
}
 
                                                                                        C:\Workspace\Web\Ai Business grow project\Back_end\src\crawler\services\analysis\structured-data-analysis.service.ts 
import { Injectable, Logger } from '@nestjs/common';
import { CrawlerConfigService } from '../../config/crawler-config.service';
import * as cheerio from 'cheerio';
import { JSDOM } from 'jsdom';
import * as jsonld from 'jsonld';
import * as schemaOrgTypes from 'schema-dts';
import { Element } from 'domhandler';

@Injectable()
export class StructuredDataAnalysisService {
  private readonly logger = new Logger(StructuredDataAnalysisService.name);

  constructor(
    private readonly crawlerConfigService: CrawlerConfigService,
  ) {}


  async analyzeStructuredData($: cheerio.CheerioAPI, url: string): Promise<StructuredDataAnalysis> {
    const config = this.crawlerConfigService.getStructuredDataConfig();
    
    const jsonLdData = config.jsonLd.enabled ? await this.extractJsonLd($) : [];
    const microdataResults = config.microdata.enabled ? this.extractMicrodata($) : [];
    const rdfaResults = config.rdfa.enabled ? this.extractRdfa($) : [];

    const allStructuredData = [...jsonLdData, ...microdataResults, ...rdfaResults];
    
    const schemaTypeAnalysis = this.analyzeSchemaTypes(allStructuredData, config.schemaTypes);
    const richSnippetAnalysis = config.richSnippets.checkEligibility ? 
      this.analyzeRichSnippetEligibility(allStructuredData, config.richSnippets) : null;
    
    const validationResults = this.validateStructuredData(allStructuredData, config.validation);
    const competitiveAnalysis = config.competitive.enabled ? 
      this.performCompetitiveAnalysis(allStructuredData, config.competitive) : null;

    return {
      jsonLd: {
        data: jsonLdData,
        count: jsonLdData.length,
        valid: this.validateJsonLd(jsonLdData, config.jsonLd),
        errors: this.getJsonLdErrors(jsonLdData, config.jsonLd)
      },
      microdata: {
        data: microdataResults,
        count: microdataResults.length,
        nestingValid: this.validateMicrodataNesting(microdataResults, config.microdata),
        errors: this.getMicrodataErrors(microdataResults, config.microdata)
      },
      rdfa: {
        data: rdfaResults,
        count: rdfaResults.length,
        prefixesValid: this.validateRdfaPrefixes(rdfaResults, config.rdfa),
        errors: this.getRdfaErrors(rdfaResults, config.rdfa)
      },
      schemaTypes: schemaTypeAnalysis,
      richSnippets: richSnippetAnalysis,
      validation: validationResults,
      competitive: competitiveAnalysis,
      recommendations: this.generateRecommendations(allStructuredData, config),
      implementationScore: this.calculateImplementationScore(allStructuredData, config)
    };
  }

  // Add to the StructuredDataAnalysisService class

private validateJsonLd(data: any[], config: any): boolean {
    return data.every(item => {
      const hasRequiredProps = config.requiredProperties.every(prop => 
        Object.prototype.hasOwnProperty.call(item, prop)
      );
      const isValidSize = JSON.stringify(item).length <= config.maxSize;
      return hasRequiredProps && isValidSize;
    });
  }
  
  private getJsonLdErrors(data: any[], config: any): ValidationError[] {
    const errors: ValidationError[] = [];
    
    data.forEach((item, index) => {
      if (!item['@context']) {
        errors.push({
          type: 'JSON_LD_ERROR',
          message: `Missing @context in JSON-LD block ${index}`,
          severity: 'ERROR'
        });
      }
  
      if (!item['@type']) {
        errors.push({
          type: 'JSON_LD_ERROR',
          message: `Missing @type in JSON-LD block ${index}`,
          severity: 'ERROR'
        });
      }
  
      const size = JSON.stringify(item).length;
      if (size > config.maxSize) {
        errors.push({
          type: 'JSON_LD_ERROR',
          message: `JSON-LD block ${index} exceeds maximum size of ${config.maxSize} bytes`,
          severity: 'WARNING'
        });
      }
    });
  
    return errors;
  }
  
  private validateMicrodataNesting(data: any[], config: any): boolean {
    return data.every(item => {
      const nestingDepth = this.calculateNestingDepth(item);
      return nestingDepth <= config.maxNestedDepth;
    });
  }
  
  private calculateNestingDepth(item: any): number {
    let maxDepth = 0;
    
    const traverse = (obj: any, depth: number) => {
      if (depth > maxDepth) maxDepth = depth;
      
      if (obj && typeof obj === 'object') {
        Object.values(obj).forEach(value => {
          if (typeof value === 'object') {
            traverse(value, depth + 1);
          }
        });
      }
    };
  
    traverse(item, 0);
    return maxDepth;
  }
  
  private getMicrodataErrors(data: any[], config: any): ValidationError[] {
    const errors: ValidationError[] = [];
  
    data.forEach((item, index) => {
      if (!item.type) {
        errors.push({
          type: 'MICRODATA_ERROR',
          message: `Missing itemtype in microdata block ${index}`,
          severity: 'ERROR'
        });
      }
  
      const nestingDepth = this.calculateNestingDepth(item);
      if (nestingDepth > config.maxNestedDepth) {
        errors.push({
          type: 'MICRODATA_ERROR',
          message: `Microdata block ${index} exceeds maximum nesting depth of ${config.maxNestedDepth}`,
          severity: 'WARNING'
        });
      }
  
      if (Object.keys(item.properties || {}).length === 0) {
        errors.push({
          type: 'MICRODATA_ERROR',
          message: `No properties found in microdata block ${index}`,
          severity: 'WARNING'
        });
      }
    });
  
    return errors;
  }
  
  private validateRdfaPrefixes(data: any[], config: any): boolean {
    return data.every(item => {
      if (!item.prefix) return true;
      return config.requiredPrefixes.some(prefix => 
        item.prefix.includes(prefix)
      );
    });
  }
  
  private getRdfaErrors(data: any[], config: any): ValidationError[] {
    const errors: ValidationError[] = [];
  
    data.forEach((item, index) => {
      if (!item.property && !item.type) {
        errors.push({
          type: 'RDFA_ERROR',
          message: `Missing property or type in RDFa block ${index}`,
          severity: 'ERROR'
        });
      }
  
      if (item.prefix) {
        const hasRequiredPrefix = config.requiredPrefixes.some(prefix => 
          item.prefix.includes(prefix)
        );
        if (!hasRequiredPrefix) {
          errors.push({
            type: 'RDFA_ERROR',
            message: `Missing required prefix in RDFa block ${index}`,
            severity: 'WARNING'
          });
        }
      }
    });
  
    return errors;
  }
  
  private generateSnippetImprovements(eligibleSnippets: RichSnippetEligibility[], missingRequirements: RichSnippetRequirement[]): string[] {
    const improvements: string[] = [];
  
    // Suggest improvements for eligible snippets
    eligibleSnippets.forEach(snippet => {
      snippet.enhancementPossibilities.forEach(enhancement => {
        improvements.push(
          `Add ${enhancement.property} to ${snippet.type} to ${enhancement.recommendation}`
        );
      });
    });
  
    // Suggest fixes for missing requirements
    missingRequirements.forEach(requirement => {
      const missingProps = requirement.missing.join(', ');
      improvements.push(
        `Add required properties (${missingProps}) to make ${requirement.type} eligible for rich snippets`
      );
    });
  
    return improvements;
  }
  

  private async extractJsonLd($: cheerio.CheerioAPI): Promise<any[]> {
    const jsonLdScripts = $('script[type="application/ld+json"]');
    const results: any[] = [];
  
    for (let i = 0; i < jsonLdScripts.length; i++) {
      try {
        const content = $(jsonLdScripts[i]).html();
        if (content) {
          const parsed = JSON.parse(content);
          const expanded = await this.validateAndExpandJsonLd(parsed);
          if (expanded && this.validateSchemaType(expanded)) {
            results.push(expanded);
          }
        }
      } catch (error) {
        this.logger.warn(`Error parsing JSON-LD: ${error.message}`);
      }
    }
  
    return results;
  }

  private async validateAndExpandJsonLd(jsonLdData: any): Promise<any> {
    try {
      // Expand JSON-LD to normalize the data structure
      const expanded = await jsonld.expand(jsonLdData);
      // Compact against Schema.org context
      const compacted = await jsonld.compact(expanded, 'https://schema.org');
      return compacted;
    } catch (error) {
      this.logger.warn(`JSON-LD processing error: ${error.message}`);
      return null;
    }
  }
  
  private validateSchemaType(data: any): boolean {
    // Use schema-dts for type checking
    const type = data['@type'] as keyof typeof schemaOrgTypes;
    return type in schemaOrgTypes;
  }

  private extractMicrodata($: cheerio.CheerioAPI): any[] {
    const results: any[] = [];
    const itemscopes = $('[itemscope]');

    itemscopes.each((_, element) => {
      const itemtype = $(element).attr('itemtype');
      const properties = this.extractMicrodataProperties($, element);
      
      if (itemtype) {
        results.push({
          type: itemtype,
          properties: properties
        });
      }
    });

    return results;
  }

  private extractMicrodataProperties($: cheerio.CheerioAPI, element: Element): Record<string, any> {
    const properties: Record<string, any> = {};
    const itemprops = $(element).find('[itemprop]');

    itemprops.each((_, prop) => {
      const name = $(prop).attr('itemprop');
      if (name) {
        properties[name] = this.extractMicrodataValue($, prop);
      }
    });

    return properties;
  }

  private extractMicrodataValue($: cheerio.CheerioAPI, element: Element): any {
    const $element = $(element);
    
    if ($element.attr('itemscope') !== undefined) {
      return this.extractMicrodataProperties($, element);
    }

    if ($element.attr('content')) {
      return $element.attr('content');
    }

    if ($element.attr('datetime')) {
      return $element.attr('datetime');
    }

    return $element.text().trim();
  }

  private extractRdfa($: cheerio.CheerioAPI): any[] {
    const results: any[] = [];
    const rdfaElements = $('[typeof],[property]');

    rdfaElements.each((_, element) => {
      const type = $(element).attr('typeof');
      const property = $(element).attr('property');
      
      if (type || property) {
        results.push({
          type: type || null,
          property: property || null,
          content: $(element).attr('content') || $(element).text().trim(),
          resource: $(element).attr('resource'),
          prefix: this.extractRdfaPrefix($(element))
        });
      }
    });

    return results;
  }

  private extractRdfaPrefix($element: cheerio.Cheerio<Element>): string | null {
    let current = $element;
    while (current.length) {
      const prefix = current.attr('prefix');
      if (prefix) return prefix;
      current = current.parent();
    }
    return null;
  }

  private validateStructuredData(data: any[], config: any): ValidationResults {
    const errors: ValidationError[] = [];
    const warnings: ValidationWarning[] = [];

    data.forEach(item => {
      // Validate against Schema.org
      if (config.validateAgainstSchemaOrg) {
        const schemaErrors = this.validateAgainstSchemaOrg(item);
        errors.push(...schemaErrors);
      }

      // Validate against Google requirements
      if (config.validateAgainstGoogleRequirements) {
        const googleErrors = this.validateAgainstGoogleRequirements(item);
        errors.push(...googleErrors);
      }
    });

    return {
      isValid: errors.length === 0,
      errors,
      warnings,
      errorCount: errors.length,
      warningCount: warnings.length
    };
  }

  private validateAgainstSchemaOrg(item: any): ValidationError[] {
    const errors: ValidationError[] = [];
    
    if (!item['@type']) {
      errors.push({
        type: 'SCHEMA_ERROR',
        message: 'Missing required @type property',
        severity: 'ERROR'
      });
    }

    // Add more Schema.org validation rules
    return errors;
  }

  private validateAgainstGoogleRequirements(item: any): ValidationError[] {
    const errors: ValidationError[] = [];
    const type = item['@type'];

    if (type) {
      switch (type) {
        case 'Product':
          if (!item.name || !item.offers) {
            errors.push({
              type: 'GOOGLE_REQUIREMENT',
              message: 'Product markup requires name and offers properties',
              severity: 'ERROR'
            });
          }
          break;
        // Add more Google-specific requirements for other types
      }
    }

    return errors;
  }

  private analyzeSchemaTypes(data: any[], config: any): SchemaTypeAnalysis {
    const types = new Set<string>();
    const deprecated = new Set<string>();
    const missing = new Set<string>(config.preferredTypes);
  
    data.forEach(item => {
      const type = item['@type'] || item.type;
      if (type) {
        types.add(type);
        missing.delete(type);
        if (this.isDeprecatedSchema(type)) {
          deprecated.add(type);
        }
      }
    });
  
    return {
      identifiedTypes: Array.from(types),
      deprecatedTypes: Array.from(deprecated),
      missingRecommendedTypes: Array.from(missing) as string[],
      coverage: this.calculateTypeCoverage(types, config.preferredTypes)
    };
  }

  private isDeprecatedSchema(type: string): boolean {
    // Add logic to check against a list of deprecated schema types
    const deprecatedTypes = ['Store', 'DataType'];
    return deprecatedTypes.includes(type);
  }

  private calculateTypeCoverage(found: Set<string>, preferred: string[]): number {
    const intersection = preferred.filter(type => found.has(type));
    return intersection.length / preferred.length;
  }

  private analyzeRichSnippetEligibility(data: any[], config: any): RichSnippetAnalysis {
    const eligibleSnippets: RichSnippetEligibility[] = [];
    const missingRequirements: RichSnippetRequirement[] = [];

    data.forEach(item => {
      const type = item['@type'] || item.type;
      if (type && config.types.includes(type)) {
        const requirements = this.checkRichSnippetRequirements(type, item);
        if (requirements.isEligible) {
          eligibleSnippets.push({
            type,
            confidence: requirements.confidence,
            enhancementPossibilities: requirements.enhancementPossibilities
          });
        } else {
          missingRequirements.push({
            type,
            missing: requirements.missing
          });
        }
      }
    });

    return {
      eligibleSnippets,
      missingRequirements,
      potentialImprovements: this.generateSnippetImprovements(eligibleSnippets, missingRequirements)
    };
  }

  private checkRichSnippetRequirements(type: string, data: any): RichSnippetRequirementCheck {
    const requirements: RichSnippetRequirementCheck = {
      isEligible: false,
      confidence: 0,
      missing: [],
      enhancementPossibilities: []
    };

    switch (type) {
      case 'Product':
        requirements.isEligible = this.checkProductRequirements(data, requirements);
        break;
      case 'Article':
        requirements.isEligible = this.checkArticleRequirements(data, requirements);
        break;
      // Add more type-specific requirement checks
    }

    return requirements;
  }

  private checkProductRequirements(data: any, requirements: RichSnippetRequirementCheck): boolean {
    let isEligible = true;
    const required = ['name', 'offers', 'image'];
    const recommended = ['description', 'review', 'aggregateRating'];

    required.forEach(prop => {
      if (!data[prop]) {
        isEligible = false;
        requirements.missing.push(prop);
      }
    });

    recommended.forEach(prop => {
      if (!data[prop]) {
        requirements.enhancementPossibilities.push({
          property: prop,
          impact: 'MEDIUM',
          recommendation: `Add ${prop} to improve rich snippet chances`
        });
      }
    });

    requirements.confidence = isEligible ? 0.8 : 0.4;
    return isEligible;
  }

  private checkArticleRequirements(data: any, requirements: RichSnippetRequirementCheck): boolean {
    // Similar to checkProductRequirements but for Article type
    return true;
  }

  private performCompetitiveAnalysis(data: any[], config: any): CompetitiveAnalysis {
    return {
      industryStandardsAlignment: this.calculateIndustryAlignment(data, config.industryStandards),
      comprehensivenessScore: this.calculateComprehensivenessScore(data),
      uniqueFeatures: this.identifyUniqueFeatures(data),
      improvements: this.suggestCompetitiveImprovements(data, config)
    };
  }

  private calculateIndustryAlignment(data: any[], standards: string[]): number {
    const implementedStandards = standards.filter(standard => 
      data.some(item => item['@type'] === standard || item.type === standard)
    );
    return implementedStandards.length / standards.length;
  }

  private calculateComprehensivenessScore(data: any[]): number {
    const maxPossibleProperties = {
      Product: 15,
      Article: 12,
      LocalBusiness: 20,
      Recipe: 18,
      // Add more type benchmarks
    };
  
    let totalScore = 0;
    data.forEach(item => {
      const type = item['@type'];
      if (type && maxPossibleProperties[type]) {
        const implementedProps = Object.keys(item).length;
        totalScore += implementedProps / maxPossibleProperties[type];
      }
    });
  
    return data.length > 0 ? totalScore / data.length : 0;
  }
  
  private identifyUniqueFeatures(data: any[]): string[] {
    const uniqueFeatures: string[] = [];
    const commonProperties = new Set(['@type', '@context', 'name', 'description']);
  
    data.forEach(item => {
      Object.keys(item).forEach(prop => {
        if (!commonProperties.has(prop) && this.isAdvancedProperty(prop)) {
          uniqueFeatures.push(`Advanced ${item['@type']} property: ${prop}`);
        }
      });
    });
  
    return [...new Set(uniqueFeatures)];
  }
  
  private isAdvancedProperty(prop: string): boolean {
    const advancedProps = [
      'aggregateRating',
      'review',
      'mainEntityOfPage',
      'potentialAction',
      'sameAs',
      'identifier'
    ];
    return advancedProps.includes(prop);
  }
  
  private suggestCompetitiveImprovements(data: any[], config: any): string[] {
    const improvements: string[] = [];
    const implementedTypes = new Set(data.map(item => item['@type']));
  
    // Check for missing industry standards
    config.industryStandards.forEach(standard => {
      if (!implementedTypes.has(standard)) {
        improvements.push(`Implement ${standard} schema to match industry standards`);
      }
    });
  
    // Check for advanced property opportunities
    data.forEach(item => {
      const type = item['@type'];
      const advancedFeatures = this.getAdvancedFeatures(type);
      advancedFeatures.forEach(feature => {
        if (!item[feature.property]) {
          improvements.push(`Add ${feature.property} to ${type} to gain competitive advantage: ${feature.benefit}`);
        }
      });
    });
  
    return improvements;
  }
  
  private getAdvancedFeatures(type: string): Array<{property: string, benefit: string}> {
    const features = {
      Product: [
        { property: 'aggregateRating', benefit: 'Show star ratings in search results' },
        { property: 'review', benefit: 'Display customer reviews in rich snippets' },
        { property: 'brand', benefit: 'Enhance product visibility with brand information' }
      ],
      Article: [
        { property: 'author', benefit: 'Establish content authority' },
        { property: 'dateModified', benefit: 'Show content freshness' },
        { property: 'speakable', benefit: 'Optimize for voice search' }
      ],
      // Add more type-specific advanced features
    };
  
    return features[type] || [];
  }

  private calculateImplementationScore(data: any[], config: any): number {
    const weights = {
      presence: 0.2,
      validity: 0.3,
      richSnippetEligibility: 0.3,
      competitiveness: 0.2
    };

    const presenceScore = data.length > 0 ? 1 : 0;
    const validityScore = this.calculateValidityScore(data);
    const richSnippetScore = this.calculateRichSnippetScore(data);
    const competitivenessScore = this.calculateCompetitivenessScore(data, config);

    return (
      presenceScore * weights.presence +
      validityScore * weights.validity +
      richSnippetScore * weights.richSnippetEligibility +
      competitivenessScore * weights.competitiveness
    );
  }

  private calculateValidityScore(data: any[]): number {
    let validItems = 0;
    data.forEach(item => {
      if (item['@type'] && item['@context']) validItems++;
    });
    return data.length > 0 ? validItems / data.length : 0;
  }

  private calculateRichSnippetScore(data: any[]): number {
    const eligibleTypes = ['Product', 'Article', 'Recipe', 'Review', 'Event'];
    let eligibleItems = 0;
    data.forEach(item => {
      if (eligibleTypes.includes(item['@type'])) eligibleItems++;
    });
    return data.length > 0 ? eligibleItems / data.length : 0;
  }

  private calculateCompetitivenessScore(data: any[], config: any): number {
    const implementedStandards = config.competitive.industryStandards.filter(standard =>
      data.some(item => item['@type'] === standard)
    );
    return implementedStandards.length / config.competitive.industryStandards.length;
  }

  private generateRecommendations(data: any[], config: any): StructuredDataRecommendation[] {
    const recommendations: StructuredDataRecommendation[] = [];

    // Check for missing essential schemas
    const implementedTypes = new Set(data.map(item => item['@type']));
    config.schemaTypes.preferredTypes.forEach(type => {
      if (!implementedTypes.has(type)) {
        recommendations.push({
          type: 'MISSING_SCHEMA',
          priority: 'HIGH',
          message: `Implement ${type} schema to improve search visibility`,
          impact: 'HIGH',
          implementation: this.getSchemaTemplate(type)
        });
      }
    });

    // Check for enhancement opportunities
    data.forEach(item => {
      const enhancements = this.findEnhancementOpportunities(item);
      recommendations.push(...enhancements);
    });

    // Add competitive recommendations
    if (config.competitive.enabled) {
      const competitiveRecs = this.generateCompetitiveRecommendations(data, config);
      recommendations.push(...competitiveRecs);
    }

    return recommendations;
  }

  private findEnhancementOpportunities(item: any): StructuredDataRecommendation[] {
    const opportunities: StructuredDataRecommendation[] = [];
    const type = item['@type'];

    if (type) {
      const template = this.getSchemaTemplate(type);
      const missingProperties = this.findMissingProperties(item, template);

      missingProperties.forEach(prop => {
        opportunities.push({
          type: 'ENHANCEMENT',
          priority: this.getPropertyPriority(type, prop),
          message: `Add ${prop} to ${type} schema for better search presentation`,
          impact: this.getPropertyImpact(type, prop),
          implementation: this.getPropertyTemplate(type, prop)
        });
      });
    }

    return opportunities;
  }

  private getSchemaTemplate(type: string): any {
    const templates: Record<string, any> = {
      Product: {
        '@type': 'Product',
        name: 'Product Name',
        description: 'Product Description',
        image: 'Product Image URL',
        offers: {
          '@type': 'Offer',
          price: 'Price',
          priceCurrency: 'Currency Code'
        }
      },
      // Add more templates for other types
    };

    return templates[type] || {};
  }

  private findMissingProperties(item: any, template: any): string[] {
    const missing: string[] = [];
    Object.keys(template).forEach(key => {
      if (!item[key]) missing.push(key);
    });
    return missing;
  }

  private getPropertyPriority(type: string, property: string): 'HIGH' | 'MEDIUM' | 'LOW' {
    const highPriorityProps: Record<string, string[]> = {
      Product: ['name', 'offers', 'image'],
      Article: ['headline', 'author', 'datePublished'],
      // Add more type-specific priority properties
    };

    return highPriorityProps[type]?.includes(property) ? 'HIGH' : 'MEDIUM';
  }

  private getPropertyImpact(type: string, property: string): 'HIGH' | 'MEDIUM' | 'LOW' {
    const highImpactProps: Record<string, string[]> = {
      Product: ['offers', 'aggregateRating'],
      Article: ['headline', 'datePublished'],
      // Add more type-specific impact properties
    };

    return highImpactProps[type]?.includes(property) ? 'HIGH' : 'MEDIUM';
  }

  private getPropertyTemplate(type: string, property: string): string {
    return `"${property}": "Add ${property} value here"`;
  }

  private generateCompetitiveRecommendations(data: any[], config: any): StructuredDataRecommendation[] {
    const recommendations: StructuredDataRecommendation[] = [];
    const implementedTypes = new Set(data.map(item => item['@type']));

    config.competitive.industryStandards.forEach(standard => {
      if (!implementedTypes.has(standard)) {
        recommendations.push({
          type: 'COMPETITIVE',
          priority: 'HIGH',
          message: `Implement ${standard} schema to match industry standards`,
          impact: 'HIGH',
          implementation: this.getSchemaTemplate(standard)
        });
      }
    });

    return recommendations;
  }
}

interface StructuredDataAnalysis {
  jsonLd: {
    data: any[];
    count: number;
    valid: boolean;
    errors: ValidationError[];
  };
  microdata: {
    data: any[];
    count: number;
    nestingValid: boolean;
    errors: ValidationError[];
  };
  rdfa: {
    data: any[];
    count: number;
    prefixesValid: boolean;
    errors: ValidationError[];
  };
  schemaTypes: SchemaTypeAnalysis;
  richSnippets: RichSnippetAnalysis | null;
  validation: ValidationResults;
  competitive: CompetitiveAnalysis | null;
  recommendations: StructuredDataRecommendation[];
  implementationScore: number;
}

interface SchemaTypeAnalysis {
  identifiedTypes: string[];
  deprecatedTypes: string[];
  missingRecommendedTypes: string[];
  coverage: number;
}

interface RichSnippetAnalysis {
  eligibleSnippets: RichSnippetEligibility[];
  missingRequirements: RichSnippetRequirement[];
  potentialImprovements: string[];
}

interface RichSnippetEligibility {
  type: string;
  confidence: number;
  enhancementPossibilities: EnhancementPossibility[];
}

interface RichSnippetRequirement {
  type: string;
  missing: string[];
}

interface RichSnippetRequirementCheck {
  isEligible: boolean;
  confidence: number;
  missing: string[];
  enhancementPossibilities: EnhancementPossibility[];
}

interface EnhancementPossibility {
  property: string;
  impact: 'HIGH' | 'MEDIUM' | 'LOW';
  recommendation: string;
}

interface ValidationResults {
  isValid: boolean;
  errors: ValidationError[];
  warnings: ValidationWarning[];
  errorCount: number;
  warningCount: number;
}

interface ValidationError {
  type: string;
  message: string;
  severity: 'ERROR' | 'WARNING';
}

interface ValidationWarning {
  type: string;
  message: string;
  impact: 'HIGH' | 'MEDIUM' | 'LOW';
}

interface CompetitiveAnalysis {
  industryStandardsAlignment: number;
  comprehensivenessScore: number;
  uniqueFeatures: string[];
  improvements: string[];
}

interface StructuredDataRecommendation {
  type: 'MISSING_SCHEMA' | 'ENHANCEMENT' | 'COMPETITIVE';
  priority: 'HIGH' | 'MEDIUM' | 'LOW';
  message: string;
  impact: 'HIGH' | 'MEDIUM' | 'LOW';
  implementation: string | any;
} 
                                                                                        C:\Workspace\Web\Ai Business grow project\Back_end\src\crawler\services\analysis\technical-mobile-analysis.service.ts 
import { Injectable } from '@nestjs/common';
import { CrawlerConfigService } from '../../config/crawler-config.service';
import { JSDOM } from 'jsdom';
import { MobileFriendlinessAnalysis } from '../../interfaces/technical-seo.interface';

@Injectable()
export class TechnicalMobileAnalysisService {
  constructor(private readonly crawlerConfigService: CrawlerConfigService) {}

  async analyzeMobileFriendliness(html: string): Promise<MobileFriendlinessAnalysis> {
    const config = this.crawlerConfigService.getTechnicalSeoConfig().mobileFriendliness;
    const dom = new JSDOM(html);
    const document = dom.window.document;

    const viewportAnalysis = this.analyzeViewport(document);
    const touchElementsAnalysis = this.analyzeTouchElements(document);
    const fontSizeAnalysis = this.analyzeFontSize(document);
    const contentWidthAnalysis = this.analyzeContentWidth(document);
    const mediaQueriesAnalysis = this.analyzeMediaQueries(document);

    const score = this.calculateMobileFriendlinessScore(
      viewportAnalysis,
      touchElementsAnalysis,
      fontSizeAnalysis,
      contentWidthAnalysis,
      mediaQueriesAnalysis
    );

    const recommendations = this.generateMobileRecommendations(
      viewportAnalysis,
      touchElementsAnalysis,
      fontSizeAnalysis,
      contentWidthAnalysis,
      mediaQueriesAnalysis
    );

    return {
      viewport: viewportAnalysis,
      touchElements: touchElementsAnalysis,
      fontSize: fontSizeAnalysis,
      contentWidth: contentWidthAnalysis,
      mediaQueries: mediaQueriesAnalysis,
      score,
      recommendations
    };
  }

  private analyzeViewport(document: Document) {
    const viewport = document.querySelector('meta[name="viewport"]');
    const viewportContent = viewport?.getAttribute('content') || '';
    const properties = new Map(
      viewportContent.split(',').map(prop => {
        const [key, value] = prop.trim().split('=');
        return [key, value];
      })
    );

    const issues = [];
    if (!viewport) {
      issues.push('Missing viewport meta tag');
    }
    if (!properties.has('width') || properties.get('width') !== 'device-width') {
      issues.push('Viewport width not set to device-width');
    }
    if (!properties.has('initial-scale') || properties.get('initial-scale') !== '1.0') {
      issues.push('Initial scale not set to 1.0');
    }

    return {
      hasViewport: !!viewport,
      isResponsive: properties.get('width') === 'device-width',
      viewportContent,
      issues
    };
  }

  private analyzeTouchElements(document: Document) {
    const config = this.crawlerConfigService.getTechnicalSeoConfig().mobileFriendliness;
    const interactiveElements = document.querySelectorAll('a, button, input, select, textarea');
    const elementsWithSmallTargets = [];
    const window = document.defaultView;

    interactiveElements.forEach((element: Element) => {
        const rect = element.getBoundingClientRect();
        const computedStyle = window.getComputedStyle(element);
        const spacing = this.calculateElementSpacing(element, computedStyle);

        if (rect.width < config.viewportAnalysis.minTouchTargetSize || 
            rect.height < config.viewportAnalysis.minTouchTargetSize ||
            spacing < config.viewportAnalysis.minTouchTargetSpacing) {
            elementsWithSmallTargets.push({
                selector: this.generateSelector(element),
                size: Math.min(rect.width, rect.height),
                spacing
            });
        }
    });

    return {
        elementsWithSmallTargets,
        totalIssues: elementsWithSmallTargets.length
    };
}

  private analyzeFontSize(document: Document) {
    const config = this.crawlerConfigService.getTechnicalSeoConfig().mobileFriendliness;
    const textElements = document.querySelectorAll('p, span, div, a, button, input, label');
    const tooSmallElements = [];
    const window = document.defaultView;

    textElements.forEach((element: Element) => {
      const computedStyle = window.getComputedStyle(element);
      const fontSize = parseFloat(computedStyle.fontSize);

      if (fontSize < config.viewportAnalysis.minFontSize) {
        tooSmallElements.push({
          selector: this.generateSelector(element),
          size: fontSize
        });
      }
    });

    return {
      tooSmallElements,
      totalIssues: tooSmallElements.length
    };
  }

  private analyzeContentWidth(document: Document) {
    const config = this.crawlerConfigService.getTechnicalSeoConfig().mobileFriendliness;
    const body = document.body;
    const html = document.documentElement;

    const contentWidth = Math.max(
      body.scrollWidth,
      body.offsetWidth,
      html.clientWidth,
      html.scrollWidth,
      html.offsetWidth
    );

    const viewportWidth = html.clientWidth;

    return {
      exceedsViewport: contentWidth > config.viewportAnalysis.maxContentWidth,
      horizontalScrolling: contentWidth > viewportWidth,
      contentWidth,
      viewportWidth
    };
  }

  private analyzeMediaQueries(document: Document) {
    const styleSheets = Array.from(document.styleSheets);
    const breakpoints = new Set<number>();
    const responsiveImages = document.querySelectorAll('img[srcset], picture source');

    styleSheets.forEach(stylesheet => {
        try {
            const rules = Array.from(stylesheet.cssRules);
            rules.forEach(rule => {
                if (rule instanceof CSSMediaRule) {
                    const mediaText = rule.media.mediaText;
                    const widthMatch = mediaText.match(/\(min-width:\s*(\d+)px\)/);
                    if (widthMatch) {
                        breakpoints.add(parseInt(widthMatch[1]));
                    }
                }
            });
        } catch (e) {
            // Handle cross-origin stylesheet errors
        }
    });

    const commonBreakpoints = [320, 768, 1024, 1440];
    const missingBreakpoints = commonBreakpoints.filter(bp => !breakpoints.has(bp));

    return {
        hasResponsiveImages: responsiveImages.length > 0,
        responsiveBreakpoints: Array.from(breakpoints).sort((a, b) => a - b),
        missingBreakpoints: missingBreakpoints.map(bp => `${bp}px`)
    };
}

  private calculateElementSpacing(element: Element, computedStyle: CSSStyleDeclaration): number {
    const margin = parseFloat(computedStyle.marginTop) +
                  parseFloat(computedStyle.marginBottom) +
                  parseFloat(computedStyle.marginLeft) +
                  parseFloat(computedStyle.marginRight);

    const padding = parseFloat(computedStyle.paddingTop) +
                   parseFloat(computedStyle.paddingBottom) +
                   parseFloat(computedStyle.paddingLeft) +
                   parseFloat(computedStyle.paddingRight);

    return Math.min(margin, padding);
  }

  private generateSelector(element: Element): string {
    const path = [];
    let current = element;

    while (current && current.nodeType === 1) { // Use 1 instead of Node.ELEMENT_NODE
        let selector = current.nodeName.toLowerCase();
        
        if (current.id) {
            selector += `#${current.id}`;
            path.unshift(selector);
            break;
        }
        
        if (current.className) {
            selector += `.${current.className.trim().replace(/\s+/g, '.')}`;
        }
        
        path.unshift(selector);
        current = current.parentElement;
    }

    return path.join(' > ');
}

  private calculateMobileFriendlinessScore(
    viewport: any,
    touchElements: any,
    fontSize: any,
    contentWidth: any,
    mediaQueries: any
  ): number {
    let score = 100;

    // Viewport issues
    if (!viewport.hasViewport) score -= 30;
    if (!viewport.isResponsive) score -= 20;
    viewport.issues.forEach(() => score -= 5);

    // Touch target issues
    score -= Math.min(touchElements.totalIssues * 2, 20);

    // Font size issues
    score -= Math.min(fontSize.totalIssues * 2, 15);

    // Content width issues
    if (contentWidth.exceedsViewport) score -= 10;
    if (contentWidth.horizontalScrolling) score -= 15;

    // Media queries
    if (!mediaQueries.hasResponsiveImages) score -= 10;
    score -= Math.min(mediaQueries.missingBreakpoints.length * 2, 10);

    return Math.max(0, Math.min(100, score));
  }

  private generateMobileRecommendations(
    viewport: any,
    touchElements: any,
    fontSize: any,
    contentWidth: any,
    mediaQueries: any
  ): string[] {
    const recommendations: string[] = [];

    // Viewport recommendations
    viewport.issues.forEach(issue => recommendations.push(issue));

    // Touch target recommendations
    if (touchElements.totalIssues > 0) {
      recommendations.push(
        `Increase touch target size for ${touchElements.totalIssues} elements to improve mobile usability`
      );
    }

    // Font size recommendations
    if (fontSize.totalIssues > 0) {
      recommendations.push(
        `Increase font size for ${fontSize.totalIssues} elements to improve readability on mobile devices`
      );
    }

    // Content width recommendations
    if (contentWidth.exceedsViewport) {
      recommendations.push(
        `Content width (${contentWidth.contentWidth}px) exceeds recommended maximum width. Consider implementing responsive design`
      );
    }

    // Media queries recommendations
    if (!mediaQueries.hasResponsiveImages) {
        recommendations.push('Implement responsive images using srcset and sizes attributes');
      }
      if (mediaQueries.missingBreakpoints.length > 0) {
        recommendations.push(
          `Add media queries for common breakpoints: ${mediaQueries.missingBreakpoints.join(', ')}`
        );
      }
  
      return recommendations;
    }
  } 
                                                                                        C:\Workspace\Web\Ai Business grow project\Back_end\src\crawler\services\analysis\technical-seo-analysis.service.ts 
import { Injectable, Logger } from '@nestjs/common';
import { CrawlerConfigService } from '../../config/crawler-config.service';
import * as zlib from 'zlib';
import { promisify } from 'util';
import { AxiosResponse } from 'axios';
import { TechnicalMobileAnalysisService } from './technical-mobile-analysis.service';
import { AmpAnalysisService } from './amp-analysis.service';
import { ResourceUsageAnalysisService } from './resource-usage-analysis.service';
import { CookieAnalysisService } from './cookie-analysis.service';



const gzipDecompress = promisify(zlib.gunzip);
const brotliDecompress = promisify(zlib.brotliDecompress);

interface PerformanceMetrics {
  ttfb: number;
  domLoadTime: number;
  fullLoadTime: number;
  firstContentfulPaint: number;
  speedIndex: number;
  resourceLoadTimes: ResourceTiming[];
}

interface ResourceTiming {
  url: string;
  type: string;
  duration: number;
  size: number;
  protocol: string;
}

interface CompressionAnalysis {
  type: string;
  originalSize: number;
  compressedSize: number;
  compressionRatio: number;
  isOptimal: boolean;
  suggestions: string[];
}

interface Http2Analysis {
  enabled: boolean;
  serverPushEnabled: boolean;
  multiplexingUsed: boolean;
  concurrentStreams: number;
  connectionEfficiency: number;
  suggestions: string[];
}

interface PageSizeAnalysis {
  totalSize: number;
  htmlSize: number;
  resourceSizes: {
    js: number;
    css: number;
    images: number;
    fonts: number;
    other: number;
  };
  exceedsLimits: boolean;
  suggestions: string[];
}

@Injectable()
export class TechnicalSeoAnalysisService {
  private readonly logger = new Logger(TechnicalSeoAnalysisService.name);
  private config: any;

  constructor(
    private readonly crawlerConfigService: CrawlerConfigService,
    private readonly mobileAnalysisService: TechnicalMobileAnalysisService,
    private readonly ampAnalysisService: AmpAnalysisService,
    private readonly resourceUsageAnalysisService: ResourceUsageAnalysisService,
    private readonly cookieAnalysisService: CookieAnalysisService
  ) {
    this.config = this.crawlerConfigService.getTechnicalSeoConfig();
    
  }

  async analyzePerformance(response: AxiosResponse, timing: any): Promise<PerformanceMetrics> {
    const startTime = timing.startTime || 0;
    const ttfb = timing.ttfb - startTime || 0;
    const domLoadTime = timing.domContentLoadedTime - startTime || 0;
    const fullLoadTime = timing.loadTime - startTime || 0;
    const resourceTimings = this.analyzeResourceTimings(response, timing.resourceTimings || []);

    return {
      ttfb,
      domLoadTime,
      fullLoadTime,
      firstContentfulPaint: this.calculateFirstContentfulPaint(timing),
      speedIndex: this.calculateSpeedIndex(timing),
      resourceLoadTimes: resourceTimings
    };
  }

  private analyzeResourceTimings(response: AxiosResponse, timings: any[]): ResourceTiming[] {
    return timings.map(timing => ({
      url: timing.url,
      type: this.getResourceType(timing.url),
      duration: timing.duration,
      size: timing.size || 0,
      protocol: timing.nextHopProtocol || response.request.protocol
    }));
  }

  private getResourceType(url: string): string {
    const extension = url.split('.').pop()?.toLowerCase();
    const typeMap = {
      js: 'javascript',
      css: 'stylesheet',
      jpg: 'image',
      jpeg: 'image',
      png: 'image',
      gif: 'image',
      webp: 'image',
      woff: 'font',
      woff2: 'font',
      ttf: 'font',
      eot: 'font'
    };
    return typeMap[extension] || 'other';
  }

  private calculateFirstContentfulPaint(timing: any): number {
    // Estimate FCP based on available metrics
    return timing.firstContentfulPaint || timing.domContentLoadedTime || 0;
  }

  private calculateSpeedIndex(timing: any): number {
    // Simplified Speed Index calculation
    const visuallyComplete = timing.loadTime || 0;
    return Math.round((timing.firstContentfulPaint + visuallyComplete) / 2);
  }

  async analyzeCompression(response: AxiosResponse): Promise<CompressionAnalysis> {
    const contentEncoding = response.headers['content-encoding'];
    const originalSize = response.data.length;
    let compressedSize = response.headers['content-length'] ? 
      parseInt(response.headers['content-length']) : originalSize;

    const decompressedContent = await this.decompressContent(response.data, contentEncoding);
    const compressionRatio = compressedSize / decompressedContent.length;

    const suggestions = this.generateCompressionSuggestions(
      contentEncoding,
      compressionRatio,
      originalSize
    );

    return {
      type: contentEncoding || 'none',
      originalSize,
      compressedSize,
      compressionRatio,
      isOptimal: compressionRatio <= this.config.compression.minCompressionRatio,
      suggestions
    };
  }

  private async decompressContent(content: Buffer, encoding: string): Promise<Buffer> {
    try {
      switch (encoding?.toLowerCase()) {
        case 'gzip':
          return await gzipDecompress(content);
        case 'br':
          return await brotliDecompress(content);
        default:
          return content;
      }
    } catch (error) {
      this.logger.error(`Error decompressing content: ${error.message}`);
      return content;
    }
  }

  private generateCompressionSuggestions(
    encoding: string,
    ratio: number,
    size: number
  ): string[] {
    const suggestions = [];
    const { minCompressionRatio, preferredEncodings } = this.config.compression;

    if (!encoding) {
      suggestions.push('Enable compression (Gzip or Brotli) for better performance');
    }

    if (encoding && !preferredEncodings.includes(encoding)) {
      suggestions.push(`Consider using ${preferredEncodings[0]} for better compression`);
    }

    if (ratio > minCompressionRatio) {
      suggestions.push('Current compression ratio is suboptimal. Consider adjusting compression settings');
    }

    if (size > 1024 * 1024) {
      suggestions.push('Consider implementing code splitting to reduce payload size');
    }

    return suggestions;
  }

  analyzeHttp2(response: AxiosResponse): Http2Analysis {
    const protocol = response.request.protocol;
    const headers = response.headers;
    const isHttp2 = protocol === 'h2' || headers['x-firefox-spdy'] === 'h2';

    const serverPushEnabled = !!headers['link']?.includes('rel=preload');
    const multiplexingUsed = isHttp2 && this.detectMultiplexing(response);
    const concurrentStreams = this.calculateConcurrentStreams(response);
    const connectionEfficiency = this.calculateConnectionEfficiency(response);

    return {
      enabled: isHttp2,
      serverPushEnabled,
      multiplexingUsed,
      concurrentStreams,
      connectionEfficiency,
      suggestions: this.generateHttp2Suggestions(isHttp2, serverPushEnabled, multiplexingUsed)
    };
  }

  private detectMultiplexing(response: AxiosResponse): boolean {
    // Check for multiplexing indicators in response headers
    return response.headers['x-firefox-spdy'] === 'h2' || 
           response.headers['x-http2-stream-id'] !== undefined;
  }

  private calculateConcurrentStreams(response: AxiosResponse): number {
    // Estimate concurrent streams from response headers
    const streamId = response.headers['x-http2-stream-id'];
    return streamId ? parseInt(streamId) : 1;
  }

  private calculateConnectionEfficiency(response: AxiosResponse): number {
    // Calculate connection efficiency based on various metrics
    const baseScore = 100;
    let efficiency = baseScore;

    if (!this.detectMultiplexing(response)) efficiency -= 20;
    if (!response.headers['link']?.includes('rel=preload')) efficiency -= 10;
    if (response.headers['connection'] === 'close') efficiency -= 15;

    return Math.max(0, efficiency);
  }

  private generateHttp2Suggestions(
    isHttp2: boolean,
    serverPushEnabled: boolean,
    multiplexingUsed: boolean
  ): string[] {
    const suggestions = [];

    if (!isHttp2) {
      suggestions.push('Upgrade to HTTP/2 for improved performance');
    } else {
      if (!serverPushEnabled) {
        suggestions.push('Consider implementing HTTP/2 Server Push for critical resources');
      }
      if (!multiplexingUsed) {
        suggestions.push('Optimize connection usage to better utilize HTTP/2 multiplexing');
      }
    }

    return suggestions;
  }

  analyzePageSize(response: AxiosResponse, resources: ResourceTiming[]): PageSizeAnalysis {
    const resourceSizes = {
      js: 0,
      css: 0,
      images: 0,
      fonts: 0,
      other: 0
    };

    resources.forEach(resource => {
      switch (resource.type) {
        case 'javascript':
          resourceSizes.js += resource.size;
          break;
        case 'stylesheet':
          resourceSizes.css += resource.size;
          break;
        case 'image':
          resourceSizes.images += resource.size;
          break;
        case 'font':
          resourceSizes.fonts += resource.size;
          break;
        default:
          resourceSizes.other += resource.size;
      }
    });

    const htmlSize = response.data.length;
    const totalSize = Object.values(resourceSizes).reduce((a, b) => a + b, htmlSize);

    const { maxTotalSizeKB, maxHtmlSizeKB, resourceLimits } = this.config.pageSize;
    const exceedsLimits = 
      totalSize > maxTotalSizeKB * 1024 ||
      htmlSize > maxHtmlSizeKB * 1024 ||
      resourceSizes.js > resourceLimits.maxJsSizeKB * 1024 ||
      resourceSizes.css > resourceLimits.maxCssSizeKB * 1024 ||
      resourceSizes.images > resourceLimits.maxImageSizeKB * 1024;

    return {
      totalSize,
      htmlSize,
      resourceSizes,
      exceedsLimits,
      suggestions: this.generatePageSizeSuggestions(totalSize, htmlSize, resourceSizes)
    };
  }

  private generatePageSizeSuggestions(
    totalSize: number,
    htmlSize: number,
    resourceSizes: any
  ): string[] {
    const suggestions = [];
    const { maxTotalSizeKB, maxHtmlSizeKB, resourceLimits } = this.config.pageSize;

    if (totalSize > maxTotalSizeKB * 1024) {
      suggestions.push(`Total page size (${Math.round(totalSize/1024)}KB) exceeds recommended limit (${maxTotalSizeKB}KB)`);
    }

    if (htmlSize > maxHtmlSizeKB * 1024) {
      suggestions.push('Consider reducing HTML size through minification');
    }

    if (resourceSizes.js > resourceLimits.maxJsSizeKB * 1024) {
      suggestions.push('JavaScript assets exceed recommended size. Consider code splitting and lazy loading');
    }

    if (resourceSizes.css > resourceLimits.maxCssSizeKB * 1024) {
      suggestions.push('CSS assets exceed recommended size. Consider optimizing and removing unused styles');
    }

    if (resourceSizes.images > resourceLimits.maxImageSizeKB * 1024) {
      suggestions.push('Image assets exceed recommended size. Consider optimization and lazy loading');
    }

    return suggestions;
  }

  async analyzePage(html: string, url: string, headers: Record<string, string>): Promise<{
    mobileFriendlinessAnalysis,
    ampAnalysis,
    resourceUsageAnalysis,
    cookieAnalysis,
    overallScore,
  }> {
    const [
      mobileFriendlinessAnalysis,
      ampAnalysis,
      resourceUsageAnalysis,
      cookieAnalysis
    ] = await Promise.all([
      this.mobileAnalysisService.analyzeMobileFriendliness(html),
      this.ampAnalysisService.analyzeAmp(html, url),
      this.resourceUsageAnalysisService.analyzeResourceUsage(html),
      this.cookieAnalysisService.analyzeCookies(
        headers['set-cookie']?.split(',') || [],
        headers,
        html
      )
    ]);

    return {
      mobileFriendlinessAnalysis,
      ampAnalysis,
      resourceUsageAnalysis,
      cookieAnalysis,
      overallScore: this.calculateOverallScore(
        mobileFriendlinessAnalysis.score,
        ampAnalysis.score,
        resourceUsageAnalysis.score,
        cookieAnalysis.score
      )
    };
  }

  private calculateOverallScore(...scores: number[]): number {
    const weights = {
      mobileFriendliness: 0.4,
      amp: 0.2,
      resourceUsage: 0.2,
      cookies: 0.2
    };

    return Math.round(
      scores[0] * weights.mobileFriendliness +
      scores[1] * weights.amp +
      scores[2] * weights.resourceUsage +
      scores[3] * weights.cookies
    );
  }
}
 
                                                                                        C:\Workspace\Web\Ai Business grow project\Back_end\src\crawler\services\analysis\url-analyzer.service.ts 


import { Injectable, Logger } from '@nestjs/common';
import { URL } from 'url';
import { CrawlerConfigService } from '../../config/crawler-config.service';

@Injectable()
export class UrlAnalyzerService {
  private readonly logger = new Logger(UrlAnalyzerService.name);

  constructor(private readonly crawlerConfigService: CrawlerConfigService) {}

  analyzeUrl(url: string): UrlAnalysis {
    try {
      const parsedUrl = new URL(url);
      const urlConfig = this.crawlerConfigService.getUrlAnalysisConfig();

      return {
        isValid: true,
        protocol: parsedUrl.protocol,
        hostname: parsedUrl.hostname,
        pathname: parsedUrl.pathname,
        search: parsedUrl.search,
        hash: parsedUrl.hash,
        isClean: this.isCleanUrl(parsedUrl),
        depth: this.calculateUrlDepth(parsedUrl.pathname),
        pattern: this.identifyUrlPattern(parsedUrl),
        isWithinDepthLimit: this.isWithinDepthLimit(parsedUrl.pathname, urlConfig.maxDepth),
        isLowercase: this.isLowercase(url),
        hasPreferredProtocol: this.hasPreferredProtocol(parsedUrl.protocol, urlConfig.preferredProtocol),
        queryStringAnalysis: this.analyzeQueryString(parsedUrl.searchParams, urlConfig.paramMaxCount),
        fragmentAnalysis: this.analyzeFragment(parsedUrl.hash, urlConfig.maxFragmentLength),
      };
    } catch (error) {
      this.logger.warn(`Invalid URL: ${url}`);
      return { isValid: false };
    }
  }

  private isCleanUrl(parsedUrl: URL): boolean {
    const urlConfig = this.crawlerConfigService.getUrlAnalysisConfig();
    const pathSegments = parsedUrl.pathname.split('/').filter(Boolean);
    return !parsedUrl.search && !parsedUrl.hash && pathSegments.length <= urlConfig.cleanUrlThreshold;
  }

  private calculateUrlDepth(pathname: string): number {
    return pathname.split('/').filter(Boolean).length;
  }

  private identifyUrlPattern(parsedUrl: URL): string {
    if (parsedUrl.pathname.includes('/category/')) return 'category';
    if (parsedUrl.pathname.includes('/product/')) return 'product';
    if (parsedUrl.pathname.includes('/blog/')) return 'blog';
    if (parsedUrl.pathname.match(/\/\d{4}\/\d{2}\/\d{2}\//)) return 'date-based';
    return 'other';
  }

  private isWithinDepthLimit(pathname: string, maxDepth: number): boolean {
    return this.calculateUrlDepth(pathname) <= maxDepth;
  }

  analyzeUrlParameters(url: string): UrlParameterAnalysis {
    const parsedUrl = new URL(url);
    const params = new URLSearchParams(parsedUrl.search);
    const config = this.crawlerConfigService.getUrlAnalysisConfig();

    const parameterCount = params.size;
    const parameterDetails = this.getParameterDetails(params);
    const exceedsMaxCount = parameterCount > config.paramMaxCount;
    const exceedsMaxLength = this.checkParameterLength(parameterDetails, config.paramMaxLength);
    const sensitiveDataDetected = this.detectSensitiveData(parameterDetails);

    return {
      parameterCount,
      parameterDetails,
      exceedsMaxCount,
      exceedsMaxLength,
      sensitiveDataDetected,
    };
  }

  private getParameterDetails(params: URLSearchParams): ParameterDetail[] {
    return Array.from(params.entries()).map(([name, value]) => ({
      name,
      value,
      length: name.length + value.length,
      containsSensitiveData: this.isSensitiveData(name, value),
    }));
  }

  private isSensitiveData(name: string, value: string): boolean {
    const sensitivePatterns = [
      /password/i,
      /token/i,
      /api[-_]?key/i,
      /secret/i,
      /^ssn$/i,
      /credit[-_]?card/i,
      /^cc[-_]?num(ber)?$/i,
    ];

    return sensitivePatterns.some(pattern => 
      pattern.test(name) || 
      (value.length > 8 && /^[A-Za-z0-9+/=]+$/.test(value)) // Potential encoded data
    );
  }

  private detectSensitiveData(details: ParameterDetail[]): boolean {
    return details.some(detail => detail.containsSensitiveData);
  }

  private checkParameterLength(details: ParameterDetail[], maxLength: number): boolean {
    return details.some(detail => detail.length > maxLength);
  }

  analyzeUrlLength(url: string): UrlLengthAnalysis {
    const parsedUrl = new URL(url);
    const config = this.crawlerConfigService.getUrlAnalysisConfig();

    const totalLength = url.length;
    const pathLength = parsedUrl.pathname.length;
    const queryLength = parsedUrl.search.length;
    const fragmentLength = parsedUrl.hash.length;

    return {
      totalLength,
      pathLength,
      queryLength,
      fragmentLength,
      exceedsTotalLength: totalLength > config.maxTotalLength,
      exceedsPathLength: pathLength > config.maxPathLength,
      exceedsQueryLength: queryLength > config.maxQueryLength,
      exceedsFragmentLength: fragmentLength > config.maxFragmentLength,
    };
  }

  private isLowercase(url: string): boolean {
    return url === url.toLowerCase();
  }

  private hasPreferredProtocol(protocol: string, preferredProtocol: string): boolean {
    return protocol.replace(':', '') === preferredProtocol;
  }

  private analyzeQueryString(searchParams: URLSearchParams, maxQueryParams: number): QueryStringAnalysis {
    const params = Array.from(searchParams.entries());
    return {
      paramCount: params.length,
      exceedsMaxParams: params.length > maxQueryParams,
      params: params.map(([key, value]) => ({ key, value })),
    };
  }

  private analyzeFragment(fragment: string, maxFragmentLength: number): FragmentAnalysis {
    return {
      hasFragment: fragment.length > 0,
      fragmentLength: fragment.length,
      exceedsMaxLength: fragment.length > maxFragmentLength,
    };
  }
}

interface UrlAnalysis {
  isValid: boolean;
  protocol?: string;
  hostname?: string;
  pathname?: string;
  search?: string;
  hash?: string;
  isClean?: boolean;
  depth?: number;
  pattern?: string;
  isWithinDepthLimit?: boolean;
  isLowercase?: boolean;
  hasPreferredProtocol?: boolean;
  queryStringAnalysis?: QueryStringAnalysis;
  fragmentAnalysis?: FragmentAnalysis;
}

interface UrlParameterAnalysis {
  parameterCount: number;
  parameterDetails: ParameterDetail[];
  exceedsMaxCount: boolean;
  exceedsMaxLength: boolean;
  sensitiveDataDetected: boolean;
}

interface ParameterDetail {
  name: string;
  value: string;
  length: number;
  containsSensitiveData: boolean;
}

interface UrlLengthAnalysis {
  totalLength: number;
  pathLength: number;
  queryLength: number;
  fragmentLength: number;
  exceedsTotalLength: boolean;
  exceedsPathLength: boolean;
  exceedsQueryLength: boolean;
  exceedsFragmentLength: boolean;
}

interface QueryStringAnalysis {
  paramCount: number;
  exceedsMaxParams: boolean;
  params: { key: string; value: string }[];
}

interface FragmentAnalysis {
  hasFragment: boolean;
  fragmentLength: number;
  exceedsMaxLength: boolean;
} 
                                                                                                C:\Workspace\Web\Ai Business grow project\Back_end\src\crawler\services\directory-tree\directory-tree-crawler.service.ts 
import { Injectable } from '@nestjs/common';
import { CrawlerConfigService } from '../../config/crawler-config.service';
import * as fs from 'fs/promises';
import * as path from 'path';

@Injectable()
export class DirectoryTreeCrawlerService {
  constructor(private readonly crawlerConfigService: CrawlerConfigService) {}

  async crawlDirectoryTree(rootPath: string): Promise<any> {
    const config = this.crawlerConfigService.getDirectoryTreeConfig();
    return this.crawlDirectory(rootPath, 0, config);
  }

  private async crawlDirectory(dirPath: string, currentDepth: number, config: any): Promise<any> {
    if (currentDepth > config.directoryTreeMaxDepth) {
      return null;
    }

    const entries = await fs.readdir(dirPath, { withFileTypes: true });
    const result: any = { name: path.basename(dirPath), type: 'directory', children: [] };

    for (const entry of entries) {
      const fullPath = path.join(dirPath, entry.name);

      if (this.shouldExclude(entry.name, config.directoryTreeExcludePatterns)) {
        continue;
      }

      if (entry.isDirectory()) {
        const subDir = await this.crawlDirectory(fullPath, currentDepth + 1, config);
        if (subDir) {
          result.children.push(subDir);
        }
      } else if (entry.isFile() && this.isAllowedFile(entry.name, config.directoryTreeAllowedExtensions)) {
        result.children.push({ name: entry.name, type: 'file' });
      }
    }

    return result;
  }

  private shouldExclude(name: string, excludePatterns: string[]): boolean {
    return excludePatterns.some(pattern => name.toLowerCase().includes(pattern.toLowerCase()));
  }

  private isAllowedFile(name: string, allowedExtensions: string[]): boolean {
    const ext = path.extname(name).toLowerCase().slice(1);
    return allowedExtensions.includes(ext);
  }
}
 
                                                                                                    C:\Workspace\Web\Ai Business grow project\Back_end\src\crawler\services\extraction\content-extractor.ts 
import * as cheerio from 'cheerio';
import axios from 'axios';

export class ContentExtractor {
  async fetchPage(url: string): Promise<{ $: cheerio.CheerioAPI; loadTime: number }> {
    const startTime = Date.now();
    const response = await axios.get(url);
    const loadTime = Date.now() - startTime;
    const $ = cheerio.load(response.data);
    return { $, loadTime };
  }

  extractPageData($: cheerio.CheerioAPI, url: string, loadTime: number): any {
    const { bestContent, goodContent, contentScore } = this.extractMainContent($);

    return {
      pageTitle: $('title').text(),
      pageUrlRelative: new URL(url).pathname,
      pageMetaData: this.extractMetadata($),
      imageData: this.extractImageData($),
      mainContent: bestContent,
      goodContent: goodContent,
      contentScore: contentScore,
      wordCount: this.countWords($('body').text()),
      loadTime,
      urlStructure: this.analyzeUrlStructure(url),
      brandingElements: this.detectBrandingElements($),
      structuredData: this.extractStructuredData($),
    };
  }

  private extractMetadata($: cheerio.CheerioAPI): Record<string, string> {
    const metadata: Record<string, string> = {};
    $('meta').each((_, el) => {
      const name = $(el).attr('name') || $(el).attr('property');
      const content = $(el).attr('content');
      if (name && content) {
        metadata[name] = content;
      }
    });
    metadata['canonical'] = $('link[rel="canonical"]').attr('href') || '';
    $('link[rel="alternate"][hreflang]').each((_, el) => {
      const hreflang = $(el).attr('hreflang');
      const href = $(el).attr('href');
      if (hreflang && href) {
        metadata[`hreflang:${hreflang}`] = href;
      }
    });
    return metadata;
  }

  private extractImageData($: cheerio.CheerioAPI): any[] {
    return $('img').map((_, el) => ({
        src: $(el).attr('src'),
        alt: $(el).attr('alt'),
        title: $(el).attr('title'),
        width: $(el).attr('width'),
        height: $(el).attr('height'),
      })).get();
  }

  private extractMainContent($: cheerio.CheerioAPI): { bestContent: string; goodContent: string[]; contentScore: number } {
    const contentSelectors = [
        'article', 'main', '#content', '.content', '.post-content',
        '[role="main"]', '.entry-content', '.post', '.article'
      ];
    
      let bestContent = '';
      let bestScore = 0;
      let goodContent: string[] = [];
    
      // Try common content selectors first
      for (const selector of contentSelectors) {
        const $content = $(selector);
        if ($content.length) {
          const content = $content.first().html();
          const score = this.calculateContentScore(content);
          if (score > bestScore) {
            if (bestContent) {
              goodContent.push(bestContent);
            }
            bestContent = content;
            bestScore = score;
          } else if (score > bestScore * 0.7) {
            goodContent.push(content);
          }
        }
      }
    
      // If no suitable content found, analyze all top-level elements
      if (!bestContent) {
        $('body > *').each((_, element) => {
          const $element = $(element);
          const content = $element.html();
          const score = this.calculateContentScore(content);
          if (score > bestScore) {
            if (bestContent) {
              goodContent.push(bestContent);
            }
            bestContent = content;
            bestScore = score;
          } else if (score > bestScore * 0.7) {
            goodContent.push(content);
          }
        });
      }
    
      // If still no content, fallback to body
      if (!bestContent) {
        bestContent = $('body').html();
        bestScore = this.calculateContentScore(bestContent);
      }
    
      return { bestContent, goodContent, contentScore: bestScore };
  }

  private calculateContentScore(content: string): number {
    if (!content) return 0;
  
    const text = cheerio.load(content).text();
    const wordCount = text.split(/\s+/).length;
    const linkDensity = Math.min(1, (content.match(/<a /g) || []).length / wordCount);
    const headingDensity = Math.min(1, (content.match(/<h[1-6]/g) || []).length / wordCount);
    const paragraphDensity = Math.min(1, (content.match(/<p/g) || []).length / wordCount);
  
    let score = wordCount;
    score *= (1 - linkDensity);
    score *= (1 + headingDensity * 0.5);
    score *= (1 + paragraphDensity * 0.5);
  
    if (content.includes('<article')) score *= 1.2;
    if (content.includes('<section')) score *= 1.1;
    if (content.includes('<figure')) score *= 1.05;
  
    // Apply activation function to keep score between 1 and 100
    return 1 + 99 / (1 + Math.exp(-score / 1000));
  }

  private countWords(text: string): number {
    return text.trim().split(/\s+/).length;
  }

  private analyzeUrlStructure(url: string): Record<string, string> {
    const parsedUrl = new URL(url);
    return {
      protocol: parsedUrl.protocol,
      hostname: parsedUrl.hostname,
      pathname: parsedUrl.pathname,
      search: parsedUrl.search,
      hash: parsedUrl.hash,
    };
  }

  private detectBrandingElements($: cheerio.CheerioAPI): Record<string, boolean> {
    return {
        hasReviews: $('*:contains("review"), *:contains("testimonial")').length > 0,
        hasChatbot: $('*:contains("chat"), *[id*="chat"], *[class*="chat"]').length > 0,
        hasAboutUs: $('a[href*="about"], *:contains("About Us")').length > 0,
        hasMediaSection: $('*:contains("Media"), a[href*="media"], a[href*="press"]').length > 0,
        hasProjectsSection: $('*:contains("Projects"), a[href*="project"], a[href*="portfolio"]').length > 0,
      };
  }

  private extractStructuredData($: cheerio.CheerioAPI): string[] {
    return $('script[type="application/ld+json"]')
    .map((_, el) => $(el).html())
    .get();
  }
}
 
                                                                                                    C:\Workspace\Web\Ai Business grow project\Back_end\src\crawler\services\extraction\url-extractor.ts 
import * as cheerio from 'cheerio';
import { Injectable } from '@nestjs/common';
import { CrawlerConfigService } from '../../config/crawler-config.service';
import { RobotsTxtService } from '../robot/robots-txt.service';
import { InclusionExclusionService } from '../../config/inclusion-exclusion.service';
import { URL } from 'url';

@Injectable()
export class UrlExtractor {
  constructor(
    private crawlerConfigService: CrawlerConfigService,
    private robotsTxtService: RobotsTxtService,
    private inclusionExclusionService: InclusionExclusionService
  ) {}

  async extractLinks($: cheerio.CheerioAPI, url: string, currentDepth: number, crawlConfig: any): Promise<string[]> {
    const baseUrl = new URL(url);
    const validExtensions = new Set(['', '.html', '.htm', '.php', '.asp', '.aspx']);

    const newUrls = $('a').map((_, el) => {
      const href = $(el).attr('href');
      if (href) {
        try {
          const newUrl = new URL(href, baseUrl.origin);
          const pathname = newUrl.pathname.toLowerCase();
          const extension = pathname.substring(pathname.lastIndexOf('.'));

          if (this.shouldFollowLink(newUrl, baseUrl, crawlConfig) &&
              (validExtensions.has(extension) || !pathname.includes('.')) &&
              this.inclusionExclusionService.isUrlAllowed(newUrl.href)) {
            return newUrl.href;
          }
        } catch {
          // Invalid URL, ignore
        }
      }
      return null;
    }).get().filter(Boolean);

    const uniqueUrls = [...new Set(newUrls)];
    const allowedUrls = await this.filterAllowedUrls(uniqueUrls);

    return allowedUrls;
  }

  private shouldFollowLink(newUrl: URL, baseUrl: URL, config: any): boolean {
    if (newUrl.hostname === baseUrl.hostname) {
      if (newUrl.pathname.startsWith(baseUrl.pathname)) {
        return config.followSubfolderLinks;
      }
      return config.followInternalLinks;
    }
    return config.followExternalLinks;
  }

  private async filterAllowedUrls(urls: string[]): Promise<string[]> {
    const allowedUrlPromises = urls.map(async (url) => {
      const isAllowed = await this.robotsTxtService.isAllowed(url);
      return isAllowed ? url : null;
    });

    const allowedUrls = await Promise.all(allowedUrlPromises);
    return allowedUrls.filter(Boolean);
  }

  async extractSitemapUrlsFromRobotsTxt(url: string): Promise<string[]> {
    const config = this.crawlerConfigService.getCrawlerConfig();
    if (!config.extractSitemapsFromRobots) {
      return [];
    }

    try {
      const robotsTxtUrl = new URL('/robots.txt', url).toString();
      const robotsTxtContent = await this.robotsTxtService.fetchRobotsTxt(robotsTxtUrl);
      const sitemapUrls = robotsTxtContent.match(/Sitemap: (.*)/gi);
      return sitemapUrls ? sitemapUrls.map(line => line.split(': ')[1]) : [];
    } catch (error) {
      console.error(`Error extracting sitemap URLs from robots.txt: ${error.message}`);
      return [];
    }
  }

  async extractSitemapUrlsFromHtml($: cheerio.CheerioAPI, url: string): Promise<string[]> {
    const config = this.crawlerConfigService.getCrawlerConfig();
    if (!config.extractSitemapsFromHtml) {
      return [];
    }

    const sitemapUrls: string[] = [];

    // Check for sitemap links in the HTML
    $('a[href*="sitemap"]').each((_, el) => {
      const href = $(el).attr('href');
      if (href) {
        sitemapUrls.push(new URL(href, url).toString());
      }
    });

    // Check for sitemap references in meta tags
    $('meta[name="sitemap"]').each((_, el) => {
      const content = $(el).attr('content');
      if (content) {
        sitemapUrls.push(new URL(content, url).toString());
      }
    });

    return [...new Set(sitemapUrls)];
  }
} 
                                                                                                                        C:\Workspace\Web\Ai Business grow project\Back_end\src\crawler\services\robot\robots-txt.service.ts 
import { Injectable } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import axios from 'axios';

@Injectable()
export class RobotsTxtService {
  private robotsTxtCache: Map<string, string> = new Map();

  constructor(private configService: ConfigService) {}

  async fetchRobotsTxt(url: string): Promise<string> {
    const robotsTxtUrl = new URL('/robots.txt', url).toString();
    try {
      const response = await axios.get(robotsTxtUrl);
      return response.data;
    } catch (error) {
      console.error(`Error fetching robots.txt from ${robotsTxtUrl}: ${error.message}`);
      return '';
    }
  }

  async parseRobotsTxt(url: string): Promise<Map<string, string[]>> {
    const domain = new URL(url).origin;
    if (!this.robotsTxtCache.has(domain)) {
      const robotsTxtContent = await this.fetchRobotsTxt(domain);
      this.robotsTxtCache.set(domain, robotsTxtContent);
    }
    
    const content = this.robotsTxtCache.get(domain);
    const rules = new Map<string, string[]>();
    let currentUserAgent = '*';

    content.split('\n').forEach(line => {
      line = line.trim().toLowerCase();
      if (line.startsWith('user-agent:')) {
        currentUserAgent = line.split(':')[1].trim();
        if (!rules.has(currentUserAgent)) {
          rules.set(currentUserAgent, []);
        }
      } else if (line.startsWith('disallow:') || line.startsWith('allow:')) {
        const [directive, path] = line.split(':');
        rules.get(currentUserAgent).push(`${directive}:${path.trim()}`);
      }
    });

    return rules;
  }

  async isAllowed(url: string): Promise<boolean> {
    const rules = await this.parseRobotsTxt(url);
    const userAgent = this.configService.get<string>('CRAWLER_USER_AGENT');
    const path = new URL(url).pathname;

    const relevantRules = rules.get(userAgent) || rules.get('*') || [];

    for (const rule of relevantRules) {
      const [directive, rulePath] = rule.split(':');
      if (path.startsWith(rulePath)) {
        return directive === 'allow';
      }
    }

    return true;
  }
} 
                                                                                                                            C:\Workspace\Web\Ai Business grow project\Back_end\src\crawler\services\sitemap\sitemap-crawler.service.ts 
import { Injectable } from '@nestjs/common';
import { CrawlerConfigService } from '../../config/crawler-config.service';
import axios from 'axios';
import * as xml2js from 'xml2js';
import * as cheerio from 'cheerio';

@Injectable()
export class SitemapCrawlerService {
  constructor(private readonly crawlerConfigService: CrawlerConfigService) {}

  async discoverSitemaps(url: string): Promise<string[]> {
    const config = this.crawlerConfigService.getCrawlerConfig();
    const baseUrl = new URL(url).origin;
    const sitemaps: string[] = [];

    // Check robots.txt for sitemaps
    const robotsTxtUrl = `${baseUrl}/robots.txt`;
    try {
      const robotsTxtResponse = await axios.get(robotsTxtUrl);
      const robotsTxtContent = robotsTxtResponse.data;
      const sitemapUrls = robotsTxtContent.match(/Sitemap: (.*)/gi);
      if (sitemapUrls) {
        sitemaps.push(...sitemapUrls.map(line => line.split(': ')[1]));
      }
    } catch (error) {
      console.error(`Error fetching robots.txt: ${error.message}`);
    }

    // Check common sitemap locations
    const commonSitemapPaths = [
      '/sitemap.xml',
      '/sitemap_index.xml',
      '/sitemap.txt',
      '/sitemap.rss',
      '/sitemap.atom',
    ];

    for (const path of commonSitemapPaths) {
      const sitemapUrl = `${baseUrl}${path}`;
      try {
        await axios.head(sitemapUrl);
        sitemaps.push(sitemapUrl);
      } catch (error) {
        // Sitemap not found at this location, continue to next
      }
    }

    return sitemaps;
  }

  async fetchSitemap(url: string): Promise<string[]> {
    const config = this.crawlerConfigService.getCrawlerConfig();
    const response = await axios.get(url, {
      headers: { 'User-Agent': config.userAgent },
    });

    const contentType = response.headers['content-type'];
    if (contentType.includes('application/xml') || contentType.includes('text/xml')) {
      return this.parseXmlSitemap(response.data);
    } else if (contentType.includes('text/plain')) {
      return this.parseTxtSitemap(response.data);
    } else if (contentType.includes('application/rss+xml')) {
      return this.parseRssSitemap(response.data);
    } else if (contentType.includes('application/atom+xml')) {
      return this.parseAtomSitemap(response.data);
    } else {
      throw new Error(`Unsupported sitemap format: ${contentType}`);
    }
  }

  private async parseXmlSitemap(content: string): Promise<string[]> {
    const parser = new xml2js.Parser();
    const result = await parser.parseStringPromise(content);
    const urls: string[] = [];

    if (result.sitemapindex) {
      // This is a sitemap index
      for (const sitemap of result.sitemapindex.sitemap) {
        const nestedUrls = await this.fetchSitemap(sitemap.loc[0]);
        urls.push(...nestedUrls);
      }
    } else if (result.urlset) {
      // This is a regular sitemap
      for (const url of result.urlset.url) {
        urls.push(url.loc[0]);
      }
    }

    return urls;
  }

  private parseTxtSitemap(content: string): string[] {
    return content.split('\n').filter(line => line.trim().startsWith('http'));
  }

  private async parseRssSitemap(content: string): Promise<string[]> {
    const parser = new xml2js.Parser();
    const result = await parser.parseStringPromise(content);
    return result.rss.channel[0].item.map(item => item.link[0]);
  }

  private async parseAtomSitemap(content: string): Promise<string[]> {
    const parser = new xml2js.Parser();
    const result = await parser.parseStringPromise(content);
    return result.feed.entry.map(entry => entry.link[0].$.href);
  }
}
 
                                                                                                                            C:\Workspace\Web\Ai Business grow project\Back_end\src\crawler\services\sitemap\sitemap-parser.ts 
import { Injectable } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import axios from 'axios';
import * as xml2js from 'xml2js';
import * as zlib from 'zlib';
import { promisify } from 'util';

const gunzip = promisify(zlib.gunzip);

@Injectable()
export class SitemapParser {
  private maxUrls: number;
  private timeout: number;

  constructor(private configService: ConfigService) {
    this.maxUrls = this.configService.get<number>('SITEMAP_PARSER_MAX_URLS', 50000);
    this.timeout = this.configService.get<number>('SITEMAP_PARSER_TIMEOUT', 30000);
  }

  async parse(url: string): Promise<string[]> {
    const response = await this.fetchSitemap(url);
    const content = await this.decompressIfNeeded(response);

    if (this.isXmlSitemap(content)) {
      return this.parseXmlSitemap(content);
    } else if (this.isTextSitemap(content)) {
      return this.parseTextSitemap(content);
    } else {
      throw new Error('Unsupported sitemap format');
    }
  }

  private async fetchSitemap(url: string): Promise<string> {
    try {
      const response = await axios.get(url, {
        responseType: 'arraybuffer',
        timeout: this.timeout,
      });
      return response.data;
    } catch (error) {
      throw new Error(`Failed to fetch sitemap: ${error.message}`);
    }
  }

  private async decompressIfNeeded(content: string | Buffer): Promise<string> {
    if (content instanceof Buffer && content[0] === 0x1f && content[1] === 0x8b) {
      const decompressed = await gunzip(content);
      return decompressed.toString('utf-8');
    }
    return content.toString('utf-8');
  }

  private isXmlSitemap(content: string): boolean {
    return content.trim().startsWith('<?xml') || content.trim().startsWith('<urlset') || content.trim().startsWith('<sitemapindex');
  }

  private isTextSitemap(content: string): boolean {
    const lines = content.trim().split('\n');
    return lines.every(line => line.trim().startsWith('http'));
  }

  private async parseXmlSitemap(content: string): Promise<string[]> {
    const parser = new xml2js.Parser();
    const result = await parser.parseStringPromise(content);

    if (result.sitemapindex) {
      return this.parseSitemapIndex(result.sitemapindex);
    } else if (result.urlset) {
      return this.parseUrlset(result.urlset);
    } else {
      throw new Error('Invalid XML sitemap format');
    }
  }

  private async parseSitemapIndex(sitemapindex: any): Promise<string[]> {
    const urls: string[] = [];
    for (const sitemap of sitemapindex.sitemap) {
      if (urls.length >= this.maxUrls) break;
      const sitemapUrl = sitemap.loc[0];
      const sitemapUrls = await this.parse(sitemapUrl);
      urls.push(...sitemapUrls.slice(0, this.maxUrls - urls.length));
    }
    return urls;
  }

  private parseUrlset(urlset: any): string[] {
    return urlset.url
      .map((url: any) => url.loc[0])
      .slice(0, this.maxUrls);
  }

  private parseTextSitemap(content: string): string[] {
    return content
      .trim()
      .split('\n')
      .map(line => line.trim())
      .filter(line => line.startsWith('http'))
      .slice(0, this.maxUrls);
  }
}
 
                                                                                                                                C:\Workspace\Web\Ai Business grow project\Back_end\src\enum\seo.enum.ts 
export enum SEOEnum {
    ROBOT = "ROBOT",
} 
                                                                                                                                    C:\Workspace\Web\Ai Business grow project\Back_end\src\seo\external-api.service.ts 
import { Injectable } from '@nestjs/common';

@Injectable()
export class ExternalAPIService {
  async fetchData(apiUrl: string, params: any): Promise<any> {
    await new Promise(resolve => setTimeout(resolve, 1000));
    return "voila ";
  }
}
 
                                                                                                                                    C:\Workspace\Web\Ai Business grow project\Back_end\src\seo\seo.interface.ts 
export interface SeoServiceInterface {
  getData(sessionId:string): any;
} 
                                                                                                                                    C:\Workspace\Web\Ai Business grow project\Back_end\src\seo\seo.module.ts 
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { RobotsModule } from './robots/robots.module';
import { SitemapModule } from './sitemap/sitemap.module';
import { RobotsData, RobotsDataSchema } from './robots/robots-data.schema';
import { SitemapData, SitemapDataSchema } from './sitemap/sitemap-data.schema';

@Module({
  imports: [
    RobotsModule,
    SitemapModule,
    MongooseModule.forFeature([
      { name: RobotsData.name, schema: RobotsDataSchema },
      { name: SitemapData.name, schema: SitemapDataSchema },
    ]),
  ],
  exports: [RobotsModule, SitemapModule],
})
export class SEOModule {} 
                                                                                                                                    C:\Workspace\Web\Ai Business grow project\Back_end\src\seo\transform.service.ts 
import { Injectable } from '@nestjs/common';

@Injectable()
export class TransformService {
  transformData(rawData: any, transformationType: string): any {
    // Placeholder for data transformation logic
    // Implement transformations based on the type of data
    return rawData; // Simplified, should be adjusted for real transformation logic
  }
}
 
                                                                                                                                        C:\Workspace\Web\Ai Business grow project\Back_end\src\seo\robots\RobotData.Interface.ts 
export interface RobotsData {
    exist: boolean;
    content?: string;
  } 
                                                                                                                                        C:\Workspace\Web\Ai Business grow project\Back_end\src\seo\robots\robots-data.schema.ts 
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document } from 'mongoose';

@Schema()
export class RobotsData extends Document {
  @Prop({ required: true })
  auditId: string;

  @Prop({ required: true })
  exist: boolean;

  @Prop()
  content?: string;
}

export const RobotsDataSchema = SchemaFactory.createForClass(RobotsData);
 
                                                                                                                                        C:\Workspace\Web\Ai Business grow project\Back_end\src\seo\robots\robots.config.ts 
export const robotsConfig = {
    externalApiUrl: 'https://example-robots-api.com',
  };
   
                                                                                                                                        C:\Workspace\Web\Ai Business grow project\Back_end\src\seo\robots\robots.controller.ts 
import { Controller, Get, Query } from '@nestjs/common';
import { RobotsService } from './robots.service';

@Controller('seo/robots')
export class RobotsController {
  constructor(private readonly robotsService: RobotsService) {}

  @Get()
  async getRobotsData(@Query('url') url: string, @Query('auditId') auditId: string) {
    return this.robotsService.analyzeRobots(url, auditId);
  }
}
 
                                                                                                                                        C:\Workspace\Web\Ai Business grow project\Back_end\src\seo\robots\robots.module.ts 
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { RobotsService } from './robots.service';
import { RobotsController } from './robots.controller';
import { RobotsData, RobotsDataSchema } from './robots-data.schema';

@Module({
  imports: [MongooseModule.forFeature([{ name: RobotsData.name, schema: RobotsDataSchema }])],
  controllers: [RobotsController],
  providers: [RobotsService],
})
export class RobotsModule {}
 
                                                                                                                                        C:\Workspace\Web\Ai Business grow project\Back_end\src\seo\robots\robots.service.ts 
import { Injectable } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { RobotsData } from './robots-data.schema';
import { SeoServiceInterface } from '../seo.interface';

@Injectable()
export class RobotsService implements SeoServiceInterface {
  constructor(
    @InjectModel(RobotsData.name) private robotsDataModel: Model<RobotsData>,
  ) { }

  async analyzeRobots(url: string, auditId: string): Promise<any> {
    const rawData = await this.getRobotsData(url);
    await this.saveRobotsData(auditId, rawData);
    return rawData;
  }

  async getRobotsData(url: string): Promise<{ exist: boolean; content?: string }> {

    const rootUrl = await this.getRootUrl(url);
    const robotsTxtUrl = `${rootUrl}/robots.txt`;
    try {
      const response = await fetch(robotsTxtUrl);
      const isText =  this.isTextFile(response);
      console.log(!this.isTextFile(response));
      if (response.ok && this.isTextFile(response) ) {
        return {
          exist: true,
          content: await response.text(),
        };
      }
    } catch (_) {
      return {
        exist: false,
        content:''
      };
    }
  }

  private async getRootUrl(url: string): Promise<string> {
    const parsedUrl = new URL(url);
    return `${parsedUrl.protocol}//${parsedUrl.hostname}`;
  }

  private isTextFile(response: Response): boolean {
    const contentType = response.headers.get('content-type');
    return contentType && contentType.includes('text/plain');
  }

  private async saveRobotsData(auditId: string, rawData: { exist: boolean; content?: string }): Promise<void> {
    const robotsData = new this.robotsDataModel({
      auditId,
      exist: rawData.exist,
      content: rawData.content,
    });
    await robotsData.save();
  }

  public async getData(sessionId: string): Promise<any> {
    try {
      const robotsData = await this.robotsDataModel.findOne({ auditId: sessionId }).exec()
      return robotsData.content
    } catch (error) {
      throw new Error(`Failed to fetch robots data: ${error.message}`)
    }
  }
  
}

 
                                                                                                                                            C:\Workspace\Web\Ai Business grow project\Back_end\src\seo\sitemap\sitemap-data.schema.ts 
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document } from 'mongoose';

@Schema()
export class SitemapData extends Document {
  @Prop({ required: true })
  auditId: string;

  @Prop({ required: true })
  xmlExist: boolean;

  @Prop()
  xmlContent?: string;

  @Prop()
  xmlUrls?: string[];

  @Prop({ required: true })
  htmlExist: boolean;

  @Prop()
  htmlContent?: string;
}

export const SitemapDataSchema = SchemaFactory.createForClass(SitemapData);
 
                                                                                                                                            C:\Workspace\Web\Ai Business grow project\Back_end\src\seo\sitemap\sitemap.controller.ts 
import { Controller, Get, Query } from '@nestjs/common';
import { SitemapService } from './sitemap.service';

@Controller('seo/sitemap')
export class SitemapController {
  constructor(private readonly sitemapService: SitemapService) {}

  @Get()
  async getSitemapData(@Query('url') url: string, @Query('auditId') auditId: string) {
    return this.sitemapService.analyzeSitemap(url, auditId);
  }
} 
                                                                                                                                            C:\Workspace\Web\Ai Business grow project\Back_end\src\seo\sitemap\sitemap.module.ts 
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { SitemapService } from './sitemap.service';
import { SitemapController } from './sitemap.controller';
import { SitemapData, SitemapDataSchema } from './sitemap-data.schema';

@Module({
  imports: [MongooseModule.forFeature([{ name: SitemapData.name, schema: SitemapDataSchema }])],
  controllers: [SitemapController],
  providers: [SitemapService],
  exports: [SitemapService],
})
export class SitemapModule {}
 
                                                                                                                                            C:\Workspace\Web\Ai Business grow project\Back_end\src\seo\sitemap\sitemap.service.ts 
import { Injectable } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { SitemapData } from './sitemap-data.schema';
import { SeoServiceInterface } from '../seo.interface';
import * as xml2js from 'xml2js';

@Injectable()
export class SitemapService implements SeoServiceInterface {
  constructor(
    @InjectModel(SitemapData.name) private sitemapDataModel: Model<SitemapData>,
  ) {}

  async analyzeSitemap(url: string, auditId: string): Promise<any> {
    const xmlData = await this.getSitemapXmlData(url);
    const htmlData = await this.getSitemapHtmlData(url);
    await this.saveSitemapData(auditId, xmlData, htmlData);
    return { xml: xmlData, html: htmlData };
  }

  async getSitemapXmlData(url: string): Promise<{ exist: boolean; content?: string; urls?: string[] }> {
    const rootUrl = await this.getRootUrl(url);
    const sitemapUrl = `${rootUrl}/sitemap.xml`;
    try {
      const response = await fetch(sitemapUrl);
      if (response.ok && response.headers.get('content-type')?.includes('application/xml')) {
        const content = await response.text();
        const urls = await this.parseSitemapXml(content);
        return {
          exist: true,
          content,
          urls,
        };
      }
    } catch (_) {}
    return {
      exist: false,
    };
  }

  async getSitemapHtmlData(url: string): Promise<{ exist: boolean; content?: string }> {
    const rootUrl = await this.getRootUrl(url);
    const sitemapUrl = `${rootUrl}/sitemap.html`;
    try {
      const response = await fetch(sitemapUrl);
      if (response.ok && response.headers.get('content-type')?.includes('text/html')) {
        const content = await response.text();
        return {
          exist: true,
          content,
        };
      }
    } catch (_) {}
    return {
      exist: false,
    };
  }

  private async getRootUrl(url: string): Promise<string> {
    const parsedUrl = new URL(url);
    return `${parsedUrl.protocol}//${parsedUrl.hostname}`;
  }

  private async parseSitemapXml(content: string): Promise<string[]> {
    const parser = new xml2js.Parser();
    const result = await parser.parseStringPromise(content);
    return result.urlset.url.map(urlObj => urlObj.loc[0]);
  }

  private async saveSitemapData(
    auditId: string, 
    xmlData: { exist: boolean; content?: string; urls?: string[] },
    htmlData: { exist: boolean; content?: string }
  ): Promise<void> {
    const sitemapData = new this.sitemapDataModel({
      auditId,
      xmlExist: xmlData.exist,
      xmlContent: xmlData.content,
      xmlUrls: xmlData.urls,
      htmlExist: htmlData.exist,
      htmlContent: htmlData.content,
    });
    await sitemapData.save();
  }

  public async getData(sessionId: string): Promise<any> {
    try {
      const sitemapData = await this.sitemapDataModel.findOne({ auditId: sessionId }).exec();
      return {
        xml: {
          exist: sitemapData.xmlExist,
          content: sitemapData.xmlContent,
          urls: sitemapData.xmlUrls,
        },
        html: {
          exist: sitemapData.htmlExist,
          content: sitemapData.htmlContent,
        },
      };
    } catch (error) {
      throw new Error(`Failed to fetch sitemap data: ${error.message}`);
    }
  }
}
 
                                                                                                                                            C:\Workspace\Web\Ai Business grow project\Back_end\src\seo\sitemap\SitemapData.Interface.ts 
export interface SitemapData {
  xmlExist: boolean;
  xmlContent?: string;
  xmlUrls?: string[];
  htmlExist: boolean;
  htmlContent?: string;
}
 
                                                                                                                                                C:\Workspace\Web\Ai Business grow project\Back_end\src\users\user.module.ts 
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { UserService } from './user.service';
import { UserSchema } from './user.schema';

@Module({
  imports: [MongooseModule.forFeature([{ name: 'User', schema: UserSchema }])],
  providers: [UserService],
  exports: [UserService],
})
export class UserModule {}
 
                                                                                                                                                C:\Workspace\Web\Ai Business grow project\Back_end\src\users\user.schema.ts 
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document } from 'mongoose';
import * as bcrypt from 'bcrypt';

@Schema()
export class User extends Document {
  @Prop({ required: true })
  username: string;

  @Prop({ required: true, unique: true })
  email: string;

  @Prop({ required: true })
  password: string;

  async comparePassword(enteredPassword: string): Promise<boolean> {
    return await bcrypt.compare(enteredPassword, this.password);
  }
}

export const UserSchema = SchemaFactory.createForClass(User);

UserSchema.pre<User>('save', async function (next) {
  if (!this.isModified('password')) {
    return next();
  }
  
  const salt = await bcrypt.genSalt(10);
  this.password = await bcrypt.hash(this.password, salt);
  next();
});
 
                                                                                                                                                C:\Workspace\Web\Ai Business grow project\Back_end\src\users\user.service.ts 
import { Injectable } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { User } from './user.schema';

@Injectable()
export class UserService {
  constructor(
    @InjectModel(User.name) private userModel: Model<User>,
  ) {}

  async findOne(email: string): Promise<User | undefined> {
    return this.userModel.findOne({ email }).exec();
  }

  async create(userData: any): Promise<User> {
    const user = new this.userModel(userData);
    return user.save();
  }
}
 
